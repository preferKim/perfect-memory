[
    {
        "level": 1,
        "problem": "GoF(Gang of Four)의 디자인 패턴 중 생성(Creational) 패턴에 해당하지 않는 것은?",
        "options": [
            "Abstract Factory",
            "Builder",
            "Adapter",
            "Singleton"
        ],
        "answer": "Adapter",
        "hint": "Adapter 패턴은 구조(Structural) 패턴에 속합니다.",
        "explanation": "Abstract Factory, Builder, Singleton은 생성 패턴이며, Adapter는 클래스나 객체를 조합해 더 큰 구조를 만드는 구조 패턴입니다."
    },
    {
        "level": 1,
        "problem": "UML 다이어그램 중 행위(Behavioral) 다이어그램에 해당하는 것은?",
        "options": [
            "Class Diagram",
            "Component Diagram",
            "Deployment Diagram",
            "State Diagram"
        ],
        "answer": "State Diagram",
        "hint": "시스템의 상태 변화나 동작을 표현하는 다이어그램을 찾으세요.",
        "explanation": "Class, Component, Deployment 다이어그램은 구조(Structural) 다이어그램이며, State(상태) 다이어그램은 객체의 상태 변화를 나타내는 행위 다이어그램입니다."
    },
    {
        "level": 1,
        "problem": "객체지향 설계 원칙(SOLID) 중 '자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야 한다'는 원칙은?",
        "options": [
            "SRP (Single Responsibility Principle)",
            "OCP (Open Closed Principle)",
            "LSP (Liskov Substitution Principle)",
            "ISP (Interface Segregation Principle)"
        ],
        "answer": "LSP (Liskov Substitution Principle)",
        "hint": "리스코프 치환 원칙이라고도 불립니다.",
        "explanation": "LSP는 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 원칙입니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 아키텍처 패턴 중, 서브시스템을 3개의 부분(모델, 뷰, 컨트롤러)으로 구조화하는 패턴은?",
        "options": [
            "Master-Slave",
            "Peer-to-Peer",
            "MVC (Model-View-Controller)",
            "Blackboard"
        ],
        "answer": "MVC (Model-View-Controller)",
        "hint": "사용자 인터페이스와 비즈니스 로직을 분리하는 데 유용합니다.",
        "explanation": "MVC 패턴은 Model(핵심 기능/데이터), View(정보 표시), Controller(입력 처리)로 구성됩니다."
    },
    {
        "level": 1,
        "problem": "다음 중 결합도(Coupling)가 가장 약한(좋은) 것부터 강한(나쁜) 순서대로 바르게 나열한 것은?",
        "options": [
            "Data -> Stamp -> Control -> Common -> Content",
            "Content -> Common -> Control -> Stamp -> Data",
            "Data -> Control -> Stamp -> Common -> Content",
            "Stamp -> Data -> Control -> Content -> Common"
        ],
        "answer": "Data -> Stamp -> Control -> Common -> Content",
        "hint": "결합도는 낮을수록 좋으며, 데이터 결합도가 가장 낮습니다.",
        "explanation": "결합도 순서(약->강): 데이터(Data) -> 스탬프(Stamp) -> 제어(Control) -> 외부(External) -> 공통(Common) -> 내용(Content)."
    },
    {
        "level": 1,
        "problem": "XP(eXtreme Programming)의 5가지 핵심 가치가 아닌 것은?",
        "options": [
            "용기 (Courage)",
            "단순성 (Simplicity)",
            "피드백 (Feedback)",
            "분석 (Analysis)"
        ],
        "answer": "분석 (Analysis)",
        "hint": "XP의 가치는 용기, 단순성, 의사소통, 피드백, 존중입니다.",
        "explanation": "XP의 5가지 가치는 용기, 단순성, 의사소통, 피드백, 존중입니다. 분석은 해당하지 않습니다."
    },
    {
        "level": 1,
        "problem": "요구사항 분석 도구 중 자료 흐름도(DFD)의 구성 요소가 아닌 것은?",
        "options": [
            "Process (처리)",
            "Data Flow (자료 흐름)",
            "Data Store (자료 저장소)",
            "Relationship (관계)"
        ],
        "answer": "Relationship (관계)",
        "hint": "관계(Relationship)는 ERD의 구성 요소입니다.",
        "explanation": "DFD의 구성 요소는 Process(원), Data Flow(화살표), Data Store(평행선), Terminator(사각형)입니다."
    },
    {
        "level": 1,
        "problem": "미들웨어(Middleware)의 종류 중 메시지 지향 미들웨어(MOM)에 대한 설명으로 옳은 것은?",
        "options": [
            "원격 프로시저를 마치 로컬 프로시저처럼 호출한다.",
            "메시지 큐를 활용하여 비동기 데이터 교환을 지원한다.",
            "트랜잭션 처리를 모니터링한다.",
            "객체 지향 시스템 간의 통신을 지원한다."
        ],
        "answer": "메시지 큐를 활용하여 비동기 데이터 교환을 지원한다.",
        "hint": "비동기 통신과 큐(Queue)가 핵심입니다.",
        "explanation": "MOM(Message Oriented Middleware)은 메시지 큐를 이용해 데이터를 비동기적으로 교환하는 미들웨어입니다."
    },
    {
        "level": 1,
        "problem": "UI 설계 원칙 중 '누구나 쉽게 이해하고 사용할 수 있어야 한다'는 원칙은?",
        "options": [
            "직관성 (Intuitiveness)",
            "유효성 (Efficiency)",
            "학습성 (Learnability)",
            "유연성 (Flexibility)"
        ],
        "answer": "직관성 (Intuitiveness)",
        "hint": "별도의 학습 없이 바로 이해할 수 있는 특성입니다.",
        "explanation": "직관성은 사용자가 구조를 쉽게 이해하고 사용법을 빠르게 익힐 수 있어야 한다는 원칙입니다."
    },
    {
        "level": 1,
        "problem": "럼바우(Rumbaugh)의 객체지향 분석 기법에서 가장 먼저 수행되는 분석은?",
        "options": [
            "기능 모델링",
            "동적 모델링",
            "객체 모델링",
            "상태 모델링"
        ],
        "answer": "객체 모델링",
        "hint": "객체를 찾아내고 관계를 규명하는 것이 최우선입니다.",
        "explanation": "럼바우 분석 절차는 객체 모델링 -> 동적 모델링 -> 기능 모델링 순서로 진행됩니다."
    },
    {
        "level": 1,
        "problem": "응집도(Cohesion) 중 모듈 내부의 요소들이 서로 관련 없는 작업들을 수행하며, 논리적인 관계도 없을 때의 응집도는?",
        "options": [
            "우연적 응집도 (Coincidental)",
            "논리적 응집도 (Logical)",
            "시간적 응집도 (Temporal)",
            "절차적 응집도 (Procedural)"
        ],
        "answer": "우연적 응집도 (Coincidental)",
        "hint": "응집도가 가장 낮고 나쁜 경우입니다.",
        "explanation": "우연적 응집도는 모듈 내부 구성 요소들이 아무런 관련 없이 구성된 상태로, 가장 낮은 응집도를 가집니다."
    },
    {
        "level": 1,
        "problem": "UML 관계(Relationship) 중, 하나의 사물이 다른 사물에 포함되어 있는 부분-전체 관계를 나타내며, 전체가 소멸되어도 부분은 독립적으로 존재할 수 있는 관계는?",
        "options": [
            "연관 (Association)",
            "의존 (Dependency)",
            "집합 (Aggregation)",
            "합성 (Composition)"
        ],
        "answer": "집합 (Aggregation)",
        "hint": "빈 마름모로 표시합니다.",
        "explanation": "집합(Aggregation)은 부분 객체가 전체 객체와 독립적인 생명 주기를 가질 때 사용합니다. 반면 합성은 생명 주기를 공유합니다."
    },
    {
        "level": 1,
        "problem": "시스템의 요구사항을 획득하기 위해 이해관계자들이 한 장소에 모여 집중적으로 토의하는 워크숍 형태의 기법은?",
        "options": [
            "인터뷰",
            "설문조사",
            "JAD (Joint Application Development)",
            "롤 플레잉"
        ],
        "answer": "JAD (Joint Application Development)",
        "hint": "사용자와 개발자가 함께 참여하는 공동 작업입니다.",
        "explanation": "JAD는 고객, 사용자, 개발자가 함께 모여 요구사항을 도출하고 명세하는 회의 기법입니다."
    },
    {
        "level": 1,
        "problem": "CASE(Computer Aided Software Engineering) 도구의 주요 기능이 아닌 것은?",
        "options": [
            "소프트웨어 생명 주기 전 단계의 연결",
            "그래픽 지원",
            "다양한 소프트웨어 개발 방법론 지원",
            "언어 번역 및 컴파일 기능 제공"
        ],
        "answer": "언어 번역 및 컴파일 기능 제공",
        "hint": "CASE는 '공학적 기법'을 지원하는 도구 모음이며, 컴파일러와는 구분됩니다.",
        "explanation": "컴파일은 컴파일러의 역할이며, CASE는 개발 방법론, 모델링, 문서화 등을 자동화 지원하는 도구입니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 '행위(Behavioral)' 패턴에 해당하는 것은?",
        "options": [
            "Facade",
            "Observer",
            "Prototype",
            "Bridge"
        ],
        "answer": "Observer",
        "hint": "일대다 의존성을 가지며, 객체의 상태 변화를 통지합니다.",
        "explanation": "Observer 패턴은 행위 패턴입니다. Facade와 Bridge는 구조 패턴, Prototype은 생성 패턴입니다."
    },
    {
        "level": 1,
        "problem": "애자일(Agile) 방법론의 하나로, 스프린트(Sprint)라는 짧은 개발 주기를 반복하는 방식은?",
        "options": [
            "스크럼 (Scrum)",
            "칸반 (Kanban)",
            "린 (Lean)",
            "나선형 (Spiral)"
        ],
        "answer": "스크럼 (Scrum)",
        "hint": "매일 스탠드업 미팅을 하고, 백로그를 관리합니다.",
        "explanation": "스크럼은 2~4주의 스프린트를 반복하며 제품을 점진적으로 개발하는 애자일 프레임워크입니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 아키텍처 4+1 뷰(View) 모델에서 시스템의 비기능적 요구사항(성능, 가용성 등)을 주로 다루는 뷰는?",
        "options": [
            "논리 뷰 (Logical View)",
            "구현 뷰 (Implementation View)",
            "프로세스 뷰 (Process View)",
            "배포 뷰 (Deployment View)"
        ],
        "answer": "프로세스 뷰 (Process View)",
        "hint": "스레드나 프로세스 처리 등 시스템의 동시성과 관련됩니다.",
        "explanation": "프로세스 뷰는 시스템의 동시성, 동기화, 성능 등 비기능적 요구사항을 표현합니다."
    },
    {
        "level": 1,
        "problem": "HIPO(Hierarchy Input Process Output)에 대한 설명으로 틀린 것은?",
        "options": [
            "하향식 소프트웨어 개발을 위한 문서화 도구이다.",
            "가시적 도표, 총체적 도표, 세부적 도표로 구성된다.",
            "기능과 자료의 의존 관계를 동시에 표현한다.",
            "상향식 개발 방법에 적합하다."
        ],
        "answer": "상향식 개발 방법에 적합하다.",
        "hint": "HIPO는 하향식(Top-Down) 설계를 지원합니다.",
        "explanation": "HIPO는 하향식 소프트웨어 개발을 위한 문서화 도구입니다."
    },
    {
        "level": 1,
        "problem": "코드 설계 시 코드의 기능으로 거리가 먼 것은?",
        "options": [
            "표준화",
            "간소화",
            "연산",
            "식별"
        ],
        "answer": "연산",
        "hint": "코드는 대상을 구분하거나 분류하기 위한 것이 주 목적입니다.",
        "explanation": "코드의 주요 기능은 식별, 분류, 배열, 표준화, 간소화 등이며, 복잡한 수치 연산은 주 기능이 아닙니다."
    },
    {
        "level": 1,
        "problem": "UML 다이어그램에서 클래스의 접근 제어자(Access Modifier) 표시가 잘못된 것은?",
        "options": [
            "+ : Public",
            "- : Private",
            "# : Protected",
            "~ : Static"
        ],
        "answer": "~ : Static",
        "hint": "물결표(~)는 패키지(Package) 접근을 의미합니다.",
        "explanation": "~는 Package 접근 제어자를 의미하며, Static은 밑줄(underline)로 표시합니다."
    },
    {
        "level": 1,
        "problem": "요구사항 검토 방법 중, 작성자가 명세서를 설명하고 검토자들이 결함을 발견하는 형태는?",
        "options": [
            "동료 검토 (Peer Review)",
            "워크스루 (Walkthrough)",
            "인스펙션 (Inspection)",
            "프로토타이핑"
        ],
        "answer": "워크스루 (Walkthrough)",
        "hint": "회의 주관을 작성자가 하며, 비공식적인 성격이 강합니다.",
        "explanation": "워크스루는 작성자가 주체가 되어 시나리오를 흐름에 따라 검토하는 비정형 검토 회의입니다."
    },
    {
        "level": 1,
        "problem": "객체지향 기법에서 같은 이름의 메소드가 인자(Argument)의 개수나 타입에 따라 다르게 동작하는 기술은?",
        "options": [
            "오버로딩 (Overloading)",
            "오버라이딩 (Overriding)",
            "추상화 (Abstraction)",
            "상속 (Inheritance)"
        ],
        "answer": "오버로딩 (Overloading)",
        "hint": "중복 정의라고도 합니다.",
        "explanation": "오버로딩은 같은 이름의 메소드를 매개변수의 유형이나 개수를 다르게 하여 여러 개 정의하는 것입니다."
    },
    {
        "level": 1,
        "problem": "현행 시스템 분석 시 고려사항 중 '운영체제' 분석 항목에 해당하지 않는 것은?",
        "options": [
            "종류 및 버전",
            "패치 및 업데이트 날짜",
            "백업 주기",
            "네트워크 구성도"
        ],
        "answer": "네트워크 구성도",
        "hint": "네트워크 구성도는 네트워크 분석 항목입니다.",
        "explanation": "네트워크 구성도는 네트워크 현황 분석 시 필요한 항목입니다."
    },
    {
        "level": 1,
        "problem": "설계 모델링 중 '구조적 다이어그램'이 아닌 것은?",
        "options": [
            "클래스 다이어그램",
            "패키지 다이어그램",
            "활동 다이어그램",
            "복합 구조 다이어그램"
        ],
        "answer": "활동 다이어그램",
        "hint": "Activity Diagram은 흐름을 보여줍니다.",
        "explanation": "활동(Activity) 다이어그램은 행위(Behavioral) 다이어그램에 속합니다."
    },
    {
        "level": 1,
        "problem": "나씨-슈나이더만(Nassi-Shneiderman) 차트의 특징이 아닌 것은?",
        "options": [
            "논리적 구조를 박스 형태로 표현한다.",
            "GOTO 문을 쉽게 표현할 수 있다.",
            "순차, 선택, 반복 구조를 표현한다.",
            "제어 흐름을 직관적으로 볼 수 있다."
        ],
        "answer": "GOTO 문을 쉽게 표현할 수 있다.",
        "hint": "구조적 프로그래밍을 위해 고안되었습니다.",
        "explanation": "N-S 차트는 GOTO 문을 사용하지 않는 구조적 프로그래밍을 표현하기 위한 도구입니다."
    },
    {
        "level": 1,
        "problem": "다음 설명에 해당하는 디자인 패턴은? '복잡한 인스턴스를 조립하여 만드는 구조로, 생성 과정을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있다.'",
        "options": [
            "Factory Method",
            "Prototype",
            "Builder",
            "Singleton"
        ],
        "answer": "Builder",
        "hint": "건축가가 건물을 짓는 과정을 생각해보세요.",
        "explanation": "Builder 패턴은 복잡한 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 다른 결과를 만들어냅니다."
    },
    {
        "level": 1,
        "problem": "사용자 인터페이스(UI) 설계 시 사용자가 시스템의 동작을 예측할 수 있도록 도와주는 장치는?",
        "options": [
            "메타포 (Metaphor)",
            "내비게이션",
            "피드백",
            "디버깅"
        ],
        "answer": "메타포 (Metaphor)",
        "hint": "현실 세계의 사물을 빗대어 표현하는 것입니다. (예: 휴지통 아이콘)",
        "explanation": "메타포는 시스템의 기능을 사용자가 익숙한 현실 세계의 개념에 빗대어 표현하여 이해를 돕습니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 개발 단계에서 오류가 늦게 발견될수록 수정 비용이 기하급수적으로 증가한다는 법칙은?",
        "options": [
            "브룩스의 법칙",
            "보엠의 법칙",
            "파레토 법칙",
            "무어의 법칙"
        ],
        "answer": "보엠의 법칙",
        "hint": "비용 수정의 관점입니다.",
        "explanation": "보엠(Boehm)은 개발 후반부로 갈수록 결함 수정 비용이 급격히 증가한다고 주장했습니다."
    },
    {
        "level": 1,
        "problem": "객체지향 개념 중 '하나의 클래스가 여러 개의 상위 클래스로부터 속성과 연산을 물려받는 것'은?",
        "options": [
            "단일 상속",
            "다중 상속",
            "캡슐화",
            "정보 은닉"
        ],
        "answer": "다중 상속",
        "hint": "부모가 여럿인 경우입니다.",
        "explanation": "다중 상속(Multiple Inheritance)은 두 개 이상의 상위 클래스로부터 상속받는 것을 말합니다."
    },
    {
        "level": 1,
        "problem": "자료 사전(Data Dictionary)에서 반복(Repetition)을 나타내는 기호는?",
        "options": [
            "=",
            "+",
            "{ }",
            "[ ]"
        ],
        "answer": "{ }",
        "hint": "중괄호를 사용합니다.",
        "explanation": "{ }는 자료의 반복을 의미하며, [ ]는 선택, +는 연결, =는 정의를 의미합니다."
    },
    {
        "level": 1,
        "problem": "미들웨어 중 클라이언트와 서버 간의 트랜잭션을 처리하고 감시하며 데이터 무결성을 보장하는 것은?",
        "options": [
            "RPC",
            "ORB",
            "TP-Monitor",
            "WAS"
        ],
        "answer": "TP-Monitor",
        "hint": "트랜잭션 처리가 핵심입니다.",
        "explanation": "TP-Monitor(Transaction Processing Monitor)는 트랜잭션 처리를 감시하고 제어하는 미들웨어입니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 'Proxy' 패턴의 용도로 적절하지 않은 것은?",
        "options": [
            "접근 제어",
            "복잡한 객체 생성 단순화",
            "데이터 캐싱",
            "원격 객체 호출"
        ],
        "answer": "복잡한 객체 생성 단순화",
        "hint": "생성 단순화는 Facade나 Builder 등의 역할에 가깝습니다.",
        "explanation": "Proxy는 대리자 역할을 하며 접근 제어, 캐싱, 원격 호출 등에 사용됩니다. 생성 단순화는 주로 생성 패턴의 역할입니다."
    },
    {
        "level": 1,
        "problem": "요구사항 분석 시 비기능적 요구사항에 해당하는 것은?",
        "options": [
            "시스템은 회원가입 기능을 제공해야 한다.",
            "시스템은 24시간 99.9% 가동되어야 한다.",
            "관리자는 게시물을 삭제할 수 있어야 한다.",
            "사용자는 상품을 검색할 수 있어야 한다."
        ],
        "answer": "시스템은 24시간 99.9% 가동되어야 한다.",
        "hint": "성능, 신뢰성, 보안 등 품질에 관한 사항입니다.",
        "explanation": "가동률, 성능, 보안 등은 비기능적 요구사항이며, 나머지는 기능적 요구사항입니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 설계를 위한 지침으로 적절하지 않은 것은?",
        "options": [
            "모듈 간의 결합도를 높인다.",
            "모듈 내부의 응집도를 높인다.",
            "적절한 모듈 크기를 유지한다.",
            "이식성을 고려한다."
        ],
        "answer": "모듈 간의 결합도를 높인다.",
        "hint": "결합도는 낮추는(Loose Coupling) 것이 좋습니다.",
        "explanation": "좋은 설계는 모듈 간의 결합도는 낮추고, 응집도는 높이는 것입니다."
    },
    {
        "level": 1,
        "problem": "유스케이스(Use Case) 다이어그램의 구성 요소가 아닌 것은?",
        "options": [
            "System Boundary (시스템 경계)",
            "Actor (액터)",
            "Use Case (유스케이스)",
            "Message (메시지)"
        ],
        "answer": "Message (메시지)",
        "hint": "메시지는 시퀀스 다이어그램 등에서 사용됩니다.",
        "explanation": "메시지는 주로 시퀀스 다이어그램에서 객체 간 상호작용을 표현할 때 사용합니다."
    },
    {
        "level": 1,
        "problem": "코드의 오류 발생 시 이를 쉽게 감지하거나 정정할 수 있는 코드는?",
        "options": [
            "순차 코드",
            "블록 코드",
            "해밍 코드",
            "표의 숫자 코드"
        ],
        "answer": "해밍 코드",
        "hint": "오류 검출 및 교정 기능을 가집니다.",
        "explanation": "해밍 코드(Hamming Code)는 오류 검출 및 교정이 가능한 코드입니다."
    },
    {
        "level": 1,
        "problem": "다음 중 Fan-in(팬인)이 높고 Fan-out(팬아웃)이 낮은 모듈의 특징은?",
        "options": [
            "많은 모듈을 제어한다.",
            "많은 모듈로부터 호출을 받는다.",
            "복잡도가 매우 높다.",
            "시스템의 최상위 모듈일 가능성이 높다."
        ],
        "answer": "많은 모듈로부터 호출을 받는다.",
        "hint": "Fan-in은 들어오는 화살표 수입니다.",
        "explanation": "Fan-in이 높다는 것은 여러 모듈에서 해당 모듈을 호출(사용)한다는 의미로, 공통 모듈일 가능성이 높습니다."
    },
    {
        "level": 1,
        "problem": "럼바우 객체지향 분석에서 상태 다이어그램(State Diagram)을 사용하는 모델링은?",
        "options": [
            "객체 모델링",
            "동적 모델링",
            "기능 모델링",
            "정적 모델링"
        ],
        "answer": "동적 모델링",
        "hint": "시간의 흐름에 따른 상태 변화를 다룹니다.",
        "explanation": "동적 모델링은 객체의 상태 변화와 시간의 흐름에 따른 행위를 상태 다이어그램으로 표현합니다."
    },
    {
        "level": 1,
        "problem": "GoF 디자인 패턴 중 Facade 패턴의 특징은?",
        "options": [
            "객체의 내부 구조를 노출하지 않고 순차적으로 접근한다.",
            "복잡한 서브시스템에 대한 단순한 인터페이스를 제공한다.",
            "한 객체의 상태가 바뀌면 의존하는 객체들에게 알린다.",
            "알고리즘군을 정의하고 각각을 캡슐화한다."
        ],
        "answer": "복잡한 서브시스템에 대한 단순한 인터페이스를 제공한다.",
        "hint": "건물의 정면(Facade)처럼 복잡한 내부를 가리고 입구를 하나로 만드는 것입니다.",
        "explanation": "Facade 패턴은 복잡한 시스템 내부 구조를 감추고 외부에서 사용하기 편한 통합 인터페이스를 제공합니다."
    },
    {
        "level": 1,
        "problem": "요구사항 확인 프로세스 순서로 옳은 것은?",
        "options": [
            "도출 -> 분석 -> 명세 -> 확인",
            "분석 -> 도출 -> 명세 -> 확인",
            "명세 -> 도출 -> 분석 -> 확인",
            "도출 -> 명세 -> 분석 -> 확인"
        ],
        "answer": "도출 -> 분석 -> 명세 -> 확인",
        "hint": "먼저 요구사항을 찾아내야 합니다.",
        "explanation": "요구사항 관리는 도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Verification) 순으로 진행됩니다."
    },
    {
        "level": 1,
        "problem": "UML에서 시퀀스 다이어그램(Sequence Diagram)의 구성 요소가 아닌 것은?",
        "options": [
            "Lifeline (생명선)",
            "Activation (실행)",
            "Message (메시지)",
            "Swimlane (스윔레인)"
        ],
        "answer": "Swimlane (스윔레인)",
        "hint": "수영장 레인처럼 구역을 나누는 것은 활동 다이어그램 요소입니다.",
        "explanation": "Swimlane은 활동 다이어그램에서 활동의 주체를 구분하기 위해 사용됩니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 공학에서 '재사용(Reuse)'의 이점이 아닌 것은?",
        "options": [
            "개발 시간 단축",
            "비용 절감",
            "품질 향상",
            "새로운 기술 도입의 용이성"
        ],
        "answer": "새로운 기술 도입의 용이성",
        "hint": "재사용은 기존의 검증된 코드를 쓰는 것입니다.",
        "explanation": "재사용은 기존 자원을 활용하므로 최신 기술 도입을 오히려 저해할 수 있는 단점이 있습니다."
    },
    {
        "level": 1,
        "problem": "사용자 인터페이스(UI) 설계 도구 중, 화면 구성을 시각적으로 보여주는 정적인 도안으로, 기능은 작동하지 않는 것은?",
        "options": [
            "와이어프레임 (Wireframe)",
            "목업 (Mockup)",
            "프로토타입 (Prototype)",
            "스토리보드 (Storyboard)"
        ],
        "answer": "목업 (Mockup)",
        "hint": "실제처럼 보이지만 껍데기만 있는 디자인 시안입니다.",
        "explanation": "목업은 디자인, 색상 등을 반영하여 정적인 형태의 결과물을 보여주는 시각적 모델입니다. (와이어프레임은 선 위주의 뼈대)"
    },
    {
        "level": 1,
        "problem": "다음 중 자료 흐름도(DFD) 작성 원칙이 아닌 것은?",
        "options": [
            "자료 보존의 원칙",
            "최소 비용의 원칙",
            "자료 흐름의 연속성",
            "순차 처리의 원칙"
        ],
        "answer": "순차 처리의 원칙",
        "hint": "DFD는 흐름을 나타내지, 제어 순서를 강제하지 않습니다.",
        "explanation": "DFD는 데이터의 흐름을 나타낼 뿐, 프로세스의 순차적 실행 순서를 명시적으로 나타내지는 않습니다."
    },
    {
        "level": 1,
        "problem": "애자일 모형 중 '테스트 주도 개발(TDD)'을 포함하며, 짝 프로그래밍을 권장하는 방법론은?",
        "options": [
            "XP (eXtreme Programming)",
            "SCRUM",
            "Crystal",
            "FDD"
        ],
        "answer": "XP (eXtreme Programming)",
        "hint": "극한의 프로그래밍이라는 뜻입니다.",
        "explanation": "XP는 TDD, 짝 프로그래밍, 지속적 통합(CI) 등을 실천 항목으로 강조합니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 패턴은?",
        "options": [
            "Template Method",
            "Strategy",
            "Command",
            "Iterator"
        ],
        "answer": "Template Method",
        "hint": "템플릿(견본)을 만들어 둔다고 생각하세요.",
        "explanation": "Template Method 패턴은 알고리즘의 구조를 상위 클래스에 정의하고, 구체적인 단계는 하위 클래스에서 구현합니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 품질 목표 중 '사용자가 요구하는 기능을 얼마나 정확하게 수행하는가'를 나타내는 것은?",
        "options": [
            "정확성 (Correctness)",
            "신뢰성 (Reliability)",
            "효율성 (Efficiency)",
            "이식성 (Portability)"
        ],
        "answer": "정확성 (Correctness)",
        "hint": "기능이 맞게 돌아가는지 확인하는 것입니다.",
        "explanation": "정확성은 사용자의 요구 기능을 충족시키며 오류 없이 수행하는 정도를 의미합니다."
    },
    {
        "level": 1,
        "problem": "다음 중 인터페이스 요구사항 검증 방법이 아닌 것은?",
        "options": [
            "동료 검토",
            "워크스루",
            "인스펙션",
            "벤치마킹"
        ],
        "answer": "벤치마킹",
        "hint": "벤치마킹은 타사 사례를 비교 분석하는 경영 기법에 가깝습니다.",
        "explanation": "인터페이스 요구사항 검증에는 동료 검토, 워크스루, 인스펙션 등의 정적 테스트 기법이 주로 사용됩니다."
    },
    {
        "level": 1,
        "problem": "UML의 스테레오 타입(Stereotype)을 표현할 때 사용하는 기호는?",
        "options": [
            "<< >>",
            "{{ }}",
            "[[ ]]",
            "(( ))"
        ],
        "answer": "<< >>",
        "hint": "길러멧(Guillemets)이라고 부릅니다.",
        "explanation": "스테레오 타입은 <<include>>, <<extend>>와 같이 겹화살괄호(Guillemets)를 사용하여 표현합니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 개발 원가 산정 기법 중, 전문가들의 주관적인 편견을 배제하기 위해 익명으로 의견을 수렴하는 기법은?",
        "options": [
            "델파이 기법 (Delphi Method)",
            "LOC 기법",
            "COCOMO 모형",
            "기능 점수 모형"
        ],
        "answer": "델파이 기법 (Delphi Method)",
        "hint": "여러 전문가의 의견을 중재자가 조정합니다.",
        "explanation": "델파이 기법은 전문가들의 의견을 익명으로 수렴하고 조정하여 비용을 산정하는 방법입니다."
    },
    {
        "level": 1,
        "problem": "GoF 디자인 패턴 중 '구조(Structural)' 패턴에 해당하는 것은?",
        "options": [
            "Decorator",
            "Observer",
            "Command",
            "State"
        ],
        "answer": "Decorator",
        "hint": "객체에 동적으로 새로운 책임을 추가할 때 유용합니다.",
        "explanation": "Decorator는 구조 패턴이며, Observer, Command, State는 행위 패턴입니다."
    },
    {
        "level": 1,
        "problem": "럼바우(Rumbaugh) 분석 기법에서 '자료 흐름도(DFD)'를 주로 사용하는 모델링 단계는?",
        "options": [
            "객체 모델링",
            "동적 모델링",
            "기능 모델링",
            "구조 모델링"
        ],
        "answer": "기능 모델링",
        "hint": "데이터가 어떻게 처리되는지 보여줍니다.",
        "explanation": "기능 모델링(Functional Modeling)에서는 자료 흐름도(DFD)를 사용하여 다수의 프로세스 간 자료 흐름을 중심으로 처리 과정을 표현합니다."
    },
    {
        "level": 1,
        "problem": "UI 설계 지침 중 '사용자가 의도한 대로 오류 없이 상호작용할 수 있어야 한다'는 개념은?",
        "options": [
            "가시성",
            "무결성",
            "유연성",
            "심미성"
        ],
        "answer": "무결성",
        "hint": "시스템의 정보가 정확하게 전달되어야 합니다.",
        "explanation": "무결성(Integrity)은 시스템의 데이터가 오염되거나 왜곡되지 않고 정확하게 유지되는 특성을 말하지만, UI 맥락에서는 사용자의 조작이 오류 없이 전달되는 것을 의미하기도 합니다."
    },
    {
        "level": 1,
        "problem": "UML 다이어그램 중 시스템을 구성하는 물리적인 하드웨어와 네트워크 구성을 보여주는 것은?",
        "options": [
            "배포 다이어그램 (Deployment Diagram)",
            "컴포넌트 다이어그램",
            "패키지 다이어그램",
            "복합 구조 다이어그램"
        ],
        "answer": "배포 다이어그램 (Deployment Diagram)",
        "hint": "서버, 노드, 통신 경로 등이 나옵니다.",
        "explanation": "배포 다이어그램은 소프트웨어 컴포넌트가 물리적인 노드(하드웨어)에 어떻게 배치되는지를 나타냅니다."
    },
    {
        "level": 1,
        "problem": "객체지향 설계 원칙(SOLID) 중 '클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다'는 원칙은?",
        "options": [
            "SRP",
            "OCP",
            "LSP",
            "ISP"
        ],
        "answer": "ISP",
        "hint": "인터페이스 분리 원칙입니다.",
        "explanation": "ISP(Interface Segregation Principle)는 범용 인터페이스 하나보다는, 클라이언트에 특화된 여러 개의 인터페이스가 낫다는 원칙입니다."
    },
    {
        "level": 1,
        "problem": "현행 시스템 분석 단계에서 '플랫폼' 분석 시 고려사항이 아닌 것은?",
        "options": [
            "운영체제 종류",
            "웹 애플리케이션 서버(WAS) 종류",
            "데이터베이스 관리 시스템(DBMS) 종류",
            "네트워크 회선 요금"
        ],
        "answer": "네트워크 회선 요금",
        "hint": "기술적인 환경 분석에 집중해야 합니다.",
        "explanation": "플랫폼 분석은 OS, DBMS, Middleware 등의 기술적 환경을 분석하는 것이며, 요금은 비용 분석에 해당합니다."
    },
    {
        "level": 1,
        "problem": "요구사항 명세 기법 중 '정형 명세 기법'의 특징이 아닌 것은?",
        "options": [
            "수학적 기호 사용",
            "표현의 간결성",
            "이해의 용이성",
            "검증의 정확성"
        ],
        "answer": "이해의 용이성",
        "hint": "수학적 기호를 사용하므로 일반인은 이해하기 어렵습니다.",
        "explanation": "정형 명세 기법(Z, VDM 등)은 수학적 원리를 기반으로 하여 정확하고 간결하지만, 사용자가 이해하기 어렵다는 단점이 있습니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 '이미 생성된 인스턴스를 저장해 두고, 동일한 요청이 들어오면 저장된 인스턴스를 반환하여 객체 생성을 제한'하는 패턴은?",
        "options": [
            "Singleton",
            "Factory Method",
            "Prototype",
            "Adapter"
        ],
        "answer": "Singleton",
        "hint": "오직 하나의 인스턴스만 존재합니다.",
        "explanation": "Singleton 패턴은 클래스의 인스턴스가 하나만 생성되도록 보장하고, 전역적인 접근점을 제공합니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 아키텍처 패턴 중 '파이프-필터(Pipe-Filter)' 패턴의 장점은?",
        "options": [
            "상호작용이 복잡하다.",
            "데이터 변환 과정을 재사용하기 쉽다.",
            "이벤트 처리에 적합하다.",
            "사용자 인터페이스 구현에 유리하다."
        ],
        "answer": "데이터 변환 과정을 재사용하기 쉽다.",
        "hint": "UNIX 쉘 명령어를 생각해보세요.",
        "explanation": "파이프-필터 패턴은 데이터 스트림을 단계별로 처리하며, 각 필터(처리 모듈)를 독립적으로 재사용하거나 확장이 용이합니다."
    },
    {
        "level": 1,
        "problem": "자료 사전(Data Dictionary)에서 '선택(Selection)'을 의미하는 기호는?",
        "options": [
            "{ }",
            "[ ]",
            "( )",
            "+"
        ],
        "answer": "[ ]",
        "hint": "대괄호를 사용합니다.",
        "explanation": "[ ]는 나열된 항목 중 하나를 선택함을 의미하며, ( )는 생략 가능, { }는 반복을 의미합니다."
    },
    {
        "level": 1,
        "problem": "애자일 방법론 중 하나로, '칸반(Kanban)' 보드를 사용하여 작업 흐름을 시각화하고 WIP(Work In Process)를 제한하는 방식은?",
        "options": [
            "린(Lean)",
            "크리스탈(Crystal)",
            "스크럼(Scrum)",
            "FDD"
        ],
        "answer": "린(Lean)",
        "hint": "도요타 생산 시스템에서 유래했습니다.",
        "explanation": "린(Lean) 소프트웨어 개발은 낭비를 제거하고 흐름을 최적화하는 데 중점을 두며, 칸반 시스템을 자주 활용합니다."
    },
    {
        "level": 1,
        "problem": "다음 중 결합도(Coupling)가 가장 높은(나쁜) 것은?",
        "options": [
            "Control Coupling",
            "Stamp Coupling",
            "Content Coupling",
            "Common Coupling"
        ],
        "answer": "Content Coupling",
        "hint": "한 모듈이 다른 모듈의 내부 기능이나 데이터를 직접 참조합니다.",
        "explanation": "내용 결합도(Content Coupling)는 한 모듈이 다른 모듈의 내부 로직을 직접 수정하거나 사용할 때 발생하며 가장 강한 결합도를 가집니다."
    },
    {
        "level": 1,
        "problem": "유스케이스 다이어그램에서 '포함(Include)' 관계에 대한 설명으로 옳은 것은?",
        "options": [
            "선택적으로 수행되는 기능이다.",
            "반드시 수행되어야 하는 기능이다.",
            "특정 조건에서만 확장되는 기능이다.",
            "상속 관계와 동일하다."
        ],
        "answer": "반드시 수행되어야 하는 기능이다.",
        "hint": "로그인 후 결제하기처럼 필수적인 전제 조건입니다.",
        "explanation": "<<include>> 관계는 기초 유스케이스를 수행할 때 반드시 실행되어야 하는 포함된 유스케이스를 의미합니다."
    },
    {
        "level": 1,
        "problem": "HCI(Human Computer Interaction)의 3대 요소가 아닌 것은?",
        "options": [
            "사용자(User)",
            "컴퓨터(Computer)",
            "상호작용(Interaction)",
            "네트워크(Network)"
        ],
        "answer": "네트워크(Network)",
        "hint": "사람과 시스템의 대화입니다.",
        "explanation": "HCI의 3요소는 사용자, 컴퓨터(시스템), 그리고 그 둘 사이의 상호작용입니다."
    },
    {
        "level": 1,
        "problem": "객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 데이터 중심의 설계를 강조하는 기법은?",
        "options": [
            "Coad-Yourdon",
            "Booch",
            "Jacobson",
            "Wirfs-Brock"
        ],
        "answer": "Coad-Yourdon",
        "hint": "E-R 다이어그램을 객체지향에 도입했습니다.",
        "explanation": "Coad-Yourdon 방법론은 E-R 다이어그램을 사용하여 객체 모델링을 수행합니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 'Mediator(중재자)' 패턴의 목적은?",
        "options": [
            "객체들 간의 복잡한 상호작용을 캡슐화하여 결합도를 낮춘다.",
            "객체의 내부 상태를 저장한다.",
            "알고리즘을 객체로 캡슐화한다.",
            "요청을 처리할 수 있는 객체를 체인으로 연결한다."
        ],
        "answer": "객체들 간의 복잡한 상호작용을 캡슐화하여 결합도를 낮춘다.",
        "hint": "M:N 관계를 1:N 관계로 단순화합니다.",
        "explanation": "Mediator 패턴은 객체 간의 통신을 중재자 객체가 전담하게 하여 객체 간의 결합도를 낮춥니다."
    },
    {
        "level": 1,
        "problem": "요구사항 검증(Verification)과 확인(Validation)의 차이에 대한 설명으로 옳은 것은?",
        "options": [
            "검증은 '올바른 제품을 만들고 있는가?'를 확인한다.",
            "확인은 '제품을 올바르게 만들고 있는가?'를 확인한다.",
            "검증은 개발자 관점, 확인은 사용자 관점이다.",
            "두 용어는 완전히 동일한 의미이다."
        ],
        "answer": "검증은 개발자 관점, 확인은 사용자 관점이다.",
        "hint": "Verification(검증): 명세서대로? / Validation(확인): 사용자 요구대로?",
        "explanation": "검증(Verification)은 '제품을 올바르게 만들고 있는가(명세 준수)'를, 확인(Validation)은 '올바른 제품을 만들고 있는가(사용자 요구 충족)'를 봅니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 비용 산정 모형 중, Rayleigh-Norden 곡선을 기초로 하여 개발 기간과 인력 배분을 분석하는 모형은?",
        "options": [
            "Putnam 모형",
            "COCOMO",
            "Function Point",
            "Delphi"
        ],
        "answer": "Putnam 모형",
        "hint": "SLIM이라는 자동화 도구가 있습니다.",
        "explanation": "Putnam 모형은 시간에 따른 함수로 노력의 분포를 가정하는 모형입니다."
    },
    {
        "level": 1,
        "problem": "UML에서 인터페이스(Interface)를 구현(Realization)함을 나타내는 화살표 모양은?",
        "options": [
            "실선과 꽉 찬 삼각형",
            "점선과 빈 삼각형",
            "실선과 빈 삼각형",
            "점선과 화살표"
        ],
        "answer": "점선과 빈 삼각형",
        "hint": "상속(일반화)과 비슷하지만 점선입니다.",
        "explanation": "구현(Realization) 관계는 점선과 비어 있는 삼각형 머리 화살표로 표현합니다."
    },
    {
        "level": 1,
        "problem": "다음 중 응집도(Cohesion)가 가장 높은(좋은) 것은?",
        "options": [
            "기능적 응집도 (Functional)",
            "순차적 응집도 (Sequential)",
            "교환적 응집도 (Communication)",
            "절차적 응집도 (Procedural)"
        ],
        "answer": "기능적 응집도 (Functional)",
        "hint": "모듈 내 모든 요소가 단 하나의 기능을 수행합니다.",
        "explanation": "기능적 응집도가 가장 높고 강력한 응집도입니다. (순서: 기능 > 순차 > 교환 > 절차 > 시간 > 논리 > 우연)"
    },
    {
        "level": 1,
        "problem": "소프트웨어 아키텍처 중 'Master-Slave' 패턴이 주로 사용되는 분야는?",
        "options": [
            "실시간 시스템의 병렬 계산",
            "단순 웹 사이트",
            "데이터베이스 모델링",
            "문서 편집기"
        ],
        "answer": "실시간 시스템의 병렬 계산",
        "hint": "주인이 작업을 나누어 노예에게 시키고 결과를 취합합니다.",
        "explanation": "Master-Slave 패턴은 마스터가 슬레이브들에게 작업을 분할하고, 처리 결과를 취합하는 방식으로 연산 집약적인 작업이나 병렬 처리에 적합합니다."
    },
    {
        "level": 1,
        "problem": "UI 시나리오 문서 작성 요건으로 적절하지 않은 것은?",
        "options": [
            "완전성",
            "일관성",
            "추상성",
            "가독성"
        ],
        "answer": "추상성",
        "hint": "문서는 구체적이어야 합니다.",
        "explanation": "시나리오는 개발자가 명확히 이해할 수 있도록 구체적이고 명확하게 작성되어야 하며, 추상적인 표현은 피해야 합니다."
    },
    {
        "level": 1,
        "problem": "객체지향 기법에서 '캡슐화(Encapsulation)'의 장점이 아닌 것은?",
        "options": [
            "정보 은닉을 통한 보안성 향상",
            "모듈 간의 결합도 증가",
            "소프트웨어 재사용성 향상",
            "인터페이스 단순화"
        ],
        "answer": "모듈 간의 결합도 증가",
        "hint": "캡슐화는 내부를 감추므로 결합도를 낮춥니다.",
        "explanation": "캡슐화는 내부 구현을 감추고 인터페이스만 제공하므로 모듈 간의 결합도를 낮추는(Loose Coupling) 효과가 있습니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 'Interpreter' 패턴이 사용되는 경우는?",
        "options": [
            "언어의 문법 표현 및 해석",
            "객체의 상태 복원",
            "알고리즘 교체",
            "객체 생성 위임"
        ],
        "answer": "언어의 문법 표현 및 해석",
        "hint": "SQL 파싱이나 정규표현식 엔진 등에 쓰입니다.",
        "explanation": "Interpreter 패턴은 특정 언어의 문법을 정의하고, 이를 해석하는 해석기를 구현할 때 사용합니다."
    },
    {
        "level": 1,
        "problem": "미들웨어 중 'ORB(Object Request Broker)'의 역할은?",
        "options": [
            "객체 지향 시스템에서 객체 간의 통신을 돕는다.",
            "데이터베이스 트랜잭션을 관리한다.",
            "메시지 큐를 관리한다.",
            "보안 인증을 담당한다."
        ],
        "answer": "객체 지향 시스템에서 객체 간의 통신을 돕는다.",
        "hint": "CORBA 표준과 관련 있습니다.",
        "explanation": "ORB는 분산 객체 환경에서 객체 간의 요청과 응답을 중개하는 역할을 합니다."
    },
    {
        "level": 1,
        "problem": "다음 중 비기능적 요구사항이 아닌 것은?",
        "options": [
            "응답 시간은 3초 이내여야 한다.",
            "사용자 정보는 암호화하여 저장해야 한다.",
            "시스템은 주문 내역을 조회할 수 있어야 한다.",
            "동시 접속자는 1000명을 수용해야 한다."
        ],
        "answer": "시스템은 주문 내역을 조회할 수 있어야 한다.",
        "hint": "'무엇을 하는가'에 대한 내용은 기능 요구사항입니다.",
        "explanation": "주문 내역 조회는 시스템이 수행해야 할 기능(Function)이므로 기능적 요구사항입니다. 나머지는 성능, 보안 등 품질(Non-functional) 속성입니다."
    },
    {
        "level": 1,
        "problem": "CASE 도구의 분류 중 'Upper CASE'가 지원하는 단계는?",
        "options": [
            "요구 분석 및 설계",
            "코드 작성",
            "테스트",
            "유지보수"
        ],
        "answer": "요구 분석 및 설계",
        "hint": "소프트웨어 생명 주기의 앞부분(상위)을 담당합니다.",
        "explanation": "Upper CASE는 계획, 분석, 설계 단계를 지원하며, Lower CASE는 구현, 테스트 단계를 지원합니다."
    },
    {
        "level": 1,
        "problem": "UML 시퀀스 다이어그램에서 '비동기 메시지'를 나타내는 화살표는?",
        "options": [
            "꽉 찬 화살표 머리",
            "열린(선으로 된) 화살표 머리",
            "점선 화살표",
            "이중 실선 화살표"
        ],
        "answer": "열린(선으로 된) 화살표 머리",
        "hint": "동기 메시지는 꽉 찬 삼각형 머리입니다.",
        "explanation": "비동기 메시지는 화살표 머리가 선으로 된 열린 모양(Open Arrowhead)을 사용합니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 'Chain of Responsibility(책임 연쇄)' 패턴의 특징은?",
        "options": [
            "요청을 처리할 수 있는 객체들이 고리로 연결되어 있어, 처리될 때까지 다음 객체로 넘어간다.",
            "객체 간의 1:N 의존성을 정의한다.",
            "복잡한 서브시스템을 단순화한다.",
            "객체의 생성 비용을 줄인다."
        ],
        "answer": "요청을 처리할 수 있는 객체들이 고리로 연결되어 있어, 처리될 때까지 다음 객체로 넘어간다.",
        "hint": "책임을 떠넘기는 구조입니다.",
        "explanation": "요청을 보내는 객체와 처리하는 객체를 분리하고, 처리 객체들을 체인으로 연결하여 차례대로 처리 기회를 주는 패턴입니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 설계 시 '공통 모듈' 명세 기법에 해당하지 않는 것은?",
        "options": [
            "정확성",
            "명확성",
            "완전성",
            "주관성"
        ],
        "answer": "주관성",
        "hint": "공통 모듈은 누구나 똑같이 이해해야 합니다.",
        "explanation": "공통 모듈 명세는 정확성, 명확성, 완전성, 일관성, 추적성을 갖춰야 하며, 주관적이면 안 됩니다."
    },
    {
        "level": 1,
        "problem": "XP(eXtreme Programming)의 실천 사항(Practice) 중, '지속적인 통합(CI)'의 의미는?",
        "options": [
            "코드를 매일 여러 번 통합하고 빌드한다.",
            "고객을 개발 과정에 참여시킨다.",
            "두 명이 짝을 지어 코딩한다.",
            "테스트 케이스를 먼저 작성한다."
        ],
        "answer": "코드를 매일 여러 번 통합하고 빌드한다.",
        "hint": "Integration을 자주 합니다.",
        "explanation": "Continuous Integration(CI)은 작업한 코드를 빈번하게 통합하여 통합 시 발생하는 오류를 조기에 발견하고 해결하는 것입니다."
    },
    {
        "level": 1,
        "problem": "다음 중 사용자 인터페이스(UI) 설계의 기본 원칙인 '유효성(Efficiency)'의 의미는?",
        "options": [
            "사용자의 목적을 정확하고 완벽하게 달성해야 한다.",
            "사용자의 목표 달성을 위해 자원을 적게 사용해야 한다.",
            "누구나 쉽게 배울 수 있어야 한다.",
            "오류를 최소화해야 한다."
        ],
        "answer": "사용자의 목적을 정확하고 완벽하게 달성해야 한다.",
        "hint": "Effective와 Efficient를 구분해야 합니다. 정보처리기사 이론에서는 유효성을 '목표 달성 여부'로 봅니다.",
        "explanation": "유효성(Effectiveness)은 사용자의 목표가 정확하고 완벽하게 달성되는지를 의미합니다. (참고: 효율성은 자원 소모 정도)"
    },
    {
        "level": 1,
        "problem": "객체지향에서 클래스 간의 관계 중 '일반화(Generalization)' 관계는 무엇을 의미하는가?",
        "options": [
            "상속 관계",
            "연관 관계",
            "의존 관계",
            "포함 관계"
        ],
        "answer": "상속 관계",
        "hint": "부모-자식 관계입니다.",
        "explanation": "일반화는 구체적인 클래스(자식)의 공통점을 묶어 상위 클래스(부모)를 만드는 것으로, 상속(Inheritance) 관계를 나타냅니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 'Memento' 패턴의 용도는?",
        "options": [
            "객체의 내부 상태를 캡슐화화지 않고 외부로 저장하여 나중에 복구한다.",
            "객체 생성을 서브클래스에 위임한다.",
            "알고리즘을 교체한다.",
            "인터페이스를 변환한다."
        ],
        "answer": "객체의 내부 상태를 캡슐화화지 않고 외부로 저장하여 나중에 복구한다.",
        "hint": "Ctrl+Z (실행 취소) 기능을 구현할 때 씁니다.",
        "explanation": "Memento 패턴은 객체의 상태를 저장해 두었다가 나중에 해당 상태로 복원(Undo)할 때 사용합니다."
    },
    {
        "level": 1,
        "problem": "다음 중 형상 관리(Configuration Management)의 주요 기능이 아닌 것은?",
        "options": [
            "버전 제어",
            "변경 관리",
            "비용 산정",
            "베이스라인 관리"
        ],
        "answer": "비용 산정",
        "hint": "형상 관리는 코드나 문서의 변경을 관리하는 것입니다.",
        "explanation": "비용 산정은 프로젝트 관리의 영역이며, 형상 관리는 소프트웨어 변경 사항을 통제하고 추적하는 활동입니다."
    },
    {
        "level": 1,
        "problem": "요구사항 분석 시 '페르소나(Persona)' 기법의 정의는?",
        "options": [
            "실제 사용자를 대표하는 가상의 인물을 설정하여 분석하는 것",
            "설문조사를 통해 통계를 내는 것",
            "개발자가 직접 사용자가 되어보는 것",
            "시스템의 로그를 분석하는 것"
        ],
        "answer": "실제 사용자를 대표하는 가상의 인물을 설정하여 분석하는 것",
        "hint": "가면이라는 뜻의 라틴어에서 유래했습니다.",
        "explanation": "페르소나는 다양한 사용자 유형을 대표하기 위해 만든 가상의 캐릭터로, 사용자 요구사항을 구체화하는 데 도움을 줍니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 아키텍처 패턴 중 '레이어(Layered)' 패턴의 특징은?",
        "options": [
            "시스템을 계층으로 나누어 상위 계층이 하위 계층 서비스를 이용한다.",
            "모든 컴포넌트가 중앙 데이터 저장소를 공유한다.",
            "이벤트 발생 시 구독자에게 알림을 보낸다.",
            "객체의 요청을 캡슐화한다."
        ],
        "answer": "시스템을 계층으로 나누어 상위 계층이 하위 계층 서비스를 이용한다.",
        "hint": "OSI 7계층이나 TCP/IP 스택을 생각하세요.",
        "explanation": "Layered 패턴은 시스템을 계층화하여 구성하며, 인접한 계층 간에만 상호작용이 일어나도록 제한하여 유지보수성을 높입니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 'Flyweight' 패턴의 목적은?",
        "options": [
            "많은 수의 유사한 객체를 공유하여 메모리 사용량을 줄인다.",
            "객체의 인터페이스를 통합한다.",
            "기능을 동적으로 추가한다.",
            "알고리즘을 캡슐화한다."
        ],
        "answer": "많은 수의 유사한 객체를 공유하여 메모리 사용량을 줄인다.",
        "hint": "가벼운(Fly) 급이라는 뜻입니다.",
        "explanation": "Flyweight 패턴은 다수의 객체가 생성될 때 공통 부분을 공유(Sharing)하여 메모리 낭비를 줄이는 구조 패턴입니다."
    },
    {
        "level": 1,
        "problem": "UML의 활동 다이어그램(Activity Diagram)에서 병행 처리를 나타내는 기호는?",
        "options": [
            "Fork/Join Node (굵은 가로선)",
            "Decision Node (마름모)",
            "Initial Node (검은 원)",
            "Final Node (이중 원)"
        ],
        "answer": "Fork/Join Node (굵은 가로선)",
        "hint": "흐름이 나뉘거나 합쳐지는 곳입니다.",
        "explanation": "Fork(분기)와 Join(결합) 노드는 굵은 선(Bar)으로 표현하며, 병행 처리 흐름을 나타냅니다."
    },
    {
        "level": 1,
        "problem": "기능 점수(Function Point) 모형에서 비용 산정 시 고려하는 요소가 아닌 것은?",
        "options": [
            "내부 논리 파일(ILF)",
            "외부 인터페이스 파일(EIF)",
            "외부 입력(EI)",
            "코드 라인 수(LOC)"
        ],
        "answer": "코드 라인 수(LOC)",
        "hint": "FP는 LOC 중심의 산정 방식의 단점을 보완하기 위해 나왔습니다.",
        "explanation": "FP 모형은 사용자 관점의 기능을 정량화한 것으로, LOC(Line of Code)는 고려하지 않습니다. (고려 요소: ILF, EIF, EI, EO, EQ)"
    },
    {
        "level": 1,
        "problem": "다음 중 '교환적 응집도(Communication Cohesion)'에 대한 설명은?",
        "options": [
            "동일한 입력 데이터를 사용하여 서로 다른 기능을 수행하는 요소들이 모여 있다.",
            "특정 시간대에 처리되는 기능들이 모여 있다.",
            "출력이 다음 입력으로 사용된다.",
            "아무런 관련이 없다."
        ],
        "answer": "동일한 입력 데이터를 사용하여 서로 다른 기능을 수행하는 요소들이 모여 있다.",
        "hint": "자료를 공유하는 것이 핵심입니다.",
        "explanation": "교환적 응집도는 모듈 내의 요소들이 동일한 입출력 자료를 사용하여 서로 다른 기능을 수행할 때의 응집도입니다."
    },
    {
        "level": 1,
        "problem": "GoF 디자인 패턴 중 'Visitor' 패턴의 특징은?",
        "options": [
            "데이터 구조와 처리를 분리하여, 구조를 변경하지 않고 새로운 연산을 추가할 수 있다.",
            "객체 생성 코드를 캡슐화한다.",
            "복잡한 서브시스템을 감춘다.",
            "한 객체의 변경 사항을 다른 객체에 알린다."
        ],
        "answer": "데이터 구조와 처리를 분리하여, 구조를 변경하지 않고 새로운 연산을 추가할 수 있다.",
        "hint": "방문자가 돌아다니며 작업을 처리합니다.",
        "explanation": "Visitor 패턴은 데이터 구조 안을 돌아다니는 '방문자' 객체를 정의하여, 데이터 구조의 변경 없이 새로운 연산을 추가할 수 있게 합니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 개발 방법론 중 '테일러링(Tailoring)'의 의미는?",
        "options": [
            "프로젝트 특성에 맞게 방법론 절차나 산출물을 조정하는 것",
            "코드를 최적화하는 것",
            "하드웨어를 업그레이드하는 것",
            "테스트 케이스를 작성하는 것"
        ],
        "answer": "프로젝트 특성에 맞게 방법론 절차나 산출물을 조정하는 것",
        "hint": "양복을 재단하듯이 맞춤형으로 만드는 것입니다.",
        "explanation": "테일러링은 표준 방법론을 프로젝트의 성격, 규모, 비용 등에 맞춰 수정 및 보완하여 최적화하는 활동입니다."
    },
    {
        "level": 1,
        "problem": "UML에서 '컴포넌트(Component)'를 표현하는 아이콘 모양은?",
        "options": [
            "직사각형 왼쪽에 작은 직사각형 2개가 튀어나온 모양 (또는 우측 상단에 컴포넌트 아이콘)",
            "직육면체 모양",
            "타원형",
            "마름모"
        ],
        "answer": "직사각형 왼쪽에 작은 직사각형 2개가 튀어나온 모양 (또는 우측 상단에 컴포넌트 아이콘)",
        "hint": "탭이 달린 모양입니다.",
        "explanation": "과거에는 탭이 2개 달린 직사각형을 썼으나, UML 2.0 이후에는 직사각형 우측 상단에 작은 컴포넌트 아이콘이 들어간 형태를 주로 씁니다."
    },
    {
        "level": 1,
        "problem": "다음 중 자료 흐름도(DFD)에서 'Data Store(자료 저장소)'를 나타내는 기호는?",
        "options": [
            "평행선",
            "원",
            "사각형",
            "화살표"
        ],
        "answer": "평행선",
        "hint": "두 줄로 표시합니다.",
        "explanation": "자료 저장소는 평행선(두 줄)으로 표현합니다. (원은 프로세스, 사각형은 단말, 화살표는 흐름)"
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 'Command' 패턴의 구성 요소가 아닌 것은?",
        "options": [
            "Command",
            "Receiver",
            "Invoker",
            "Observer"
        ],
        "answer": "Observer",
        "hint": "Observer는 별도의 패턴입니다.",
        "explanation": "Command 패턴은 Command, Receiver, Invoker, Client로 구성됩니다. Observer는 다른 패턴입니다."
    },
    {
        "level": 1,
        "problem": "소프트웨어 공학의 3R(Re-engineering)에 해당하지 않는 것은?",
        "options": [
            "역공학 (Reverse Engineering)",
            "재공학 (Re-engineering)",
            "재사용 (Reuse)",
            "리팩토링 (Refactoring)"
        ],
        "answer": "리팩토링 (Refactoring)",
        "hint": "3R은 역공학, 재공학, 재사용입니다.",
        "explanation": "소프트웨어 공학의 3R은 역공학(Reverse Engineering), 재공학(Re-engineering), 재사용(Reuse)을 말합니다."
    },
    {
        "level": 1,
        "problem": "인터페이스 설계 시 시스템 간 데이터 교환 포맷으로 주로 사용되는, '키-값(Key-Value)' 쌍으로 이루어진 텍스트 기반 포맷은?",
        "options": [
            "JSON",
            "XML",
            "HTML",
            "CSV"
        ],
        "answer": "JSON",
        "hint": "자바스크립트 객체 표기법입니다.",
        "explanation": "JSON(JavaScript Object Notation)은 속성-값 쌍으로 이루어진 개방형 표준 포맷입니다."
    },
    {
        "level": 1,
        "problem": "애자일 방법론 '스크럼(Scrum)'에서 프로젝트의 요구사항을 우선순위에 따라 나열한 목록은?",
        "options": [
            "제품 백로그 (Product Backlog)",
            "스프린트 백로그 (Sprint Backlog)",
            "소멸 차트 (Burn-down Chart)",
            "일일 기록"
        ],
        "answer": "제품 백로그 (Product Backlog)",
        "hint": "전체 업무 목록입니다.",
        "explanation": "제품 백로그는 개발할 제품에 대한 요구사항을 우선순위대로 정렬해 놓은 목록이며, 여기서 스프린트 백로그를 추출합니다."
    },
    {
        "level": 1,
        "problem": "디자인 패턴 중 'Abstract Factory' 패턴의 특징은?",
        "options": [
            "관련된 객체들의 군(Family)을 생성하기 위한 인터페이스를 제공한다.",
            "복잡한 객체 생성 과정을 단계별로 정의한다.",
            "단 하나의 객체만 생성한다.",
            "기존 클래스를 재사용할 수 있게 인터페이스를 맞춘다."
        ],
        "answer": "관련된 객체들의 군(Family)을 생성하기 위한 인터페이스를 제공한다.",
        "hint": "구체적인 클래스를 지정하지 않고 관련 객체들을 한꺼번에 만듭니다.",
        "explanation": "Abstract Factory는 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합(Kit)을 생성하는 인터페이스를 제공합니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 테스트 기법 중 '화이트박스 테스트'의 검증 기준에 해당하지 않는 것은?",
        "options": [
            "기초 경로 검사",
            "조건 검사",
            "루프 검사",
            "경계값 분석"
        ],
        "answer": "경계값 분석",
        "hint": "경계값 분석은 블랙박스 테스트 기법입니다.",
        "explanation": "경계값 분석(Boundary Value Analysis)은 블랙박스 테스트 기법에 속합니다. 화이트박스 테스트는 내부 소스 코드의 로직을 테스트하는 것으로, 기초 경로, 제어 구조(조건, 루프, 데이터 흐름) 검사 등이 있습니다."
    },
    {
        "level": 2,
        "problem": "자료구조 중 'LIFO(Last In First Out)' 방식을 사용하며, 서브루틴 호출, 인터럽트 처리, 후위 표기법 연산 등에 활용되는 것은?",
        "options": [
            "Queue",
            "Stack",
            "Deque",
            "Tree"
        ],
        "answer": "Stack",
        "hint": "가장 나중에 들어온 데이터가 가장 먼저 나갑니다.",
        "explanation": "스택(Stack)은 후입선출(LIFO) 구조로, 함수 호출의 복귀 주소 저장이나 인터럽트 처리 등에 사용됩니다."
    },
    {
        "level": 2,
        "problem": "알고리즘의 시간 복잡도를 나타내는 빅오(Big-O) 표기법 중, 가장 효율적인(빠른) 실행 시간을 갖는 것은?",
        "options": [
            "O(1)",
            "O(n)",
            "O(log n)",
            "O(n log n)"
        ],
        "answer": "O(1)",
        "hint": "상수 시간 복잡도입니다.",
        "explanation": "실행 시간 효율성 순서는 O(1) < O(log n) < O(n) < O(n log n) < O(n^2) ... 입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 형상 관리(SCM) 도구 중 '분산 버전 관리 시스템(DVCS)'에 해당하는 것은?",
        "options": [
            "CVS",
            "Subversion(SVN)",
            "Git",
            "ClearCase"
        ],
        "answer": "Git",
        "hint": "로컬 저장소에 전체 이력을 복사해 작업합니다.",
        "explanation": "Git은 분산 버전 관리 시스템으로, 로컬 저장소와 원격 저장소가 분리되어 있어 오프라인 작업이 가능하고 브랜치 관리가 용이합니다. CVS와 SVN은 중앙 집중형입니다."
    },
    {
        "level": 2,
        "problem": "디지털 저작권 관리(DRM)의 구성 요소가 아닌 것은?",
        "options": [
            "콘텐츠 제공자(Content Provider)",
            "클리어링 하우스(Clearing House)",
            "패키저(Packager)",
            "방화벽(Firewall)"
        ],
        "answer": "방화벽(Firewall)",
        "hint": "방화벽은 네트워크 보안 장비입니다.",
        "explanation": "DRM의 주요 구성 요소는 콘텐츠 제공자, 분배자, 패키저, 보안 컨테이너, 클리어링 하우스, DRM 컨트롤러 등입니다. 방화벽은 일반적인 네트워크 보안 요소입니다."
    },
    {
        "level": 2,
        "problem": "다음 트리를 전위 순회(Preorder Traversal) 했을 때의 결과는? (Root: A, Left: B, Right: C)",
        "options": [
            "A - B - C",
            "B - A - C",
            "B - C - A",
            "C - B - A"
        ],
        "answer": "A - B - C",
        "hint": "전위 순회 순서는 Root -> Left -> Right 입니다.",
        "explanation": "전위 순회는 루트(A)를 먼저 방문하고, 왼쪽 자식(B), 오른쪽 자식(C) 순서로 방문합니다."
    },
    {
        "level": 2,
        "problem": "애플리케이션 통합(EAI) 구축 유형 중, 애플리케이션 사이에 미들웨어(Bus)를 두어 연동하는 방식은?",
        "options": [
            "Point-to-Point",
            "Hub & Spoke",
            "Message Bus",
            "Hybrid"
        ],
        "answer": "Message Bus",
        "hint": "미들웨어를 통해 대용량 처리가 가능하고 확장성이 좋습니다.",
        "explanation": "메시지 버스(Message Bus) 방식은 미들웨어(Bus)를 통해 애플리케이션들이 메시지를 주고받는 방식으로, 확장성이 뛰어나고 대용량 처리에 유리합니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 테스트 단계 중 '단위 테스트(Unit Test)'가 끝난 모듈들을 결합하여 인터페이스 상의 오류를 발견하는 테스트는?",
        "options": [
            "시스템 테스트",
            "인수 테스트",
            "통합 테스트",
            "회귀 테스트"
        ],
        "answer": "통합 테스트",
        "hint": "모듈 간의 상호작용을 검증합니다.",
        "explanation": "통합 테스트(Integration Test)는 단위 테스트가 완료된 모듈들을 결합하는 과정에서 발생하는 인터페이스 오류나 연동 문제를 검증합니다."
    },
    {
        "level": 2,
        "problem": "정렬 알고리즘 중 '최악의 경우(Worst Case)' 시간 복잡도가 O(n^2)인 것은?",
        "options": [
            "Heap Sort",
            "Merge Sort",
            "Quick Sort",
            "Radix Sort"
        ],
        "answer": "Quick Sort",
        "hint": "평균은 빠르지만, 이미 정렬된 데이터 등에서 성능이 저하될 수 있습니다.",
        "explanation": "Quick Sort는 평균적으로 O(n log n)이지만, 피벗(Pivot) 선택이 불균형할 때 최악의 경우 O(n^2)의 복잡도를 가집니다. (Heap, Merge는 항상 O(n log n) 보장)"
    },
    {
        "level": 2,
        "problem": "인터페이스 구현 기술 중, 자바스크립트를 사용하여 비동기적으로 서버와 데이터를 교환하는 기술은?",
        "options": [
            "AJAX",
            "SOAP",
            "REST",
            "UDDI"
        ],
        "answer": "AJAX",
        "hint": "Asynchronous JavaScript and XML의 약자입니다.",
        "explanation": "AJAX는 JavaScript를 사용해 서버와 비동기적으로 통신하여 웹 페이지 전체를 다시 로드하지 않고 일부만 갱신할 수 있게 하는 기술입니다."
    },
    {
        "level": 2,
        "problem": "해싱 함수(Hashing Function)의 요구조건으로 틀린 것은?",
        "options": [
            "충돌(Collision) 발생을 최소화해야 한다.",
            "계산이 복잡하여 보안성이 높아야 한다.",
            "주소 테이블에 고르게 분포되어야 한다.",
            "계산 속도가 빨라야 한다."
        ],
        "answer": "계산이 복잡하여 보안성이 높아야 한다.",
        "hint": "해시 테이블의 목적은 빠른 검색입니다.",
        "explanation": "해싱 함수는 데이터의 위치를 빠르게 찾기 위한 것이므로 계산이 단순하고 빨라야 합니다. 암호화 해시와는 목적이 다릅니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 품질 특성(ISO/IEC 9126) 중 '사용자가 주어진 조건에서 소프트웨어를 얼마나 쉽게 이해하고 배울 수 있는가'를 나타내는 것은?",
        "options": [
            "신뢰성",
            "사용성",
            "유지보수성",
            "효율성"
        ],
        "answer": "사용성",
        "hint": "Usability라고 합니다.",
        "explanation": "사용성(Usability)은 이해성, 학습성, 운용성 등 사용자가 소프트웨어를 편리하게 사용할 수 있는 능력을 의미합니다."
    },
    {
        "level": 2,
        "problem": "상향식 통합 테스트(Bottom-Up Integration)에서 하위 모듈의 반환 값을 전달하기 위해 사용하는 임시 모듈은?",
        "options": [
            "Stub",
            "Driver",
            "Proxy",
            "Bridge"
        ],
        "answer": "Driver",
        "hint": "상향식은 드라이버(Driver), 하향식은 스텁(Stub)입니다.",
        "explanation": "상향식 통합에서는 상위 모듈이 아직 없으므로, 하위 모듈을 제어하고 데이터를 넘겨줄 '테스트 드라이버(Driver)'가 필요합니다."
    },
    {
        "level": 2,
        "problem": "다음 중 비선형(Non-Linear) 자료구조에 해당하는 것은?",
        "options": [
            "Stack",
            "Queue",
            "Linked List",
            "Graph"
        ],
        "answer": "Graph",
        "hint": "데이터가 일렬로 나열되지 않습니다.",
        "explanation": "스택, 큐, 연결 리스트는 선형 구조이며, 트리와 그래프는 비선형 구조입니다."
    },
    {
        "level": 2,
        "problem": "인터페이스 보안 기술 중 네트워크 계층(IP Layer)에서 IP 패킷 단위로 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜은?",
        "options": [
            "SSL/TLS",
            "IPSec",
            "S-HTTP",
            "SSH"
        ],
        "answer": "IPSec",
        "hint": "IP Security의 약자입니다.",
        "explanation": "IPSec은 네트워크 계층에서 IP 패킷을 암호화하고 인증 헤더(AH)와 암호화(ESP)를 통해 보안을 제공합니다."
    },
    {
        "level": 2,
        "problem": "블랙박스 테스트 기법 중 입력 조건의 타당한 값과 타당하지 않은 값을 설정하여 테스트하는 기법은?",
        "options": [
            "동치 분할 검사 (Equivalence Partitioning)",
            "경계값 분석",
            "원인-효과 그래프",
            "오류 예측 검사"
        ],
        "answer": "동치 분할 검사 (Equivalence Partitioning)",
        "hint": "입력 영역을 그룹으로 나눕니다.",
        "explanation": "동치 분할 검사는 입력 자료의 범위를 타당한 데이터와 그렇지 않은 데이터의 구간으로 나누어 각 구간에서 대표값을 선택해 테스트하는 방법입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 패키징 시 고려사항으로 적절하지 않은 것은?",
        "options": [
            "사용자 편의성을 위해 복잡한 설치 과정을 제공한다.",
            "다양한 운영체제 환경을 고려한다.",
            "저작권 보호 기술을 적용한다.",
            "사용자 매뉴얼을 함께 배포한다."
        ],
        "answer": "사용자 편의성을 위해 복잡한 설치 과정을 제공한다.",
        "hint": "설치 과정은 단순할수록 좋습니다.",
        "explanation": "패키징은 사용자가 소프트웨어를 쉽게 설치하고 사용할 수 있도록 편의성을 고려해야 하며, 설치 과정은 최대한 단순화해야 합니다."
    },
    {
        "level": 2,
        "problem": "빌드 자동화 도구 중 Groovy를 기반으로 한 스크립트 언어로 구성되어 있으며, 안드로이드 앱 개발 환경에서 주로 사용되는 것은?",
        "options": [
            "Ant",
            "Maven",
            "Gradle",
            "Make"
        ],
        "answer": "Gradle",
        "hint": "유연성과 성능이 뛰어난 최신 빌드 도구입니다.",
        "explanation": "Gradle은 Groovy를 기반으로 하며, Ant와 Maven의 장점을 보완하여 유연한 빌드 구성을 지원합니다."
    },
    {
        "level": 2,
        "problem": "데이터베이스의 이상(Anomaly) 현상이 아닌 것은?",
        "options": [
            "삽입 이상",
            "삭제 이상",
            "갱신 이상",
            "조회 이상"
        ],
        "answer": "조회 이상",
        "hint": "데이터를 읽을 때 문제가 생기는 것은 이상 현상이 아닙니다.",
        "explanation": "이상 현상은 정규화되지 않은 테이블에서 데이터 변경(삽입, 삭제, 갱신) 시 발생하는 논리적 오류를 말합니다. 조회 이상은 해당하지 않습니다."
    },
    {
        "level": 2,
        "problem": "다음 중 '삽입 정렬(Insertion Sort)'의 특징으로 옳은 것은?",
        "options": [
            "레코드의 키 값을 비교하여 교환하는 방식이다.",
            "이미 순서화된 파일인 경우 효율이 가장 좋다.",
            "인접한 두 개의 레코드를 비교한다.",
            "별도의 추가 공간이 많이 필요하다."
        ],
        "answer": "이미 순서화된 파일인 경우 효율이 가장 좋다.",
        "hint": "정렬된 상태에서는 비교만 하고 이동이 거의 없습니다.",
        "explanation": "삽입 정렬은 이미 정렬되어 있는 경우 O(n)의 시간 복잡도를 가지므로 매우 효율적입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 테스트의 원칙으로 옳지 않은 것은?",
        "options": [
            "테스트는 결함이 존재함을 보여주는 것이다.",
            "완벽한 테스트는 가능하다.",
            "테스트는 개발 초기에 시작해야 한다.",
            "살충제 패러독스(Pesticide Paradox)를 고려해야 한다."
        ],
        "answer": "완벽한 테스트는 가능하다.",
        "hint": "모든 입력 조건을 테스트하는 것은 불가능합니다.",
        "explanation": "무한한 입력값과 경로가 존재하므로, 소프트웨어에서 결함이 없음을 증명하는 '완벽한 테스트'는 불가능합니다."
    },
    {
        "level": 2,
        "problem": "JSON(JavaScript Object Notation)에 대한 설명으로 틀린 것은?",
        "options": [
            "키-값(Key-Value) 쌍으로 구성된다.",
            "XML보다 가볍고 가독성이 좋다.",
            "자바스크립트의 객체 표기법을 따른다.",
            "반드시 종료 태그가 필요하다."
        ],
        "answer": "반드시 종료 태그가 필요하다.",
        "hint": "종료 태그는 XML의 특징입니다.",
        "explanation": "JSON은 태그를 사용하지 않고 중괄호 {}와 대괄호 [] 등을 사용하여 데이터를 표현하므로 종료 태그가 없습니다."
    },
    {
        "level": 2,
        "problem": "소스 코드 품질 분석 도구 중 '정적 분석 도구'에 해당하지 않는 것은?",
        "options": [
            "pmd",
            "cppcheck",
            "SonarQube",
            "Valgrind"
        ],
        "answer": "Valgrind",
        "hint": "메모리 누수 등을 실행 중에 검사합니다.",
        "explanation": "Valgrind는 프로그램을 실행하면서 메모리 누수나 스레드 오류 등을 검사하는 동적 분석 도구입니다. 나머지는 소스 코드만 보고 분석하는 정적 도구입니다."
    },
    {
        "level": 2,
        "problem": "형상 관리(SCM)의 기능 중 '변경 요청을 검토하고 승인하여 베이스라인에 반영할지 결정하는 활동'은?",
        "options": [
            "형상 식별",
            "형상 통제",
            "형상 감사",
            "형상 기록"
        ],
        "answer": "형상 통제",
        "hint": "변경 제어 위원회(CCB)가 수행합니다.",
        "explanation": "형상 통제(Configuration Control)는 변경 요청을 관리하고 승인/반려를 결정하여 베이스라인의 무결성을 유지하는 활동입니다."
    },
    {
        "level": 2,
        "problem": "이진 트리(Binary Tree)에서 노드의 개수가 n개일 때, 간선(Edge)의 개수는?",
        "options": [
            "n",
            "n - 1",
            "n + 1",
            "2n"
        ],
        "answer": "n - 1",
        "hint": "루트 노드를 제외한 모든 노드는 하나의 부모와 연결됩니다.",
        "explanation": "트리 구조에서 n개의 노드가 연결되기 위해서는 항상 n-1개의 간선이 필요합니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 재공학(Re-engineering)의 주요 활동이 아닌 것은?",
        "options": [
            "분석(Analysis)",
            "재구성(Restructuring)",
            "역공학(Reverse Engineering)",
            "프로토타이핑(Prototyping)"
        ],
        "answer": "프로토타이핑(Prototyping)",
        "hint": "프로토타이핑은 신규 개발 시 요구사항 분석을 위해 주로 사용합니다.",
        "explanation": "재공학은 기존 시스템을 개선하는 것으로 분석, 재구성, 역공학, 이식 등이 포함됩니다. 프로토타이핑은 주로 신규 개발 방법론입니다."
    },
    {
        "level": 2,
        "problem": "다음 중 '인터페이스 명세서'에 포함되어야 할 항목으로 거리가 먼 것은?",
        "options": [
            "인터페이스 ID",
            "처리 로직의 상세 알고리즘",
            "데이터 포맷",
            "송수신 데이터 타입"
        ],
        "answer": "처리 로직의 상세 알고리즘",
        "hint": "인터페이스는 '연결'에 초점을 맞춥니다.",
        "explanation": "인터페이스 명세서는 주고받는 데이터의 형식, 통신 방법 등을 정의하며, 내부 구현 로직(알고리즘)까지 상세히 기술하지는 않습니다."
    },
    {
        "level": 2,
        "problem": "테스트 오라클(Test Oracle)의 유형 중, 모든 입력값에 대해 기대하는 결과를 생성하여 전수 검사가 가능한 오라클은?",
        "options": [
            "참(True) 오라클",
            "샘플링(Sampling) 오라클",
            "휴리스틱(Heuristic) 오라클",
            "일관성(Consistent) 오라클"
        ],
        "answer": "참(True) 오라클",
        "hint": "모든 경우의 수를 다 확인합니다.",
        "explanation": "참 오라클은 모든 입력값에 대해 기대 결과를 생성할 수 있어 발생한 오류를 모두 검출할 수 있는 오라클입니다."
    },
    {
        "level": 2,
        "problem": "버블 정렬(Bubble Sort)에서 1회전 수행 후 정렬되는 값의 위치는?",
        "options": [
            "가장 작은 값이 맨 뒤로 이동",
            "가장 큰 값이 맨 뒤로 이동",
            "가장 작은 값이 맨 앞으로 이동",
            "중간 값이 결정됨"
        ],
        "answer": "가장 큰 값이 맨 뒤로 이동",
        "hint": "거품이 위로 올라가는 모습을 상상해보세요(오름차순 기준).",
        "explanation": "오름차순 버블 정렬은 인접한 두 수를 비교하여 큰 수를 뒤로 보내므로, 1회전이 끝나면 가장 큰 수가 맨 뒤에 위치하게 됩니다."
    },
    {
        "level": 2,
        "problem": "SOAP(Simple Object Access Protocol) 프로토콜의 기반 언어는?",
        "options": [
            "HTML",
            "XML",
            "JSON",
            "YAML"
        ],
        "answer": "XML",
        "hint": "태그를 사용하는 확장 마크업 언어입니다.",
        "explanation": "SOAP는 XML을 기반으로 하여 네트워크 상에서 정보를 교환하는 프로토콜입니다."
    },
    {
        "level": 2,
        "problem": "형상 관리에서 '베이스라인(Baseline)'에 대한 설명으로 옳은 것은?",
        "options": [
            "개발 과정의 각 단계별 산출물을 검토하고 승인된 기준 시점이다.",
            "최초의 아이디어 단계를 의미한다.",
            "최종 완제품만을 의미한다.",
            "개발자의 로컬 작업 공간이다."
        ],
        "answer": "개발 과정의 각 단계별 산출물을 검토하고 승인된 기준 시점이다.",
        "hint": "변경 통제의 기준이 됩니다.",
        "explanation": "베이스라인은 소프트웨어 개발 과정에서 특정 시점에 검토와 승인을 거쳐 확정된 형상 항목의 집합으로, 변경 통제의 기준이 됩니다."
    },
    {
        "level": 2,
        "problem": "블랙박스 테스트 기법 중, 입력 조건들의 조합을 고려하여 테스트 케이스를 최소화하면서도 커버리지를 높이는 기법은?",
        "options": [
            "페어와이즈(Pairwise) 테스트",
            "경계값 분석",
            "상태 전이 검사",
            "비교 검사"
        ],
        "answer": "페어와이즈(Pairwise) 테스트",
        "hint": "모든 조합(All-pairs)이 아닌 쌍(Pair) 조합을 테스트합니다.",
        "explanation": "페어와이즈 테스트는 입력 파라미터 간의 모든 쌍(Pair)에 대해 최소 한 번씩 테스트하여, 상대적으로 적은 테스트 케이스로 높은 결함 발견율을 보장합니다."
    },
    {
        "level": 2,
        "problem": "국제 표준화 기구(ISO)에서 제정한 소프트웨어 품질 평가 표준 모델로, ISO 9126을 대체 및 보완한 모델은?",
        "options": [
            "ISO/IEC 12207",
            "ISO/IEC 15504 (SPICE)",
            "ISO/IEC 25010",
            "CMMI"
        ],
        "answer": "ISO/IEC 25010",
        "hint": "SQuaRE라고도 불립니다.",
        "explanation": "ISO/IEC 25010은 ISO 9126을 개정하여 호환성, 보안성 등의 특성을 강화한 시스템 및 소프트웨어 품질 모델입니다."
    },
    {
        "level": 2,
        "problem": "알고리즘 설계 기법 중 '문제를 작은 부분 문제로 나누어 해결한 후, 그 결과를 저장(Memoization)하여 중복 계산을 피하는' 방법은?",
        "options": [
            "분할 정복(Divide and Conquer)",
            "동적 계획법(Dynamic Programming)",
            "탐욕법(Greedy)",
            "백트래킹(Backtracking)"
        ],
        "answer": "동적 계획법(Dynamic Programming)",
        "hint": "기억하기(Memoization)가 핵심입니다.",
        "explanation": "동적 계획법은 하위 문제의 해를 저장해 두었다가 재사용함으로써 계산 횟수를 줄이는 최적화 기법입니다."
    },
    {
        "level": 2,
        "problem": "다음 중 버전 관리 도구(VCS)의 주요 기능이 아닌 것은?",
        "options": [
            "백업 및 복구",
            "변경 이력 추적",
            "협업 지원",
            "바이러스 검사"
        ],
        "answer": "바이러스 검사",
        "hint": "보안 백신 프로그램의 역할입니다.",
        "explanation": "버전 관리 도구는 소스 코드의 변경 사항을 관리하는 도구이며, 바이러스 검사는 포함되지 않습니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 패키징 도구 활용 시 '디지털 서명'을 사용하는 주된 이유는?",
        "options": [
            "패키지 용량을 줄이기 위해",
            "설치 속도를 높이기 위해",
            "소프트웨어의 무결성과 배포처를 인증하기 위해",
            "실행 속도를 최적화하기 위해"
        ],
        "answer": "소프트웨어의 무결성과 배포처를 인증하기 위해",
        "hint": "위변조 여부를 확인합니다.",
        "explanation": "디지털 서명은 소프트웨어가 변조되지 않았음(무결성)과 신뢰할 수 있는 배포자(인증)임을 보증하기 위해 사용합니다."
    },
    {
        "level": 2,
        "problem": "테스트 케이스(Test Case) 작성 시 포함되어야 할 항목이 아닌 것은?",
        "options": [
            "테스트 조건",
            "입력 데이터",
            "기대 결과",
            "개발 비용"
        ],
        "answer": "개발 비용",
        "hint": "테스트 케이스는 '검증 방법'을 기술한 문서입니다.",
        "explanation": "테스트 케이스는 테스트 ID, 조건, 입력값, 기대 결과, 절차 등을 포함하며, 비용은 프로젝트 관리 영역입니다."
    },
    {
        "level": 2,
        "problem": "연결 리스트(Linked List)에 대한 설명으로 옳은 것은?",
        "options": [
            "메모리가 연속적이어야 한다.",
            "데이터 삽입/삭제가 배열보다 용이하다.",
            "인덱스를 통해 임의 접근(Random Access)이 가능하다.",
            "크기가 고정되어 있다."
        ],
        "answer": "데이터 삽입/삭제가 배열보다 용이하다.",
        "hint": "링크(포인터)만 변경하면 됩니다.",
        "explanation": "연결 리스트는 논리적인 순서대로 데이터가 연결되어 있어, 포인터 변경만으로 삽입/삭제가 가능해 효율적입니다. 반면 임의 접근은 불가능합니다."
    },
    {
        "level": 2,
        "problem": "애플리케이션 성능 측정 지표 중 '시스템이 단위 시간당 처리할 수 있는 작업의 양'을 의미하는 것은?",
        "options": [
            "응답 시간(Response Time)",
            "처리량(Throughput)",
            "경과 시간(Turnaround Time)",
            "자원 사용률(Resource Usage)"
        ],
        "answer": "처리량(Throughput)",
        "hint": "TPS(Transaction Per Second)와 관련 있습니다.",
        "explanation": "처리량(Throughput)은 단위 시간 내에 처리하는 업무량 또는 전송량을 의미합니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 모듈화의 장점으로 볼 수 없는 것은?",
        "options": [
            "프로그램의 효율적인 관리가 가능하다.",
            "오류 파급 효과를 최소화할 수 있다.",
            "모듈 간의 결합도를 높여 성능을 향상시킨다.",
            "소프트웨어의 재사용성을 높인다."
        ],
        "answer": "모듈 간의 결합도를 높여 성능을 향상시킨다.",
        "hint": "결합도는 낮아야 좋습니다.",
        "explanation": "모듈화는 결합도를 낮추고(Loose Coupling), 응집도를 높여야(High Cohesion) 유지보수와 재사용에 유리합니다."
    },
    {
        "level": 2,
        "problem": "해시(Hash) 암호화 알고리즘 중 128비트 다이제스트를 생성하며, 현재는 보안 취약점으로 인해 사용이 권장되지 않는 것은?",
        "options": [
            "SHA-256",
            "AES",
            "MD5",
            "RSA"
        ],
        "answer": "MD5",
        "hint": "Message Digest 알고리즘 5번째 버전입니다.",
        "explanation": "MD5는 128비트 해시 값을 생성하지만 충돌 가능성이 발견되어 보안 용도로는 사용이 권장되지 않습니다. (SHA-256 등을 권장)"
    },
    {
        "level": 2,
        "problem": "다음 중 시스템의 상태 변화를 나타내는 UML 다이어그램은?",
        "options": [
            "클래스 다이어그램",
            "시퀀스 다이어그램",
            "상태 다이어그램 (State Diagram)",
            "유스케이스 다이어그램"
        ],
        "answer": "상태 다이어그램 (State Diagram)",
        "hint": "이름에 답이 있습니다.",
        "explanation": "상태 다이어그램은 객체가 라이프사이클 동안 겪는 상태 변화와 전이를 표현합니다."
    },
    {
        "level": 2,
        "problem": "Git 명령어 중 원격 저장소의 내용을 로컬 저장소로 가져와서 병합(Merge)까지 수행하는 명령어는?",
        "options": [
            "git fetch",
            "git pull",
            "git clone",
            "git push"
        ],
        "answer": "git pull",
        "hint": "Fetch + Merge와 같습니다.",
        "explanation": "git pull은 원격 저장소의 변경 내용을 가져와서(fetch) 현재 브랜치에 병합(merge)하는 작업을 수행합니다."
    },
    {
        "level": 2,
        "problem": "테스트 레벨 중 '알파 테스트'와 '베타 테스트'가 수행되는 단계는?",
        "options": [
            "단위 테스트",
            "통합 테스트",
            "시스템 테스트",
            "인수 테스트"
        ],
        "answer": "인수 테스트",
        "hint": "사용자가 직접 확인하는 단계입니다.",
        "explanation": "인수 테스트(Acceptance Test)는 실제 환경에서 사용자의 요구사항을 만족하는지 확인하는 단계로, 알파/베타 테스트가 여기에 속합니다."
    },
    {
        "level": 2,
        "problem": "자료구조 'Deque(Double Ended Queue)'에 대한 설명으로 옳은 것은?",
        "options": [
            "한쪽 끝에서만 삽입과 삭제가 일어난다.",
            "양쪽 끝에서 삽입과 삭제가 모두 가능하다.",
            "중간에서의 삽입 삭제가 가능하다.",
            "FIFO 방식만 지원한다."
        ],
        "answer": "양쪽 끝에서 삽입과 삭제가 모두 가능하다.",
        "hint": "Stack과 Queue의 혼합형입니다.",
        "explanation": "Deque는 양쪽 끝(Front, Rear)에서 삽입과 삭제가 모두 가능한 자료구조입니다."
    },
    {
        "level": 2,
        "problem": "인터페이스 전송 데이터 보안을 위해 사용되는 기술이 아닌 것은?",
        "options": [
            "IPSec",
            "SSL",
            "S-HTTP",
            "SMTP"
        ],
        "answer": "SMTP",
        "hint": "이메일 전송 프로토콜입니다.",
        "explanation": "SMTP는 간이 우편 전송 프로토콜로, 보안 기술 자체가 아닌 이메일 전송을 위한 통신 규약입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 결함 관리 프로세스에서 개발자가 수정한 결함을 테스터가 다시 확인하는 상태는?",
        "options": [
            "Open",
            "Fixed",
            "Closed",
            "Deferred"
        ],
        "answer": "Fixed",
        "hint": "수정 완료된 상태입니다.",
        "explanation": "Fixed는 개발자가 결함을 수정한 후 확인을 요청한 상태이며, 테스터가 이를 확인하여 검증이 완료되면 Closed 상태가 됩니다."
    },
    {
        "level": 2,
        "problem": "다음 중 '스택(Stack)'을 활용하는 예시가 아닌 것은?",
        "options": [
            "재귀 함수 호출",
            "웹 브라우저의 '뒤로 가기'",
            "후위 표기법 연산",
            "운영체제의 작업 스케줄링"
        ],
        "answer": "운영체제의 작업 스케줄링",
        "hint": "순서대로 처리해야 공평합니다.",
        "explanation": "운영체제의 작업 스케줄링은 대기 행렬을 사용하므로 주로 큐(Queue)를 활용합니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 유지보수 유형 중, 환경 변화(OS 업그레이드 등)에 적응하기 위해 수행하는 유지보수는?",
        "options": [
            "수정(Corrective) 유지보수",
            "적응(Adaptive) 유지보수",
            "완전(Perfective) 유지보수",
            "예방(Preventive) 유지보수"
        ],
        "answer": "적응(Adaptive) 유지보수",
        "hint": "환경에 맞추는 것입니다.",
        "explanation": "적응 유지보수는 운영체제나 하드웨어 등 환경 변화에 소프트웨어를 맞추기 위해 수행하는 활동입니다."
    },
    {
        "level": 2,
        "problem": "화이트박스 테스트 기법 중, 프로그램의 제어 흐름을 그래프로 표현하여 모든 경로를 탐색하는 복잡도를 계산하는 지표는?",
        "options": [
            "순환 복잡도 (Cyclomatic Complexity)",
            "기능 점수 (Function Point)",
            "라인 수 (LOC)",
            "Halstead의 복잡도"
        ],
        "answer": "순환 복잡도 (Cyclomatic Complexity)",
        "hint": "McCabe가 제안했습니다.",
        "explanation": "순환 복잡도는 프로그램의 논리적 복잡도를 측정하기 위한 지표로, 제어 흐름 그래프의 영역 수나 (간선 수 - 노드 수 + 2)로 계산합니다."
    },
    {
        "level": 2,
        "problem": "이진 검색(Binary Search) 알고리즘을 수행하기 위한 선행 조건으로 옳은 것은?",
        "options": [
            "데이터가 정렬되어 있어야 한다.",
            "데이터의 개수가 짝수여야 한다.",
            "데이터가 연결 리스트로 구성되어야 한다.",
            "데이터가 중복되지 않아야 한다."
        ],
        "answer": "데이터가 정렬되어 있어야 한다.",
        "hint": "중앙값과 비교하여 범위를 반으로 줄여나가는 방식입니다.",
        "explanation": "이진 검색은 탐색 범위를 절반씩 줄여나가며 값을 찾기 때문에, 데이터가 반드시 순서대로 정렬(Sort)되어 있어야 합니다."
    },
    {
        "level": 2,
        "problem": "다음 중 선형 구조(Linear Structure)에 해당하지 않는 자료구조는?",
        "options": [
            "스택(Stack)",
            "큐(Queue)",
            "데크(Deque)",
            "트리(Tree)"
        ],
        "answer": "트리(Tree)",
        "hint": "계층적인 구조를 가집니다.",
        "explanation": "트리와 그래프는 비선형(Non-Linear) 구조이며, 스택, 큐, 데크, 연결 리스트는 선형 구조입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 테스트에서 '살충제 패러독스(Pesticide Paradox)'의 의미는?",
        "options": [
            "소프트웨어의 결함은 특정 모듈에 집중된다.",
            "동일한 테스트 케이스를 반복하면 더 이상 새로운 결함을 찾을 수 없다.",
            "테스트는 개발 초기부터 진행해야 한다.",
            "완벽한 테스트는 불가능하다."
        ],
        "answer": "동일한 테스트 케이스를 반복하면 더 이상 새로운 결함을 찾을 수 없다.",
        "hint": "내성이 생겨 약이 듣지 않는 현상에 비유했습니다.",
        "explanation": "살충제 패러독스는 동일한 테스트 케이스로 반복 테스트를 수행하면 내성이 생겨 새로운 버그를 찾지 못하므로, 주기적으로 테스트 케이스를 개선해야 함을 의미합니다."
    },
    {
        "level": 2,
        "problem": "정렬된 두 개의 리스트를 하나의 정렬된 리스트로 합치면서 정렬하는 알고리즘은?",
        "options": [
            "Merge Sort",
            "Quick Sort",
            "Heap Sort",
            "Bubble Sort"
        ],
        "answer": "Merge Sort",
        "hint": "분할 정복(Divide and Conquer) 방식의 대표적인 예입니다.",
        "explanation": "합병 정렬(Merge Sort)은 리스트를 잘게 쪼갠 뒤, 정렬하면서 다시 하나로 합치는(Merge) 방식입니다."
    },
    {
        "level": 2,
        "problem": "인터페이스 구현 시 사용되는 'JSON'의 자료형(Type)에 포함되지 않는 것은?",
        "options": [
            "String",
            "Number",
            "Boolean",
            "Date"
        ],
        "answer": "Date",
        "hint": "날짜는 주로 문자열로 표현합니다.",
        "explanation": "JSON의 기본 자료형은 String, Number, Boolean, Null, Object, Array이며, Date 타입은 별도로 존재하지 않아 문자열(String)로 처리합니다."
    },
    {
        "level": 2,
        "problem": "다음 트리를 중위 순회(Inorder Traversal) 했을 때의 순서는? (Root: A, Left: B, Right: C)",
        "options": [
            "B - A - C",
            "A - B - C",
            "B - C - A",
            "C - B - A"
        ],
        "answer": "B - A - C",
        "hint": "Left -> Root -> Right 순서입니다.",
        "explanation": "중위 순회는 왼쪽 자식(B) -> 루트(A) -> 오른쪽 자식(C) 순으로 방문합니다."
    },
    {
        "level": 2,
        "problem": "해싱(Hashing)에서 서로 다른 두 키가 해시 함수에 의해 동일한 주소로 계산되는 현상은?",
        "options": [
            "Synonym",
            "Collision",
            "Bucket",
            "Overflow"
        ],
        "answer": "Collision",
        "hint": "충돌이라고 합니다.",
        "explanation": "Collision(충돌)은 서로 다른 키가 같은 해시 값을 가지게 되어 동일한 주소를 배정받으려는 현상입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 품질 목표 중 '이식성(Portability)'의 하위 특성이 아닌 것은?",
        "options": [
            "적응성",
            "설치성",
            "대체성",
            "성숙성"
        ],
        "answer": "성숙성",
        "hint": "성숙성은 신뢰성(Reliability)의 하위 특성입니다.",
        "explanation": "이식성의 하위 특성은 적응성, 설치성, 공존성, 대체성입니다. 성숙성은 신뢰성의 하위 특성입니다."
    },
    {
        "level": 2,
        "problem": "화이트박스 테스트 검증 기준 중 '모든 분기(Branch)의 참, 거짓 경로를 최소 한 번 이상 수행'하는 것은?",
        "options": [
            "구문 커버리지(Statement Coverage)",
            "결정 커버리지(Decision Coverage)",
            "조건 커버리지(Condition Coverage)",
            "경로 커버리지(Path Coverage)"
        ],
        "answer": "결정 커버리지(Decision Coverage)",
        "hint": "분기 커버리지라고도 합니다.",
        "explanation": "결정 커버리지는 각 분기점(결정 포인트)의 전체 조건식이 참이 되는 경우와 거짓이 되는 경우를 적어도 한 번씩 수행합니다."
    },
    {
        "level": 2,
        "problem": "알고리즘의 시간 복잡도 중 O(n log n)에 해당하는 정렬 알고리즘은?",
        "options": [
            "Insertion Sort",
            "Selection Sort",
            "Heap Sort",
            "Bubble Sort"
        ],
        "answer": "Heap Sort",
        "hint": "트리 구조를 이용한 정렬입니다.",
        "explanation": "Heap Sort와 Merge Sort는 최악의 경우에도 O(n log n)을 보장합니다. 나머지는 평균 또는 최악의 경우 O(n^2)입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 형상 관리(SCM) 용어 중 '소스 코드의 변경 사항을 메인 저장소(Trunk/Master)에 반영하는 작업'은?",
        "options": [
            "Check-out",
            "Check-in(Commit)",
            "Import",
            "Update"
        ],
        "answer": "Check-in(Commit)",
        "hint": "작업을 완료하고 저장소에 등록합니다.",
        "explanation": "Check-in(또는 Commit)은 개발자가 수정한 소스 코드를 형상 관리 저장소에 갱신하는 작업입니다."
    },
    {
        "level": 2,
        "problem": "스택(Stack)을 이용하여 구현하기 가장 적절한 것은?",
        "options": [
            "운영체제의 작업 큐",
            "프린터 버퍼",
            "함수의 재귀 호출(Recursion)",
            "은행 대기표 시스템"
        ],
        "answer": "함수의 재귀 호출(Recursion)",
        "hint": "되돌아갈 위치를 기억해야 합니다.",
        "explanation": "재귀 호출 시 함수가 복귀할 주소를 저장하기 위해 시스템 스택(System Stack)이 사용됩니다. 나머지는 큐(Queue)의 예시입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 테스트에서 '회귀 테스트(Regression Test)'의 목적은?",
        "options": [
            "새로운 기능의 오류 검출",
            "변경된 코드나 수정된 결함으로 인해 기존 기능에 부작용이 없는지 확인",
            "사용자 요구사항 만족 여부 확인",
            "시스템의 최대 성능 측정"
        ],
        "answer": "변경된 코드나 수정된 결함으로 인해 기존 기능에 부작용이 없는지 확인",
        "hint": "과거에 잘 되던 기능이 망가지지 않았는지 확인합니다.",
        "explanation": "회귀 테스트는 오류 수정이나 코드 변경 후, 기존에 정상 작동하던 기능에 문제가 생기지 않았는지 반복해서 테스트하는 것입니다."
    },
    {
        "level": 2,
        "problem": "인터페이스 보안 기술 중 '공개키 암호화 방식(PKI)'을 기반으로 웹 브라우저와 서버 간의 통신을 암호화하는 프로토콜은?",
        "options": [
            "FTP",
            "Telnet",
            "SSL/TLS",
            "SNMP"
        ],
        "answer": "SSL/TLS",
        "hint": "https:// 로 시작하는 주소에서 사용됩니다.",
        "explanation": "SSL/TLS는 전송 계층에서 데이터 암호화, 서버 인증 등을 제공하여 웹 통신의 보안을 담당합니다."
    },
    {
        "level": 2,
        "problem": "EAI 구축 유형 중 'Hub & Spoke' 방식의 단점은?",
        "options": [
            "확장성이 떨어진다.",
            "허브 장애 시 전체 시스템에 영향을 준다.",
            "1:1 연결로 유지보수가 어렵다.",
            "보안 적용이 불가능하다."
        ],
        "answer": "허브 장애 시 전체 시스템에 영향을 준다.",
        "hint": "중앙 집중형 구조의 취약점입니다.",
        "explanation": "Hub & Spoke는 중앙 허브를 통해 데이터를 중계하므로, 허브에 장애가 발생하면 연결된 모든 시스템이 마비될 수 있습니다."
    },
    {
        "level": 2,
        "problem": "다음 중 '최소 비용 신장 트리(MST)'를 구하는 알고리즘은?",
        "options": [
            "Dijkstra 알고리즘",
            "Prim 알고리즘",
            "Floyd-Warshall 알고리즘",
            "A* 알고리즘"
        ],
        "answer": "Prim 알고리즘",
        "hint": "Kruskal 알고리즘과 함께 MST를 구하는 대표적인 방법입니다.",
        "explanation": "Prim 알고리즘과 Kruskal 알고리즘은 그래프의 모든 정점을 가장 적은 비용으로 연결하는 최소 신장 트리를 구하는 알고리즘입니다."
    },
    {
        "level": 2,
        "problem": "블랙박스 테스트 기법 중 '원인-효과 그래프(Cause-Effect Graphing)' 검사의 설명으로 옳은 것은?",
        "options": [
            "입력 데이터 간의 관계와 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정한다.",
            "입력값의 경계값을 중심으로 테스트한다.",
            "프로그램의 제어 구조를 그래프로 그린다.",
            "모든 가능한 입력 조합을 테스트한다."
        ],
        "answer": "입력 데이터 간의 관계와 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정한다.",
        "hint": "입력(원인)과 출력(효과)의 논리적 관계를 봅니다.",
        "explanation": "원인-효과 그래프 검사는 입력 조건(원인)과 결과(효과) 간의 관계를 그래프로 표현하여 테스트 케이스를 도출하는 기법입니다."
    },
    {
        "level": 2,
        "problem": "다음 자료구조 중 데이터의 삽입과 삭제가 리스트의 한쪽 끝(Top)에서만 이루어지는 것은?",
        "options": [
            "Stack",
            "Queue",
            "Graph",
            "Array"
        ],
        "answer": "Stack",
        "hint": "쌓아 올리는 구조입니다.",
        "explanation": "스택(Stack)은 LIFO 구조로, Top이라 불리는 한쪽 끝에서만 삽입(Push)과 삭제(Pop)가 일어납니다."
    },
    {
        "level": 2,
        "problem": "애플리케이션 성능 테스트 도구 중 'JMeter'의 주 용도는?",
        "options": [
            "정적 코드 분석",
            "웹 애플리케이션 부하 및 성능 테스트",
            "단위 테스트 자동화",
            "보안 취약점 점검"
        ],
        "answer": "웹 애플리케이션 부하 및 성능 테스트",
        "hint": "Apache 재단에서 만든 부하 테스트 도구입니다.",
        "explanation": "JMeter는 서버, 네트워크 등의 부하를 시뮬레이션하고 성능을 분석하는 데 사용되는 오픈 소스 도구입니다."
    },
    {
        "level": 2,
        "problem": "비대칭 키 암호화 알고리즘(공개키 암호화)에 해당하는 것은?",
        "options": [
            "DES",
            "AES",
            "SEED",
            "RSA"
        ],
        "answer": "RSA",
        "hint": "소인수분해의 어려움을 이용합니다.",
        "explanation": "RSA는 대표적인 공개키 암호화 알고리즘입니다. DES, AES, SEED는 대칭 키(비밀키) 암호화 방식입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 유지보수 중 '예방(Preventive) 유지보수'의 정의는?",
        "options": [
            "발견된 잠재적인 오류를 미리 수정하거나 기능을 개선하여 미래의 유지보수를 용이하게 하는 활동",
            "환경 변화에 대응하는 활동",
            "오류를 수정하는 활동",
            "사용자 요구에 의해 기능을 추가하는 활동"
        ],
        "answer": "발견된 잠재적인 오류를 미리 수정하거나 기능을 개선하여 미래의 유지보수를 용이하게 하는 활동",
        "hint": "문제가 생기기 전에 미리 조치하는 것입니다.",
        "explanation": "예방 유지보수는 현재 문제는 없으나 장래의 유지보수성이나 신뢰성을 향상시키기 위해 코드 구조를 개선(리팩토링 등)하는 활동입니다."
    },
    {
        "level": 2,
        "problem": "다음 코드의 시간 복잡도는? for(i=0; i<n; i++) { for(j=0; j<n; j++) { ... } }",
        "options": [
            "O(1)",
            "O(n)",
            "O(n^2)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "hint": "중첩 루프입니다.",
        "explanation": "n번 반복하는 루프 안에 n번 반복하는 루프가 중첩되어 있으므로 n * n = n^2의 복잡도를 가집니다."
    },
    {
        "level": 2,
        "problem": "인터페이스 연계 기술 중 'Socket' 방식에 대한 설명으로 옳은 것은?",
        "options": [
            "서버와 클라이언트가 특정 포트를 통해 연결을 설정하고 실시간으로 양방향 통신을 한다.",
            "DB 테이블을 공유하여 데이터를 연계한다.",
            "파일을 생성하여 전송한다.",
            "웹 서비스를 통해 메서드를 호출한다."
        ],
        "answer": "서버와 클라이언트가 특정 포트를 통해 연결을 설정하고 실시간으로 양방향 통신을 한다.",
        "hint": "TCP/IP 통신의 기본입니다.",
        "explanation": "소켓(Socket)은 네트워크상에서 프로세스 간 통신의 종착점(Endpoint)으로, 연결 지향적이며 실시간 양방향 통신을 지원합니다."
    },
    {
        "level": 2,
        "problem": "형상 관리 도구 중 SVN(Subversion)의 특징이 아닌 것은?",
        "options": [
            "중앙 집중형 버전 관리 시스템이다.",
            "커밋(Commit) 시 서버에 바로 반영된다.",
            "분산 저장소를 지원하여 오프라인 작업이 용이하다.",
            "CVS의 단점을 보완하여 개발되었다."
        ],
        "answer": "분산 저장소를 지원하여 오프라인 작업이 용이하다.",
        "hint": "분산 저장소는 Git의 특징입니다.",
        "explanation": "SVN은 중앙 집중형(Centralized) 시스템으로, 중앙 서버에 연결되어 있어야만 이력 관리가 가능합니다. 분산 저장소는 Git의 특징입니다."
    },
    {
        "level": 2,
        "problem": "다음 중 '단위 테스트(Unit Test)' 도구가 아닌 것은?",
        "options": [
            "JUnit",
            "NUnit",
            "CppUnit",
            "LoadRunner"
        ],
        "answer": "LoadRunner",
        "hint": "부하 테스트 도구입니다.",
        "explanation": "xUnit 계열(JUnit, NUnit 등)은 단위 테스트 도구이며, LoadRunner는 성능 및 부하 테스트 도구입니다."
    },
    {
        "level": 2,
        "problem": "자료구조 '그래프(Graph)'에서 인접한 정점(Vertex) 간의 연결선(Edge)에 가중치나 방향이 없는 그래프는?",
        "options": [
            "방향 그래프 (Directed Graph)",
            "무방향 그래프 (Undirected Graph)",
            "가중치 그래프 (Weighted Graph)",
            "완전 그래프 (Complete Graph)"
        ],
        "answer": "무방향 그래프 (Undirected Graph)",
        "hint": "화살표가 없고 단순한 선으로 연결됩니다.",
        "explanation": "간선에 방향성이 없는 그래프를 무방향 그래프라고 합니다."
    },
    {
        "level": 2,
        "problem": "알고리즘 기법 중 '탐욕법(Greedy Algorithm)'의 특징은?",
        "options": [
            "각 단계에서 당장 눈앞에 보이는 최적의 선택을 한다.",
            "전체 문제의 최적해를 보장한다.",
            "과거의 선택을 번복하여 다시 탐색한다.",
            "문제를 분할하여 병렬로 처리한다."
        ],
        "answer": "각 단계에서 당장 눈앞에 보이는 최적의 선택을 한다.",
        "hint": "근시안적인 선택 방식입니다.",
        "explanation": "탐욕법은 현재 시점에서 가장 이득이 되는 것을 선택하는 방식으로, 항상 전체적인 최적해를 보장하지는 않습니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 패키징 시 '릴리즈 노트(Release Note)'에 포함될 항목으로 가장 거리가 먼 것은?",
        "options": [
            "버전 정보",
            "주요 기능 개선 사항",
            "소스 코드 전체",
            "알려진 버그 및 해결 방법"
        ],
        "answer": "소스 코드 전체",
        "hint": "사용자에게 코드를 보여줄 필요는 없습니다.",
        "explanation": "릴리즈 노트는 사용자에게 변경 사항을 알리는 문서이므로, 소스 코드 자체는 포함하지 않습니다."
    },
    {
        "level": 2,
        "problem": "다음 중 정적 분석(Static Analysis)을 통해 검출할 수 있는 결함이 아닌 것은?",
        "options": [
            "선언되지 않은 변수 사용",
            "실행 시 메모리 누수",
            "코딩 표준 위반",
            "사용되지 않는 코드(Dead Code)"
        ],
        "answer": "실행 시 메모리 누수",
        "hint": "실행을 해봐야 알 수 있는 동적인 문제입니다.",
        "explanation": "메모리 누수나 스레드 교착 상태 등은 프로그램을 실제 실행시켜 보아야 알 수 있는 동적 분석의 영역입니다. (일부 정적 도구가 추정은 가능하나 정확한 검출은 동적 분석이 유리)"
    },
    {
        "level": 2,
        "problem": "AJAX 기술에서 서버와 비동기 통신을 담당하는 자바스크립트 객체는?",
        "options": [
            "DOMParser",
            "XMLHttpRequest",
            "ActiveXObject",
            "JSON"
        ],
        "answer": "XMLHttpRequest",
        "hint": "XHR이라고 줄여서 부릅니다.",
        "explanation": "AJAX의 핵심은 XMLHttpRequest 객체를 사용하여 백그라운드에서 서버와 데이터를 교환하는 것입니다."
    },
    {
        "level": 2,
        "problem": "선택 정렬(Selection Sort)의 시간 복잡도(평균 및 최악)는?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n^2)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "hint": "이중 루프를 돌며 최솟값을 찾습니다.",
        "explanation": "선택 정렬은 매번 최솟값을 찾아 맨 앞과 교환하는 방식으로, 비교 횟수가 항상 n(n-1)/2번 발생하여 O(n^2)입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 품질 특성 중 '신뢰성(Reliability)'의 측정 척도가 되는 것은?",
        "options": [
            "MTBF (Mean Time Between Failures)",
            "LOC (Lines Of Code)",
            "FPS (Frames Per Second)",
            "DPI (Dots Per Inch)"
        ],
        "answer": "MTBF (Mean Time Between Failures)",
        "hint": "평균 고장 간격입니다.",
        "explanation": "MTBF(평균 고장 간격)는 시스템이 고장 나지 않고 정상적으로 작동하는 평균 시간을 의미하며 신뢰성의 주요 척도입니다."
    },
    {
        "level": 2,
        "problem": "다음 중 XML(Extensible Markup Language)의 특징이 아닌 것은?",
        "options": [
            "사용자가 태그를 정의할 수 있다.",
            "데이터의 구조와 의미를 기술한다.",
            "HTML과 호환성이 없다.",
            "트리 구조로 문서를 표현한다."
        ],
        "answer": "HTML과 호환성이 없다.",
        "hint": "웹 표준 기술들은 서로 연동이 잘 됩니다.",
        "explanation": "XML은 HTML과 함께 웹에서 사용되며, 상호 보완적인 관계를 가집니다. 호환성이 없다는 말은 틀립니다."
    },
    {
        "level": 2,
        "problem": "테스트 케이스 생성 기법 중 '상태 전이(State Transition) 테스트'는 어떤 경우에 효과적인가?",
        "options": [
            "입력 데이터의 범위가 클 때",
            "시스템이 이벤트에 따라 상태가 변경되는 로직일 때",
            "내부 계산식이 복잡할 때",
            "데이터베이스 조회가 많을 때"
        ],
        "answer": "시스템이 이벤트에 따라 상태가 변경되는 로직일 때",
        "hint": "이벤트와 상태 변화가 핵심입니다.",
        "explanation": "상태 전이 테스트는 시스템의 상태 변화(State Machine)를 모델링하여, 특정 이벤트에 따른 상태 전이가 올바른지 검증하는 기법입니다."
    },
    {
        "level": 2,
        "problem": "자료구조에서 '우선순위 큐(Priority Queue)'를 구현하기에 가장 효율적인 자료구조는?",
        "options": [
            "Stack",
            "Linked List",
            "Heap",
            "Array"
        ],
        "answer": "Heap",
        "hint": "최대값이나 최소값을 빠르게 찾아야 합니다.",
        "explanation": "힙(Heap)은 부모 노드가 자식 노드보다 우선순위가 높은 완전 이진 트리로, 우선순위 큐 구현에 최적화되어 있습니다."
    },
    {
        "level": 2,
        "problem": "다음 중 DRM(Digital Rights Management) 기술 요소가 아닌 것은?",
        "options": [
            "암호화(Encryption)",
            "워터마킹(Watermarking)",
            "크롤링(Crawling)",
            "키 관리(Key Management)"
        ],
        "answer": "크롤링(Crawling)",
        "hint": "크롤링은 검색 엔진이 데이터를 수집하는 기술입니다.",
        "explanation": "크롤링은 웹 데이터를 수집하는 기술이며, DRM은 저작권 보호를 위한 암호화, 워터마킹, 식별, 키 관리 등의 기술을 포함합니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 개발 단계에서 '빌드(Build)'의 의미는?",
        "options": [
            "소스 코드를 실행 가능한 소프트웨어 산출물로 변환하는 과정",
            "요구사항을 분석하는 과정",
            "테스트 계획을 수립하는 과정",
            "데이터베이스를 설계하는 과정"
        ],
        "answer": "소스 코드를 실행 가능한 소프트웨어 산출물로 변환하는 과정",
        "hint": "컴파일, 링크, 패키징 등을 포함합니다.",
        "explanation": "빌드는 소스 코드를 컴파일, 링크, 패키징하여 실행 가능한 파일이나 배포 가능한 형태로 만드는 일련의 과정입니다."
    },
    {
        "level": 2,
        "problem": "다음 중 인터페이스 예외 처리 방법으로 적절하지 않은 것은?",
        "options": [
            "예외 상황을 로그로 남긴다.",
            "사용자에게 알기 쉬운 에러 메시지를 제공한다.",
            "예외 발생 시 시스템을 즉시 강제 종료한다.",
            "트랜잭션을 롤백(Rollback)한다."
        ],
        "answer": "예외 발생 시 시스템을 즉시 강제 종료한다.",
        "hint": "안정적인 서비스 운영이 목표입니다.",
        "explanation": "예외가 발생하더라도 시스템이 비정상 종료되지 않도록 예외 처리를 통해 안정성을 확보해야 합니다."
    },
    {
        "level": 2,
        "problem": "화이트박스 테스트의 검증 기법 중 '데이터 흐름(Data Flow) 검사'의 기준은?",
        "options": [
            "변수의 정의(Definition)와 사용(Use) 위치에 초점을 맞춘다.",
            "모든 문장을 실행한다.",
            "모든 분기를 실행한다.",
            "경계값을 테스트한다."
        ],
        "answer": "변수의 정의(Definition)와 사용(Use) 위치에 초점을 맞춘다.",
        "hint": "변수 값이 어디서 설정되고 어디서 쓰이는지 봅니다.",
        "explanation": "데이터 흐름 검사는 프로그램 내 변수의 정의와 사용 경로를 추적하여 결함을 발견하는 기법입니다."
    },
    {
        "level": 2,
        "problem": "Git에서 현재 작업 중인 브랜치를 다른 브랜치로 변경하는 명령어는?",
        "options": [
            "git init",
            "git checkout (또는 switch)",
            "git add",
            "git status"
        ],
        "answer": "git checkout (또는 switch)",
        "hint": "체크아웃 한다고 합니다.",
        "explanation": "git checkout [브랜치명] 또는 최신 버전의 git switch [브랜치명]을 사용하여 작업 브랜치를 변경합니다."
    },
    {
        "level": 2,
        "problem": "알고리즘 설계 기법 중 '분할 정복(Divide and Conquer)'을 사용하는 알고리즘은?",
        "options": [
            "Quick Sort",
            "Insertion Sort",
            "DFS",
            "Dijkstra"
        ],
        "answer": "Quick Sort",
        "hint": "문제를 작게 나누어 해결하고 합칩니다.",
        "explanation": "Quick Sort와 Merge Sort는 문제를 작은 부분 문제로 분할하여 해결하는 분할 정복 기법의 대표적인 예입니다."
    },
    {
        "level": 2,
        "problem": "ISO/IEC 9126 품질 특성 중 '기능성(Functionality)'의 부특성이 아닌 것은?",
        "options": [
            "적절성",
            "정밀성",
            "상호운용성",
            "학습성"
        ],
        "answer": "학습성",
        "hint": "학습성은 사용성(Usability)의 부특성입니다.",
        "explanation": "학습성, 이해성, 운용성은 '사용성(Usability)'의 부특성입니다. 기능성은 적절성, 정밀성, 상호운용성, 보안성 등을 포함합니다."
    },
    {
        "level": 2,
        "problem": "다음 중 '큐(Queue)' 자료구조의 동작 원리는?",
        "options": [
            "FIFO (First In First Out)",
            "LIFO (Last In First Out)",
            "Random Access",
            "Priority Based"
        ],
        "answer": "FIFO (First In First Out)",
        "hint": "선착순입니다.",
        "explanation": "큐는 먼저 들어온 데이터가 먼저 나가는 선입선출(FIFO) 구조입니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 버전 등록 시 'Major.Minor.Patch' 형식(Semantic Versioning)에서 '기존 버전과 호환되지 않는 큰 변화'가 있을 때 증가시키는 숫자는?",
        "options": [
            "Major",
            "Minor",
            "Patch",
            "Build Number"
        ],
        "answer": "Major",
        "hint": "가장 앞자리 숫자입니다.",
        "explanation": "Major 버전은 하위 호환성이 깨지는 중대한 변경 시 증가시키며, Minor는 기능 추가, Patch는 버그 수정 시 증가시킵니다."
    },
    {
        "level": 2,
        "problem": "다음 중 '형상 감사(Configuration Audit)'의 목적으로 옳은 것은?",
        "options": [
            "베이스라인의 무결성을 평가하고, 변경 사항이 요구사항과 일치하는지 확인한다.",
            "각 버전의 소스 코드를 백업한다.",
            "개발자의 성과를 측정한다.",
            "테스트 케이스를 작성한다."
        ],
        "answer": "베이스라인의 무결성을 평가하고, 변경 사항이 요구사항과 일치하는지 확인한다.",
        "hint": "제대로 변경되었는지 검사하는 것입니다.",
        "explanation": "형상 감사는 형상 항목의 변경이 계획대로 이루어졌는지, 요구사항을 만족하는지 검토하고 보증하는 활동입니다."
    },
    {
        "level": 2,
        "problem": "인터페이스 구현 시 'REST(Representational State Transfer)' 아키텍처에서 자원(Resource)을 조작하기 위해 사용하는 HTTP 메서드가 아닌 것은?",
        "options": [
            "GET",
            "POST",
            "DELETE",
            "CONNECT"
        ],
        "answer": "CONNECT",
        "hint": "CRUD 연산에 매핑되는 메서드를 생각하세요.",
        "explanation": "RESTful API에서는 주로 GET(조회), POST(생성), PUT(수정), DELETE(삭제) 메서드를 사용하여 자원을 처리합니다. CONNECT는 터널링 목적입니다."
    },
    {
        "level": 2,
        "problem": "다음 중 '버블 정렬(Bubble Sort)'의 최악 시간 복잡도는?",
        "options": [
            "O(n)",
            "O(n log n)",
            "O(n^2)",
            "O(n^3)"
        ],
        "answer": "O(n^2)",
        "hint": "인접한 요소를 계속 비교합니다.",
        "explanation": "버블 정렬은 인접한 두 원소를 비교/교환하는 과정을 반복하므로, 데이터가 역순일 때 최악의 경우 O(n^2)의 시간이 소요됩니다."
    },
    {
        "level": 2,
        "problem": "소프트웨어 테스트에서 '드라이버(Driver)'와 '스텁(Stub)'의 차이점은?",
        "options": [
            "드라이버는 상위 모듈 역할을, 스텁은 하위 모듈 역할을 한다.",
            "드라이버는 하향식 테스트, 스텁은 상향식 테스트에 사용된다.",
            "둘 다 동일한 기능을 한다.",
            "드라이버는 데이터베이스, 스텁은 네트워크를 테스트한다."
        ],
        "answer": "드라이버는 상위 모듈 역할을, 스텁은 하위 모듈 역할을 한다.",
        "hint": "상향식(Bottom-up)엔 드라이버, 하향식(Top-down)엔 스텁이 필요합니다.",
        "explanation": "상향식 테스트에서는 상위 모듈이 없으므로 '드라이버'가 호출하고, 하향식 테스트에서는 하위 모듈이 없으므로 '스텁'이 호출을 받아 흉내를 냅니다."
    },
    {
        "level": 2,
        "problem": "다음 중 해시 함수(Hash Function)의 종류가 아닌 것은?",
        "options": [
            "제산법 (Division)",
            "폴딩법 (Folding)",
            "숫자 분석법 (Digit Analysis)",
            "이진 탐색법 (Binary Search)"
        ],
        "answer": "이진 탐색법 (Binary Search)",
        "hint": "이진 탐색은 검색 알고리즘입니다.",
        "explanation": "이진 탐색법은 검색 알고리즘이며, 해시 함수 생성 방법에는 제산법, 제곱법, 폴딩법, 숫자 분석법, 기수 변환법 등이 있습니다."
    },
    {
        "level": 2,
        "problem": "애플리케이션 배포 도구 중 컨테이너 기반의 가상화 플랫폼으로, '이미지'를 통해 애플리케이션 실행 환경을 격리하는 것은?",
        "options": [
            "Jenkins",
            "Docker",
            "Git",
            "Maven"
        ],
        "answer": "Docker",
        "hint": "고래 로고가 유명합니다.",
        "explanation": "Docker는 컨테이너 기술을 사용하여 애플리케이션을 실행 환경과 함께 패키징하고 배포하는 플랫폼입니다."
    },
    {
        "level": 3,
        "problem": "관계 대수(Relational Algebra) 연산 중, 두 릴레이션 R과 S에서 R에는 속하지만 S에는 속하지 않는 튜플들로 구성된 릴레이션을 반환하는 연산은?",
        "options": [
            "Union",
            "Intersection",
            "Difference",
            "Cartesian Product"
        ],
        "answer": "Difference",
        "hint": "집합 연산 중 차집합을 의미합니다.",
        "explanation": "차집합(Difference, -) 연산은 R-S로 표현하며, R에는 존재하고 S에는 존재하지 않는 튜플을 구합니다."
    },
    {
        "level": 3,
        "problem": "다음 SQL 문의 실행 결과로 올바른 설명은? 'DROP TABLE 사원 CASCADE CONSTRAINTS;'",
        "options": [
            "사원 테이블만 삭제하고, 참조 무결성 제약조건은 남겨둔다.",
            "사원 테이블과 이를 참조하는 다른 테이블의 제약조건까지 모두 삭제한다.",
            "사원 테이블의 데이터만 삭제하고 구조는 남긴다.",
            "참조하는 테이블이 있으면 삭제를 취소한다."
        ],
        "answer": "사원 테이블과 이를 참조하는 다른 테이블의 제약조건까지 모두 삭제한다.",
        "hint": "CASCADE 옵션은 연쇄적인 동작을 의미합니다.",
        "explanation": "CASCADE CONSTRAINTS 옵션은 해당 테이블을 참조하고 있는 다른 테이블의 외래키(Foreign Key) 제약조건(Constraint)까지 연쇄적으로 삭제합니다."
    },
    {
        "level": 3,
        "problem": "트랜잭션의 특성(ACID) 중 '시스템이 고장 나더라도 트랜잭션의 결과는 영구적으로 반영되어야 한다'는 성질은?",
        "options": [
            "Atomicity (원자성)",
            "Consistency (일관성)",
            "Isolation (격리성)",
            "Durability (영속성)"
        ],
        "answer": "Durability (영속성)",
        "hint": "완료(Commit)된 결과는 사라지지 않아야 합니다.",
        "explanation": "영속성(Durability)은 트랜잭션이 성공적으로 완료되면 그 결과는 시스템 오류가 발생하더라도 영구적으로 보존되어야 한다는 특성입니다."
    },
    {
        "level": 3,
        "problem": "정규화 과정 중 '결정자가 후보키가 아닌 함수 종속을 제거'하여 모든 결정자가 후보키가 되도록 만드는 단계는?",
        "options": [
            "2NF",
            "3NF",
            "BCNF",
            "4NF"
        ],
        "answer": "BCNF",
        "hint": "3차 정규형(3NF) 다음 단계입니다.",
        "explanation": "BCNF(Boyce-Codd Normal Form)는 3NF를 만족하면서, 모든 결정자가 후보키 집합에 속하는 정규형입니다. (강한 제 3정규형)"
    },
    {
        "level": 3,
        "problem": "분산 데이터베이스의 투명성(Transparency) 중 '데이터가 여러 곳에 복제되어 있어도 사용자는 하나만 있는 것처럼 사용할 수 있어야 한다'는 성질은?",
        "options": [
            "위치 투명성",
            "중복 투명성",
            "병행 투명성",
            "장애 투명성"
        ],
        "answer": "중복 투명성",
        "hint": "Replication Transparency라고도 합니다.",
        "explanation": "중복 투명성(Replication Transparency)은 동일한 데이터가 여러 곳에 중복 저장되어 있더라도 사용자는 논리적으로 하나의 데이터처럼 다룰 수 있어야 함을 의미합니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스의 뷰(View)에 대한 설명으로 틀린 것은?",
        "options": [
            "물리적으로 데이터를 저장하지 않는 가상 테이블이다.",
            "독자적인 인덱스를 가질 수 있다.",
            "데이터 보안 및 논리적 독립성을 제공한다.",
            "뷰 위에 또 다른 뷰를 정의할 수 있다."
        ],
        "answer": "독자적인 인덱스를 가질 수 있다.",
        "hint": "뷰는 물리적 실체가 없습니다.",
        "explanation": "뷰는 가상 테이블이므로 물리적으로 존재하지 않아 독자적인 인덱스를 가질 수 없습니다. (인덱스는 물리적 저장소에 생성됨)"
    },
    {
        "level": 3,
        "problem": "E-R 다이어그램에서 '약한 개체(Weak Entity)'를 표현하는 기호는?",
        "options": [
            "이중 직사각형",
            "이중 타원",
            "이중 마름모",
            "점선 직사각형"
        ],
        "answer": "이중 직사각형",
        "hint": "강한 개체에 종속적인 개체입니다.",
        "explanation": "약한 개체 타입은 이중 직사각형으로, 약한 개체를 연결하는 관계는 이중 마름모로 표현합니다."
    },
    {
        "level": 3,
        "problem": "관계 데이터 모델에서 '후보키(Candidate Key)'가 되기 위해 만족해야 하는 두 가지 성질은?",
        "options": [
            "유일성, 최소성",
            "유일성, 정보성",
            "최소성, 원자성",
            "원자성, 일관성"
        ],
        "answer": "유일성, 최소성",
        "hint": "슈퍼키는 유일성만 만족합니다.",
        "explanation": "후보키는 튜플을 유일하게 식별할 수 있는 '유일성'과 꼭 필요한 속성으로만 구성되어야 하는 '최소성'을 모두 만족해야 합니다."
    },
    {
        "level": 3,
        "problem": "SQL에서 'HAVING' 절의 용도는?",
        "options": [
            "테이블을 그룹화한다.",
            "그룹화된 결과에 대한 조건을 지정한다.",
            "정렬 순서를 지정한다.",
            "중복을 제거한다."
        ],
        "answer": "그룹화된 결과에 대한 조건을 지정한다.",
        "hint": "GROUP BY와 함께 사용됩니다.",
        "explanation": "WHERE 절은 개별 행에 대한 조건이고, HAVING 절은 GROUP BY로 그룹화된 집계 결과에 대한 조건을 지정할 때 사용합니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 회복 기법 중 '로그(Log)'를 이용하지 않는 기법은?",
        "options": [
            "즉시 갱신 기법",
            "지연 갱신 기법",
            "그림자 페이징 기법",
            "체크포인트 기법"
        ],
        "answer": "그림자 페이징 기법",
        "hint": "페이지 테이블을 교체하는 방식입니다.",
        "explanation": "그림자 페이징(Shadow Paging) 기법은 로그 대신 데이터베이스를 페이지 단위로 복제하여 원본과 그림자 페이지를 유지하는 방식입니다."
    },
    {
        "level": 3,
        "problem": "병행 제어(Concurrency Control) 기법 중 '로킹(Locking)' 단위에 대한 설명으로 옳은 것은?",
        "options": [
            "로킹 단위가 클수록 병행성 수준이 높아진다.",
            "로킹 단위가 작을수록 로킹 오버헤드가 감소한다.",
            "로킹 단위가 클수록 데이터베이스 공유도가 낮아진다.",
            "로킹 단위는 파일 단위로만 설정 가능하다."
        ],
        "answer": "로킹 단위가 클수록 데이터베이스 공유도가 낮아진다.",
        "hint": "단위가 크면 한 번에 잠그는 범위가 넓어집니다.",
        "explanation": "로킹 단위가 크면(예: 테이블 전체) 관리는 쉽지만 병행성(공유도)이 낮아지고, 단위가 작으면(예: 행) 병행성은 높아지지만 오버헤드가 증가합니다."
    },
    {
        "level": 3,
        "problem": "관계 대수에서 순수 관계 연산자에 해당하지 않는 것은?",
        "options": [
            "Select",
            "Project",
            "Join",
            "Cartesian Product"
        ],
        "answer": "Cartesian Product",
        "hint": "Cartesian Product는 일반 집합 연산자입니다.",
        "explanation": "순수 관계 연산자는 Select, Project, Join, Division입니다. Cartesian Product(교차곱), Union, Intersection, Difference는 일반 집합 연산자입니다."
    },
    {
        "level": 3,
        "problem": "데이터 웨어하우스에서 사용자의 의사결정을 돕기 위해 데이터를 다차원적으로 분석하고 대화식으로 정보를 분석하는 프로세스는?",
        "options": [
            "OLTP",
            "OLAP",
            "Data Mining",
            "Batch Processing"
        ],
        "answer": "OLAP",
        "hint": "On-Line Analytical Processing의 약자입니다.",
        "explanation": "OLAP(온라인 분석 처리)은 다차원 데이터 분석을 통해 의사결정을 지원하는 기술입니다. OLTP는 트랜잭션 처리에 중점을 둡니다."
    },
    {
        "level": 3,
        "problem": "다음 중 DDL(Data Definition Language) 명령어가 아닌 것은?",
        "options": [
            "CREATE",
            "ALTER",
            "TRUNCATE",
            "DELETE"
        ],
        "answer": "DELETE",
        "hint": "데이터를 조작하는 언어입니다.",
        "explanation": "DELETE는 데이터를 삭제하는 DML(Data Manipulation Language)입니다. TRUNCATE는 구조는 남기지만 데이터를 모두 삭제하며 자동 커밋되므로 DDL로 분류됩니다."
    },
    {
        "level": 3,
        "problem": "인덱스(Index) 설계 시 고려사항으로 적절하지 않은 것은?",
        "options": [
            "조회 빈도가 높은 컬럼을 선택한다.",
            "카디널리티(Cardinality)가 높은 컬럼이 유리하다.",
            "INSERT, UPDATE, DELETE가 빈번한 컬럼에 많이 생성한다.",
            "WHERE 절이나 JOIN 조건에 자주 사용되는 컬럼을 선택한다."
        ],
        "answer": "INSERT, UPDATE, DELETE가 빈번한 컬럼에 많이 생성한다.",
        "hint": "인덱스도 갱신해야 하므로 성능이 저하됩니다.",
        "explanation": "데이터 변경이 잦은 컬럼에 인덱스가 많으면 인덱스 갱신 오버헤드로 인해 성능이 저하될 수 있습니다."
    },
    {
        "level": 3,
        "problem": "제 2정규형(2NF)에서 제 3정규형(3NF)으로 진행하기 위해 제거해야 하는 이상 현상의 원인은?",
        "options": [
            "부분 함수 종속",
            "이행적 함수 종속",
            "다치 종속",
            "조인 종속"
        ],
        "answer": "이행적 함수 종속",
        "hint": "A->B, B->C 일 때 A->C가 되는 관계입니다.",
        "explanation": "3NF는 이행적 함수 종속(Transitive Functional Dependency)을 제거하여 비주요 속성이 기본키에 대해서만 직접 종속되도록 하는 것입니다."
    },
    {
        "level": 3,
        "problem": "시스템 카탈로그(System Catalog)에 대한 설명으로 틀린 것은?",
        "options": [
            "데이터베이스에 포함되는 모든 데이터 객체에 대한 정의나 명세 정보를 유지 관리한다.",
            "데이터 사전(Data Dictionary)이라고도 한다.",
            "사용자가 SQL 문을 사용하여 직접 내용을 갱신할 수 있다.",
            "시스템이 자동으로 갱신한다."
        ],
        "answer": "사용자가 SQL 문을 사용하여 직접 내용을 갱신할 수 있다.",
        "hint": "시스템이 관리하는 메타 데이터입니다.",
        "explanation": "시스템 카탈로그는 사용자가 내용을 조회(SELECT)할 수는 있으나, 직접 갱신(INSERT, UPDATE, DELETE)하는 것은 불가능합니다. 시스템에 의해 자동 관리됩니다."
    },
    {
        "level": 3,
        "problem": "SQL의 집계 함수 중 NULL 값을 포함하지 않고 계산하는 것은?",
        "options": [
            "COUNT(*)",
            "COUNT(컬럼명)",
            "NVL",
            "ISNULL"
        ],
        "answer": "COUNT(컬럼명)",
        "hint": "별표(*)는 전체 행을 셉니다.",
        "explanation": "COUNT(*)는 NULL을 포함한 전체 행 수를 반환하지만, COUNT(컬럼명) 등 컬럼을 지정한 집계 함수는 NULL 값을 제외하고 계산합니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 보안 기법 중 '공개키 암호화' 방식에 대한 설명으로 옳은 것은?",
        "options": [
            "암호화 키와 복호화 키가 동일하다.",
            "키 분배 및 관리가 비밀키(대칭키) 방식보다 용이하다.",
            "암호화 처리 속도가 매우 빠르다.",
            "대표적인 알고리즘으로 DES가 있다."
        ],
        "answer": "키 분배 및 관리가 비밀키(대칭키) 방식보다 용이하다.",
        "hint": "비대칭키 방식입니다.",
        "explanation": "공개키 암호화(RSA 등)는 암호화 키는 공개하고 복호화 키는 비밀로 하므로 키 분배가 용이합니다. 속도는 대칭키보다 느립니다."
    },
    {
        "level": 3,
        "problem": "트랜잭션 스케줄 중, 직렬 스케줄과 실행 결과가 항상 동일함을 보장하는 스케줄은?",
        "options": [
            "직렬 가능 스케줄(Serializable Schedule)",
            "비직렬 스케줄",
            "회복 불가능 스케줄",
            "연쇄 복귀 스케줄"
        ],
        "answer": "직렬 가능 스케줄(Serializable Schedule)",
        "hint": "비직렬적으로 실행되지만 결과는 직렬과 같습니다.",
        "explanation": "직렬 가능 스케줄은 트랜잭션을 병행 실행하더라도 그 결과가 어떤 순서로 직렬 실행한 결과와 동일한 스케줄을 말합니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '다치 종속(MVD)'을 제거하여 4NF를 만드는 과정은?",
        "options": [
            "1NF -> 2NF",
            "2NF -> 3NF",
            "3NF -> BCNF",
            "BCNF -> 4NF"
        ],
        "answer": "BCNF -> 4NF",
        "hint": "A ->> B 형태로 표현되는 종속성입니다.",
        "explanation": "4NF는 BCNF를 만족하면서 태블 내의 다치 종속(Multi-Valued Dependency) A ->> B를 제거한 정규형입니다."
    },
    {
        "level": 3,
        "problem": "관계형 데이터 모델의 제약조건 중 '참조하는 외래키의 값은 항상 참조되는 릴레이션의 기본키 값이거나 NULL이어야 한다'는 조건은?",
        "options": [
            "개체 무결성",
            "참조 무결성",
            "도메인 무결성",
            "키 무결성"
        ],
        "answer": "참조 무결성",
        "hint": "릴레이션 간의 관계에 대한 제약입니다.",
        "explanation": "참조 무결성(Referential Integrity) 제약조건은 외래키 값은 참조하는 테이블의 기본키로 존재하거나 NULL이어야 한다는 규칙입니다."
    },
    {
        "level": 3,
        "problem": "SQL Injection 공격을 방어하기 위한 방법으로 가장 효과적인 것은?",
        "options": [
            "웹 방화벽 설치",
            "입력값 검증 및 Prepared Statement 사용",
            "데이터베이스 암호화",
            "주기적인 백업"
        ],
        "answer": "입력값 검증 및 Prepared Statement 사용",
        "hint": "코드가 아닌 데이터로 인식하게 해야 합니다.",
        "explanation": "Prepared Statement(파라미터화된 쿼리)를 사용하면 입력값을 실행 가능한 코드가 아닌 단순 데이터로 처리하여 SQL Injection을 근본적으로 차단할 수 있습니다."
    },
    {
        "level": 3,
        "problem": "데이터 모델링의 3단계 진행 순서로 옳은 것은?",
        "options": [
            "논리적 -> 개념적 -> 물리적",
            "개념적 -> 물리적 -> 논리적",
            "개념적 -> 논리적 -> 물리적",
            "물리적 -> 논리적 -> 개념적"
        ],
        "answer": "개념적 -> 논리적 -> 물리적",
        "hint": "추상화 수준이 높은 것에서 낮은 것으로 갑니다.",
        "explanation": "일반적인 설계 순서는 요구사항 분석 -> 개념적 설계(E-R) -> 논리적 설계(테이블, 정규화) -> 물리적 설계(저장 구조) 순입니다."
    },
    {
        "level": 3,
        "problem": "분산 데이터베이스 시스템에서 '2단계 커밋(Two-Phase Commit)' 프로토콜의 목적은?",
        "options": [
            "트랜잭션의 원자성 보장",
            "교착 상태 방지",
            "통신 비용 절감",
            "데이터 암호화"
        ],
        "answer": "트랜잭션의 원자성 보장",
        "hint": "모두 커밋하거나 모두 롤백해야 합니다.",
        "explanation": "분산 환경에서 모든 노드가 트랜잭션을 성공적으로 수행했는지 확인(Prepare -> Commit)하여 전체의 원자성(All or Nothing)을 보장하기 위함입니다."
    },
    {
        "level": 3,
        "problem": "해싱(Hashing)에서 서로 다른 두 개의 키가 해시 함수에 의해 동일한 주소로 변환되는 현상은?",
        "options": [
            "Overflow",
            "Collision",
            "Clustering",
            "Synonym"
        ],
        "answer": "Collision",
        "hint": "충돌이라고 합니다.",
        "explanation": "Collision(충돌)은 서로 다른 키 K1, K2에 대해 Hash(K1) = Hash(K2)가 되는 현상입니다. 이로 인해 같은 버킷에 저장되는 레코드들을 Synonym이라고 합니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 성능 튜닝의 단계 중 가장 큰 성능 향상 효과를 기대할 수 있는 단계는?",
        "options": [
            "하드웨어 튜닝",
            "OS 튜닝",
            "DBMS 메모리 튜닝",
            "SQL 및 데이터 모델 튜닝"
        ],
        "answer": "SQL 및 데이터 모델 튜닝",
        "hint": "설계와 쿼리가 근본적인 원인인 경우가 많습니다.",
        "explanation": "비효율적인 SQL 문이나 잘못된 테이블 설계(모델링)를 개선하는 것이 가장 큰 폭의 성능 향상을 가져옵니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '슈퍼키(Super Key)'이지만 '후보키(Candidate Key)'는 아닌 것은? (학번, 주민번호는 각각 유일하다)",
        "options": [
            "(학번)",
            "(주민번호)",
            "(학번, 이름)",
            "없음"
        ],
        "answer": "(학번, 이름)",
        "hint": "최소성을 만족하지 않는 키를 찾으세요.",
        "explanation": "(학번)만으로도 유일성이 보장되는데 (학번, 이름)은 불필요한 속성을 포함하므로 최소성을 위배하여 후보키가 될 수 없는 슈퍼키입니다."
    },
    {
        "level": 3,
        "problem": "관계 대수 연산식에서 기호 'π'가 나타내는 연산은?",
        "options": [
            "Selection",
            "Projection",
            "Join",
            "Division"
        ],
        "answer": "Projection",
        "hint": "그리스 문자 파이(Pi)입니다.",
        "explanation": "π(Project)는 릴레이션에서 특정 속성(열)만을 추출하는 연산입니다. (σ: Select, ⋈: Join, ÷: Division)"
    },
    {
        "level": 3,
        "problem": "데이터 무결성 제약조건 중, 특정 속성 값이 가질 수 있는 값의 범위를 정의하는 것은?",
        "options": [
            "NULL 무결성",
            "고유(Unique) 무결성",
            "도메인(Domain) 무결성",
            "키 무결성"
        ],
        "answer": "도메인(Domain) 무결성",
        "hint": "성별은 '남', '여'만 가능와 같은 제약입니다.",
        "explanation": "도메인 무결성은 속성 값이 정의된 도메인(범위, 타입 등)에 속해야 한다는 제약조건입니다."
    },
    {
        "level": 3,
        "problem": "로킹(Locking) 기법에서 교착 상태(Deadlock)가 발생할 수 있는 원인이 아닌 것은?",
        "options": [
            "상호 배제 (Mutual Exclusion)",
            "점유와 대기 (Hold and Wait)",
            "비선점 (No Preemption)",
            "다중 사용자 (Multi-User)"
        ],
        "answer": "다중 사용자 (Multi-User)",
        "hint": "교착 상태의 4가지 필요충분조건을 생각해보세요.",
        "explanation": "교착 상태의 4가지 조건은 상호 배제, 점유와 대기, 비선점, 환형 대기(Circular Wait)입니다. 다중 사용자는 환경적 요인일 뿐 조건은 아닙니다."
    },
    {
        "level": 3,
        "problem": "빅데이터의 3V 특성에 해당하지 않는 것은?",
        "options": [
            "Volume (규모)",
            "Velocity (속도)",
            "Variety (다양성)",
            "Value (가치)"
        ],
        "answer": "Value (가치)",
        "hint": "초기 정의된 3V는 물리적 특성 위주입니다. 나중에 Value 등이 추가되어 5V가 되기도 합니다.",
        "explanation": "전통적인 3V는 Volume, Velocity, Variety입니다. Value나 Veracity(정확성)가 추가되기도 하지만, 기본 3요소는 아닙니다."
    },
    {
        "level": 3,
        "problem": "SQL에서 'GRANT SELECT ON User TO Kim WITH GRANT OPTION;'의 의미는?",
        "options": [
            "Kim에게 User 테이블 조회 권한을 주고, 남에게 줄 수는 없게 한다.",
            "Kim에게 User 테이블 조회 권한을 주고, 남에게도 권한을 부여할 수 있게 한다.",
            "Kim에게 모든 권한을 준다.",
            "User 테이블을 Kim 소유로 변경한다."
        ],
        "answer": "Kim에게 User 테이블 조회 권한을 주고, 남에게도 권한을 부여할 수 있게 한다.",
        "hint": "WITH GRANT OPTION이 핵심입니다.",
        "explanation": "WITH GRANT OPTION은 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한까지 함께 주는 옵션입니다."
    },
    {
        "level": 3,
        "problem": "다음 중 파티셔닝(Partitioning)의 장점이 아닌 것은?",
        "options": [
            "데이터 액세스 성능 향상",
            "데이터 가용성 향상",
            "백업 및 복구의 용이성",
            "조인(Join) 비용의 감소"
        ],
        "answer": "조인(Join) 비용의 감소",
        "hint": "테이블이 쪼개지면 조인이 더 복잡해질 수 있습니다.",
        "explanation": "파티셔닝을 하면 파티션 간의 조인이 발생할 경우 오히려 비용이 증가할 수 있습니다. (성능, 가용성, 관리 용이성은 장점)"
    },
    {
        "level": 3,
        "problem": "개체-관계(E-R) 모델에서 '속성(Attribute)'은 어떤 기호로 표시하는가?",
        "options": [
            "직사각형",
            "마름모",
            "타원",
            "선"
        ],
        "answer": "타원",
        "hint": "개체는 직사각형, 관계는 마름모입니다.",
        "explanation": "E-R 다이어그램에서 개체는 직사각형, 관계는 마름모, 속성은 타원으로 표기합니다."
    },
    {
        "level": 3,
        "problem": "정규화의 목적으로 거리가 먼 것은?",
        "options": [
            "데이터 중복을 최소화한다.",
            "이상 현상을 방지한다.",
            "데이터 구조를 확장성 있게 만든다.",
            "데이터 조회 성능을 극대화한다."
        ],
        "answer": "데이터 조회 성능을 극대화한다.",
        "hint": "정규화는 테이블을 쪼개므로 조인이 늘어납니다.",
        "explanation": "정규화는 데이터 무결성과 일관성을 위해 수행하며, 과도한 정규화는 조인 연산을 증가시켜 조회 성능을 저하시킬 수 있습니다. (반정규화의 이유)"
    },
    {
        "level": 3,
        "problem": "NoSQL 데이터베이스의 특징인 'BASE' 속성에 해당하지 않는 것은?",
        "options": [
            "Basically Available",
            "Soft state",
            "Eventually consistent",
            "Atomicity"
        ],
        "answer": "Atomicity",
        "hint": "Atomicity는 RDBMS의 ACID 특성입니다.",
        "explanation": "BASE는 Basically Available, Soft state, Eventually consistent의 약자로, 일관성보다는 가용성을 중시하는 NoSQL의 특성입니다."
    },
    {
        "level": 3,
        "problem": "트리거(Trigger)에 대한 설명으로 옳은 것은?",
        "options": [
            "사용자가 직접 호출하여 실행한다.",
            "데이터베이스의 특정 이벤트(INSERT 등) 발생 시 자동으로 실행된다.",
            "매개변수를 사용할 수 있다.",
            "트랜잭션 제어(COMMIT, ROLLBACK)가 가능하다."
        ],
        "answer": "데이터베이스의 특정 이벤트(INSERT 등) 발생 시 자동으로 실행된다.",
        "hint": "방아쇠처럼 자동으로 발사됩니다.",
        "explanation": "트리거는 테이블에 대한 이벤트(삽입, 수정, 삭제)가 발생할 때 DBMS에 의해 자동으로 실행되는 절차형 SQL입니다. TCL 사용은 제한됩니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '차수(Degree)'와 '카디널리티(Cardinality)'의 의미가 바르게 짝지어진 것은?",
        "options": [
            "속성의 수 - 튜플의 수",
            "튜플의 수 - 속성의 수",
            "릴레이션의 수 - 속성의 수",
            "속성의 수 - 관계의 수"
        ],
        "answer": "속성의 수 - 튜플의 수",
        "hint": "디그리는 열, 카디널리티는 행의 개수입니다.",
        "explanation": "차수(Degree)는 릴레이션을 구성하는 속성(열)의 수이고, 카디널리티(Cardinality)는 튜플(행)의 수입니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 설계 단계 중 '트랜잭션 인터페이스 설계'를 수행하는 단계는?",
        "options": [
            "요구 조건 분석",
            "개념적 설계",
            "논리적 설계",
            "물리적 설계"
        ],
        "answer": "논리적 설계",
        "hint": "스키마 설계와 인터페이스 설계가 이루어집니다.",
        "explanation": "논리적 설계 단계에서는 논리적 스키마 설계, 트랜잭션 인터페이스 설계 등이 수행됩니다. (개념적 단계는 트랜잭션 모델링)"
    },
    {
        "level": 3,
        "problem": "SQL에서 뷰(View)를 삭제할 때 사용하는 명령어는?",
        "options": [
            "DELETE VIEW",
            "DROP VIEW",
            "ERASE VIEW",
            "KILL VIEW"
        ],
        "answer": "DROP VIEW",
        "hint": "DDL 명령어입니다.",
        "explanation": "객체의 구조를 삭제하는 것이므로 DDL인 DROP 명령어를 사용합니다."
    },
    {
        "level": 3,
        "problem": "데이터 마이닝 기법 중, '맥주를 산 사람이 기저귀도 산다'와 같이 항목 간의 종속 관계를 찾아내는 기법은?",
        "options": [
            "연관 분석 (Association Analysis)",
            "분류 (Classification)",
            "군집화 (Clustering)",
            "예측 (Prediction)"
        ],
        "answer": "연관 분석 (Association Analysis)",
        "hint": "장바구니 분석이라고도 합니다.",
        "explanation": "연관 분석은 데이터 안에 존재하는 항목 간의 연관 규칙을 발견하는 기법입니다."
    },
    {
        "level": 3,
        "problem": "스토리지 시스템 중, 서버와 저장장치를 파이버 채널(FC) 스위치로 연결하여 고속 데이터 전송을 지원하는 네트워크 방식은?",
        "options": [
            "DAS (Direct Attached Storage)",
            "NAS (Network Attached Storage)",
            "SAN (Storage Area Network)",
            "Cloud Storage"
        ],
        "answer": "SAN (Storage Area Network)",
        "hint": "별도의 전용 네트워크를 구성합니다.",
        "explanation": "SAN은 서버와 스토리지를 광채널(FC) 등의 전용 네트워크로 연결하여 고속 데이터 처리가 가능한 방식입니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '반정규화(De-normalization)'의 기법이 아닌 것은?",
        "options": [
            "테이블 병합",
            "테이블 분할",
            "중복 컬럼 추가",
            "기본키 제거"
        ],
        "answer": "기본키 제거",
        "hint": "식별자는 유지해야 합니다.",
        "explanation": "반정규화는 성능을 위해 중복을 허용하거나 테이블을 합치고 나누는 것이지만, 데이터 무결성을 위한 기본키 자체를 제거하는 것은 반정규화 기법이 아닙니다."
    },
    {
        "level": 3,
        "problem": "SQL에서 NULL 값과의 연산 결과로 옳은 것은? (예: 10 + NULL)",
        "options": [
            "10",
            "0",
            "NULL",
            "Error"
        ],
        "answer": "NULL",
        "hint": "알 수 없는 값과의 연산은 알 수 없습니다.",
        "explanation": "데이터베이스에서 NULL과의 모든 사칙연산 결과는 NULL입니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 논리적 단위는?",
        "options": [
            "프로시저",
            "트랜잭션",
            "함수",
            "모듈"
        ],
        "answer": "트랜잭션",
        "hint": "원자성을 가지는 작업 단위입니다.",
        "explanation": "트랜잭션(Transaction)은 데이터베이스의 논리적 작업 단위(Logical Unit of Work)입니다."
    },
    {
        "level": 3,
        "problem": "다음 중 후보키가 기본키로 선정되지 못하여 남은 키들을 지칭하는 용어는?",
        "options": [
            "슈퍼키",
            "외래키",
            "대체키(Alternate Key)",
            "복합키"
        ],
        "answer": "대체키(Alternate Key)",
        "hint": "대안이 되는 키입니다.",
        "explanation": "대체키는 후보키 중에서 기본키로 선택되지 않은 나머지 키들을 의미합니다."
    },
    {
        "level": 3,
        "problem": "물리적 데이터베이스 설계 시 고려사항이 아닌 것은?",
        "options": [
            "저장 레코드의 양식 설계",
            "트랜잭션의 상세 설계",
            "파일 조직 방법 결정",
            "개체와 관계 식별"
        ],
        "answer": "개체와 관계 식별",
        "hint": "개체 식별은 개념적 설계 단계입니다.",
        "explanation": "개체와 관계를 식별하고 E-R 다이어그램을 그리는 것은 개념적 설계 단계의 활동입니다."
    },
    {
        "level": 3,
        "problem": "분산 데이터베이스에서 '수평 분할(Horizontal Fragmentation)'의 정의는?",
        "options": [
            "릴레이션을 특정 속성(열) 단위로 쪼개는 것",
            "릴레이션을 특정 튜플(행) 단위로 쪼개는 것",
            "릴레이션을 랜덤하게 쪼개는 것",
            "릴레이션을 복제하는 것"
        ],
        "answer": "릴레이션을 특정 튜플(행) 단위로 쪼개는 것",
        "hint": "가로로 자릅니다.",
        "explanation": "수평 분할은 조건에 맞는 튜플(행)들을 모아 서로 다른 조각으로 나누는 것입니다. (속성 단위 분할은 수직 분할)"
    },
    {
        "level": 3,
        "problem": "SQL에서 인덱스를 생성하는 명령어는?",
        "options": [
            "MAKE INDEX",
            "CREATE INDEX",
            "ADD INDEX",
            "INSERT INDEX"
        ],
        "answer": "CREATE INDEX",
        "hint": "객체 생성은 CREATE입니다.",
        "explanation": "인덱스 생성 구문은 `CREATE INDEX 인덱스명 ON 테이블명(컬럼명)` 입니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 스키마(Schema)의 3계층 중, 사용자나 응용 프로그래머가 접근하는 개인적이고 논리적인 구조를 정의한 것은?",
        "options": [
            "내부 스키마 (Internal Schema)",
            "개념 스키마 (Conceptual Schema)",
            "외부 스키마 (External Schema)",
            "논리 스키마 (Logical Schema)"
        ],
        "answer": "외부 스키마 (External Schema)",
        "hint": "사용자 관점의 스키마입니다.",
        "explanation": "외부 스키마는 사용자나 응용 프로그래머가 각자의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것입니다."
    },
    {
        "level": 3,
        "problem": "관계 대수에서 두 릴레이션 R과 S가 있을 때, R의 튜플과 S의 튜플을 모두 합쳐서 새로운 릴레이션을 만드는 연산은? (중복 튜플은 제거됨)",
        "options": [
            "교집합 (Intersection)",
            "합집합 (Union)",
            "차집합 (Difference)",
            "카티션 프로덕트 (Cartesian Product)"
        ],
        "answer": "합집합 (Union)",
        "hint": "∪ 기호를 사용합니다.",
        "explanation": "합집합(Union)은 두 릴레이션에 존재하는 튜플의 합을 구하는 연산으로, 결과 릴레이션에서 중복된 튜플은 제거됩니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 설계 단계 중, 목표 DBMS에 맞는 테이블 명세서, 인덱스 정의서 등을 작성하는 단계는?",
        "options": [
            "요구사항 분석",
            "개념적 설계",
            "논리적 설계",
            "물리적 설계"
        ],
        "answer": "물리적 설계",
        "hint": "저장 구조와 관련이 있습니다.",
        "explanation": "물리적 설계 단계에서는 저장 레코드 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계 등을 수행합니다."
    },
    {
        "level": 3,
        "problem": "SQL에서 'DCL(Data Control Language)'에 해당하지 않는 명령어는?",
        "options": [
            "GRANT",
            "REVOKE",
            "COMMIT",
            "DROP"
        ],
        "answer": "DROP",
        "hint": "DROP은 구조를 삭제합니다.",
        "explanation": "DROP은 데이터베이스 객체를 삭제하는 DDL(Data Definition Language)입니다. GRANT, REVOKE, COMMIT, ROLLBACK 등은 제어어(DCL) 또는 트랜잭션 제어어(TCL)로 분류됩니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '암호화(Encryption)'의 평문을 암호문으로 바꾸는 과정을 수행하는 것은?",
        "options": [
            "복호화 (Decryption)",
            "인코딩 (Encoding)",
            "암호화 (Encryption)",
            "해싱 (Hashing)"
        ],
        "answer": "암호화 (Encryption)",
        "hint": "용어의 정의를 묻는 문제입니다.",
        "explanation": "평문을 암호문으로 변환하는 것을 암호화(Encryption)라고 하며, 반대 과정을 복호화(Decryption)라고 합니다."
    },
    {
        "level": 3,
        "problem": "관계형 데이터 모델에서 릴레이션(Relation)의 특징으로 틀린 것은?",
        "options": [
            "튜플의 유일성",
            "튜플의 무순서성",
            "속성의 무순서성",
            "속성 값의 분해 가능성"
        ],
        "answer": "속성 값의 분해 가능성",
        "hint": "속성 값은 원자값이어야 합니다.",
        "explanation": "릴레이션의 모든 속성 값은 더 이상 분해할 수 없는 원자값(Atomic Value)이어야 합니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스의 무결성 규정(Integrity Rule)을 확인하거나 위반 시 처리하는 검증 시점이 아닌 것은?",
        "options": [
            "트랜잭션이 수행되는 도중",
            "트랜잭션이 완료(Commit)될 때",
            "데이터가 조회(Select)될 때",
            "데이터가 삽입(Insert)될 때"
        ],
        "answer": "데이터가 조회(Select)될 때",
        "hint": "조회는 데이터를 변경하지 않습니다.",
        "explanation": "무결성 검증은 데이터의 상태가 변하는 삽입, 삭제, 갱신 시점이나 트랜잭션 완료 시점에 수행됩니다. 단순 조회 시에는 무결성이 깨질 위험이 없습니다."
    },
    {
        "level": 3,
        "problem": "분산 데이터베이스의 장점으로 거리가 먼 것은?",
        "options": [
            "지역 자치성 보장",
            "시스템의 신뢰성 및 가용성 증대",
            "효율적인 데이터 처리 및 빠른 응답 속도",
            "소프트웨어 개발 비용 감소"
        ],
        "answer": "소프트웨어 개발 비용 감소",
        "hint": "분산 시스템은 복잡합니다.",
        "explanation": "분산 데이터베이스는 시스템 구축 및 관리가 복잡하여 소프트웨어 개발 비용과 처리 비용이 증가할 수 있습니다."
    },
    {
        "level": 3,
        "problem": "다음 SQL 문에서 빈칸에 들어갈 알맞은 절은? 'SELECT * FROM 사원 ___ 이름 LIKE '김%';'",
        "options": [
            "WHERE",
            "HAVING",
            "GROUP BY",
            "ORDER BY"
        ],
        "answer": "WHERE",
        "hint": "조건을 지정하는 절입니다.",
        "explanation": "행에 대한 조건을 지정할 때는 WHERE 절을 사용합니다."
    },
    {
        "level": 3,
        "problem": "트랜잭션의 상태 중, 트랜잭션의 마지막 연산이 실행된 직후의 상태로, 아직 커밋되지 않은 상태는?",
        "options": [
            "활동 (Active)",
            "부분 완료 (Partially Committed)",
            "완료 (Committed)",
            "실패 (Failed)"
        ],
        "answer": "부분 완료 (Partially Committed)",
        "hint": "모든 연산은 끝났으나 확정 전입니다.",
        "explanation": "부분 완료 상태는 트랜잭션의 마지막 연산까지 실행되었지만, Commit 연산이 실행되기 전의 상태입니다."
    },
    {
        "level": 3,
        "problem": "E-R 다이어그램을 관계형 테이블로 변환할 때, 다대다(N:M) 관계는 어떻게 처리하는가?",
        "options": [
            "한쪽 테이블에 외래키를 추가한다.",
            "별도의 교차 테이블(Mapping Table)을 생성한다.",
            "두 테이블을 하나로 합친다.",
            "변환할 수 없다."
        ],
        "answer": "별도의 교차 테이블(Mapping Table)을 생성한다.",
        "hint": "중간 다리가 필요합니다.",
        "explanation": "다대다 관계는 직접 표현할 수 없으므로, 두 개체의 기본키를 포함하는 별도의 교차 테이블(Relation Table)을 만들어 1:N, M:1 관계로 분해해야 합니다."
    },
    {
        "level": 3,
        "problem": "정규화 과정에서 제 1정규형(1NF)의 조건은?",
        "options": [
            "모든 속성의 도메인이 원자값이어야 한다.",
            "부분 함수 종속을 제거해야 한다.",
            "이행 함수 종속을 제거해야 한다.",
            "결정자가 후보키여야 한다."
        ],
        "answer": "모든 속성의 도메인이 원자값이어야 한다.",
        "hint": "반복 그룹이 없어야 합니다.",
        "explanation": "1NF는 릴레이션에 속한 모든 속성의 도메인이 원자값(Atomic Value)으로만 구성되어야 한다는 조건입니다."
    },
    {
        "level": 3,
        "problem": "다음 중 클러스터드 인덱스(Clustered Index)의 특징이 아닌 것은?",
        "options": [
            "테이블당 하나만 생성할 수 있다.",
            "데이터 자체가 정렬되어 저장된다.",
            "인덱스의 리프 노드가 곧 데이터 페이지다.",
            "보조 인덱스보다 검색 속도가 느리다."
        ],
        "answer": "보조 인덱스보다 검색 속도가 느리다.",
        "hint": "책의 페이지 순서와 목차 순서가 일치하는 경우입니다.",
        "explanation": "클러스터드 인덱스는 물리적으로 데이터가 정렬되어 있으므로 범위 검색 등에서 보조 인덱스(Non-Clustered)보다 훨씬 빠른 성능을 보입니다."
    },
    {
        "level": 3,
        "problem": "데이터 모델링에서 'CRUD 매트릭스'를 작성하는 주된 목적은?",
        "options": [
            "데이터 타입 정의",
            "프로세스와 데이터 간의 상관관계 분석",
            "테이블 정규화",
            "인덱스 설계"
        ],
        "answer": "프로세스와 데이터 간의 상관관계 분석",
        "hint": "Create, Read, Update, Delete의 약자입니다.",
        "explanation": "CRUD 매트릭스는 업무 프로세스(행)와 데이터 엔티티(열) 간의 상관관계를 분석하여 누락된 프로세스나 엔티티를 검증하는 도구입니다."
    },
    {
        "level": 3,
        "problem": "병행 제어 기법 중 '타임스탬프 순서(Timestamp Ordering)' 기법에 대한 설명으로 옳은 것은?",
        "options": [
            "직렬 가능성을 보장하지 않는다.",
            "교착 상태(Deadlock)가 발생하지 않는다.",
            "로킹(Locking)을 사용한다.",
            "트랜잭션 간의 순서를 미리 정하지 않는다."
        ],
        "answer": "교착 상태(Deadlock)가 발생하지 않는다.",
        "hint": "시간표대로만 움직이므로 서로 기다릴 일이 없습니다.",
        "explanation": "타임스탬프 기법은 트랜잭션 시작 시간에 따라 순서를 정하여 실행하므로, 대기 관계가 형성되지 않아 교착 상태가 발생하지 않습니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '데이터 마트(Data Mart)'의 정의로 가장 적절한 것은?",
        "options": [
            "전사적인 통합 데이터 저장소",
            "특정 조직이나 부서의 목적에 맞춰 구축된 소규모 데이터 웨어하우스",
            "비정형 데이터 저장소",
            "실시간 트랜잭션 처리 시스템"
        ],
        "answer": "특정 조직이나 부서의 목적에 맞춰 구축된 소규모 데이터 웨어하우스",
        "hint": "웨어하우스보다 작은 단위입니다.",
        "explanation": "데이터 마트는 데이터 웨어하우스로부터 특정 주제나 부서 중심으로 데이터를 추출하여 구성한 소규모 데이터 저장소입니다."
    },
    {
        "level": 3,
        "problem": "SQL에서 테이블의 구조를 변경할 때 사용하는 명령어는?",
        "options": [
            "CHANGE TABLE",
            "MODIFY TABLE",
            "ALTER TABLE",
            "UPDATE TABLE"
        ],
        "answer": "ALTER TABLE",
        "hint": "DDL 명령어입니다.",
        "explanation": "테이블의 컬럼 추가, 삭제, 타입 변경 등 구조 변경에는 `ALTER TABLE` 명령어를 사용합니다."
    },
    {
        "level": 3,
        "problem": "RAID(Redundant Array of Independent Disks) 레벨 중, 미러링(Mirroring) 방식을 사용하여 최고의 신뢰성을 제공하지만 저장 공간 효율이 50%인 것은?",
        "options": [
            "RAID 0",
            "RAID 1",
            "RAID 5",
            "RAID 6"
        ],
        "answer": "RAID 1",
        "hint": "똑같이 복제합니다.",
        "explanation": "RAID 1은 데이터를 두 개의 디스크에 동일하게 기록(Mirroring)하여 결함 허용 능력이 뛰어나지만, 용량 효율은 절반으로 떨어집니다."
    },
    {
        "level": 3,
        "problem": "접근 통제(Access Control) 모델 중, 사용자의 신분에 따라 접근 권한을 부여하는 방식은?",
        "options": [
            "DAC (Discretionary Access Control)",
            "MAC (Mandatory Access Control)",
            "RBAC (Role Based Access Control)",
            "ABAC (Attribute Based Access Control)"
        ],
        "answer": "DAC (Discretionary Access Control)",
        "hint": "임의 접근 통제라고 합니다.",
        "explanation": "DAC(임의 접근 통제)는 데이터 소유자가 사용자의 신원(Identity)에 따라 접근 권한을 임의로 부여하거나 취소할 수 있는 방식입니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 튜닝 시 '반정규화(Denormalization)'를 수행하는 가장 큰 이유는?",
        "options": [
            "데이터 무결성 강화",
            "저장 공간 절약",
            "조인 연산 감소를 통한 조회 성능 향상",
            "데이터 모델의 단순화"
        ],
        "answer": "조인 연산 감소를 통한 조회 성능 향상",
        "hint": "정규화의 반대 방향입니다.",
        "explanation": "반정규화는 정규화된 엔티티를 다시 합치거나 중복 속성을 추가하여 조인 횟수를 줄이고 조회를 빠르게 하기 위해 수행합니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '이상 현상(Anomaly)'의 종류가 아닌 것은?",
        "options": [
            "삽입 이상",
            "삭제 이상",
            "갱신 이상",
            "참조 이상"
        ],
        "answer": "참조 이상",
        "hint": "세 가지 이상 현상만 존재합니다.",
        "explanation": "이상 현상은 삽입 이상(Insertion Anomaly), 삭제 이상(Deletion Anomaly), 갱신 이상(Update Anomaly) 세 가지입니다."
    },
    {
        "level": 3,
        "problem": "분산 데이터베이스의 투명성 중 '데이터가 어떻게 분할되어 있는지 알 필요가 없다'는 성질은?",
        "options": [
            "위치 투명성",
            "분할 투명성 (Fragmentation Transparency)",
            "지역사상 투명성",
            "병행 투명성"
        ],
        "answer": "분할 투명성 (Fragmentation Transparency)",
        "hint": "단편화 투명성이라고도 합니다.",
        "explanation": "분할 투명성은 하나의 릴레이션이 여러 단편으로 나뉘어 저장되어 있어도 사용자는 이를 인식할 필요 없이 전역 스키마를 통해 사용할 수 있음을 의미합니다."
    },
    {
        "level": 3,
        "problem": "SQL 집계 함수 중 조건을 만족하는 행의 개수를 구하는 함수는?",
        "options": [
            "SUM",
            "AVG",
            "COUNT",
            "MAX"
        ],
        "answer": "COUNT",
        "hint": "숫자를 세다.",
        "explanation": "COUNT 함수는 조회된 행의 개수를 반환합니다."
    },
    {
        "level": 3,
        "problem": "관계 대수에서 기호 'σ(Sigma)'가 의미하는 연산은?",
        "options": [
            "Selection",
            "Projection",
            "Join",
            "Division"
        ],
        "answer": "Selection",
        "hint": "조건에 맞는 행(Horizontal)을 선택합니다.",
        "explanation": "σ(Sigma)는 Selection 연산을 의미하며, 조건에 만족하는 튜플(행)들을 추출합니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 회복 기법 중 '체크포인트(Checkpoint)' 기법의 목적은?",
        "options": [
            "로그 전체를 검색하는 시간을 줄이기 위해",
            "디스크 용량을 절약하기 위해",
            "트랜잭션 처리 속도를 높이기 위해",
            "데이터 중복을 방지하기 위해"
        ],
        "answer": "로그 전체를 검색하는 시간을 줄이기 위해",
        "hint": "검사점 이후의 로그만 보면 됩니다.",
        "explanation": "체크포인트 기법은 검사점을 두어 장애 발생 시 로그 전체가 아닌 검사점 이후의 로그만을 이용하여 회복함으로써 회복 시간을 단축시킵니다."
    },
    {
        "level": 3,
        "problem": "다음 중 'OLAP(Online Analytical Processing)'의 연산이 아닌 것은?",
        "options": [
            "Roll-up",
            "Drill-down",
            "Slicing & Dicing",
            "Normalization"
        ],
        "answer": "Normalization",
        "hint": "정규화는 DB 설계 과정입니다.",
        "explanation": "OLAP의 주요 연산은 Roll-up, Drill-down, Slicing, Dicing, Pivoting입니다. 정규화(Normalization)는 데이터베이스 설계 기법입니다."
    },
    {
        "level": 3,
        "problem": "데이터 보안 위협 중, 네트워크상의 데이터를 도청하거나 가로채는 행위는?",
        "options": [
            "스니핑 (Sniffing)",
            "스푸핑 (Spoofing)",
            "피싱 (Phishing)",
            "디도스 (DDoS)"
        ],
        "answer": "스니핑 (Sniffing)",
        "hint": "냄새를 맡다는 뜻입니다.",
        "explanation": "스니핑은 네트워크 통신망을 흐르는 패킷을 몰래 엿보거나 가로채는 해킹 기법입니다."
    },
    {
        "level": 3,
        "problem": "논리적 데이터 모델링에서 '속성(Attribute)'에 대한 설명으로 틀린 것은?",
        "options": [
            "엔티티가 가지는 성격이나 특성을 나타낸다.",
            "더 이상 분리되지 않는 최소의 데이터 단위이다.",
            "반드시 하나의 값을 가져야 한다.",
            "다른 엔티티와의 관계를 나타낸다."
        ],
        "answer": "다른 엔티티와의 관계를 나타낸다.",
        "hint": "관계는 'Relationship'입니다.",
        "explanation": "속성은 엔티티의 고유한 성질을 나타내며, 엔티티 간의 연관성은 '관계(Relationship)'로 표현합니다. (단, 외래키 속성은 관계를 구현하는 수단이긴 함)"
    },
    {
        "level": 3,
        "problem": "SQL 뷰(View) 생성 시 사용하는 옵션 중, 뷰 정의 조건에 맞지 않는 데이터의 삽입/수정을 방지하는 옵션은?",
        "options": [
            "WITH READ ONLY",
            "WITH CHECK OPTION",
            "CASCADE",
            "RESTRICT"
        ],
        "answer": "WITH CHECK OPTION",
        "hint": "조건을 체크합니다.",
        "explanation": "WITH CHECK OPTION은 뷰를 생성할 때 정의한 조건식(WHERE 절 등)을 만족하는 데이터만 입력하거나 수정할 수 있도록 제약합니다."
    },
    {
        "level": 3,
        "problem": "다음 설명에 해당하는 정규형은? '모든 결정자가 후보키이다.'",
        "options": [
            "2NF",
            "3NF",
            "BCNF",
            "4NF"
        ],
        "answer": "BCNF",
        "hint": "강한 제 3정규형이라고도 합니다.",
        "explanation": "BCNF(Boyce-Codd Normal Form)는 릴레이션의 모든 결정자가 후보키(Candidate Key)가 되도록 제한한 정규형입니다."
    },
    {
        "level": 3,
        "problem": "관계형 데이터베이스에서 'NULL' 값의 의미로 가장 적절한 것은?",
        "options": [
            "공백 문자",
            "숫자 0",
            "아직 알려지지 않았거나 모르는 값",
            "가장 작은 값"
        ],
        "answer": "아직 알려지지 않았거나 모르는 값",
        "hint": "부재하는 정보입니다.",
        "explanation": "NULL은 공백이나 0과는 다르며, '정보의 부재', '아직 정해지지 않음', '알 수 없음'을 의미합니다."
    },
    {
        "level": 3,
        "problem": "분산 데이터베이스 설계 시 고려사항이 아닌 것은?",
        "options": [
            "단편화 (Fragmentation)",
            "할당 (Allocation)",
            "복제 (Replication)",
            "캡슐화 (Encapsulation)"
        ],
        "answer": "캡슐화 (Encapsulation)",
        "hint": "캡슐화는 객체지향의 특징입니다.",
        "explanation": "분산 DB 설계의 핵심 요소는 분할(단편화), 할당(위치 선정), 복제입니다. 캡슐화는 객체지향 프로그래밍의 개념입니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '빅데이터(Big Data)' 수집/저장 기술과 거리가 먼 것은?",
        "options": [
            "Hadoop",
            "NoSQL",
            "MapReduce",
            "SMTP"
        ],
        "answer": "SMTP",
        "hint": "이메일 프로토콜입니다.",
        "explanation": "Hadoop, NoSQL, MapReduce는 빅데이터 처리를 위한 핵심 기술인 반면, SMTP는 이메일 전송 프로토콜입니다."
    },
    {
        "level": 3,
        "problem": "릴레이션 스키마가 R(A, B, C, D)이고 함수 종속 A -> B, B -> C가 성립할 때, 이 릴레이션에 존재하는 종속성은?",
        "options": [
            "부분 함수 종속",
            "이행적 함수 종속",
            "다치 종속",
            "조인 종속"
        ],
        "answer": "이행적 함수 종속",
        "hint": "A를 알면 B를 알고, B를 알면 C를 아니, 결국 A를 알면 C를 알게 됩니다.",
        "explanation": "A -> B이고 B -> C일 때, A -> C가 성립하는 관계를 이행적 함수 종속(Transitive Functional Dependency)이라고 합니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 보안 모델 중, 주체와 객체의 보안 등급을 비교하여 접근을 통제하는 모델은?",
        "options": [
            "DAC",
            "MAC (Mandatory Access Control)",
            "RBAC",
            "Public Key"
        ],
        "answer": "MAC (Mandatory Access Control)",
        "hint": "강제적 접근 통제입니다. 군대식 보안 등급(1급비밀 등)을 생각하세요.",
        "explanation": "MAC(강제 접근 통제)는 사용자(주체)의 등급과 자원(객체)의 보안 등급을 비교하여 접근 권한을 부여하는 방식입니다. (예: BLP 모델)"
    },
    {
        "level": 3,
        "problem": "다음 중 '저장 프로시저(Stored Procedure)'의 장점이 아닌 것은?",
        "options": [
            "SQL 실행 성능 향상",
            "네트워크 트래픽 감소",
            "보안성 향상",
            "DB 서버의 부하 감소"
        ],
        "answer": "DB 서버의 부하 감소",
        "hint": "서버가 할 일이 많아집니다.",
        "explanation": "저장 프로시저는 DB 서버 내에서 컴파일되고 실행되므로 클라이언트의 부담은 줄지만, 복잡한 로직이 많아지면 DB 서버의 CPU/메모리 부하가 증가할 수 있습니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 로그(Log) 파일의 주된 용도는?",
        "options": [
            "데이터 검색 속도 향상",
            "데이터베이스 회복(Recovery)",
            "사용자 인증",
            "데이터 압축"
        ],
        "answer": "데이터베이스 회복(Recovery)",
        "hint": "역사를 기록해 두어야 되돌릴 수 있습니다.",
        "explanation": "로그 파일은 트랜잭션의 수행 내역을 기록하여 장애 발생 시 Redo/Undo를 통해 데이터베이스를 복구하는 데 사용됩니다."
    },
    {
        "level": 3,
        "problem": "SQL에서 중복된 행을 제거하고 조회하기 위해 사용하는 키워드는?",
        "options": [
            "UNIQUE",
            "DISTINCT",
            "DIFFERENT",
            "ONLY"
        ],
        "answer": "DISTINCT",
        "hint": "SELECT 바로 뒤에 옵니다.",
        "explanation": "`SELECT DISTINCT 컬럼명...` 형식으로 사용하여 중복된 결과 행을 제거합니다."
    },
    {
        "level": 3,
        "problem": "시스템 카탈로그(System Catalog)에 저장되는 정보를 무엇이라 하는가?",
        "options": [
            "메타 데이터 (Meta-Data)",
            "유저 데이터 (User Data)",
            "로그 데이터 (Log Data)",
            "인덱스 데이터 (Index Data)"
        ],
        "answer": "메타 데이터 (Meta-Data)",
        "hint": "데이터에 대한 데이터입니다.",
        "explanation": "시스템 카탈로그는 테이블, 인덱스, 뷰 등 데이터베이스 객체들에 대한 정의 정보, 즉 '데이터에 대한 데이터(Meta-Data)'를 저장합니다."
    },
    {
        "level": 3,
        "problem": "E-R 모델의 관계(Relationship) 표기법 중, 관계에 참여하는 엔티티의 최소/최대 참여 수를 나타내는 것은?",
        "options": [
            "차수 (Degree)",
            "카디널리티 (Cardinality)",
            "식별자 (Identifier)",
            "도메인 (Domain)"
        ],
        "answer": "카디널리티 (Cardinality)",
        "hint": "1:1, 1:N 등을 말합니다.",
        "explanation": "관계형 데이터베이스 이론에서 튜플 수를 카디널리티라고도 하지만, E-R 모델 관계 표기에서는 엔티티 간의 대응되는 수(1:1, 1:N 등)를 카디널리티라고 합니다."
    },
    {
        "level": 3,
        "problem": "다음 중 DML(데이터 조작어)이 아닌 것은?",
        "options": [
            "SELECT",
            "INSERT",
            "UPDATE",
            "TRUNCATE"
        ],
        "answer": "TRUNCATE",
        "hint": "TRUNCATE는 구조는 남기지만 DDL로 분류됩니다.",
        "explanation": "SELECT, INSERT, UPDATE, DELETE는 DML입니다. TRUNCATE는 테이블의 모든 데이터를 삭제하며 공간을 해제하고 자동 커밋되므로 DDL(데이터 정의어)로 분류됩니다."
    },
    {
        "level": 3,
        "problem": "데이터베이스 설계에서 '식별자(Identifier)' 분류 중, 엔티티 내에서 스스로 생성되는 식별자는?",
        "options": [
            "내부 식별자",
            "외부 식별자",
            "단일 식별자",
            "복합 식별자"
        ],
        "answer": "내부 식별자",
        "hint": "다른 엔티티에서 빌려오지 않은 것입니다.",
        "explanation": "내부 식별자는 엔티티 내부에서 스스로 만들어지는 식별자이며, 외부 식별자는 다른 엔티티와의 관계를 통해 받아오는 식별자(외래키)입니다."
    },
    {
        "level": 3,
        "problem": "로킹(Locking) 단위가 작을수록 나타나는 현상으로 옳은 것은?",
        "options": [
            "로킹 오버헤드가 감소한다.",
            "데이터베이스 공유도가 증가한다.",
            "병행성 수준이 낮아진다.",
            "제어 기법이 단순해진다."
        ],
        "answer": "데이터베이스 공유도가 증가한다.",
        "hint": "세밀하게 잠그면 다른 사람이 건드릴 수 있는 부분이 많아집니다.",
        "explanation": "로킹 단위가 작으면(예: 행 단위) 락 관리가 복잡해지고 오버헤드는 증가하지만, 동시에 접근할 수 있는 데이터 범위가 늘어나 공유도(병행성)가 증가합니다."
    },
    {
        "level": 3,
        "problem": "관계 대수 연산 중 '나눗셈(Division)' 연산의 기호는?",
        "options": [
            "÷",
            "×",
            "−",
            "∩"
        ],
        "answer": "÷",
        "hint": "나누기 기호입니다.",
        "explanation": "Division 연산은 R ÷ S로 표기하며, S의 모든 튜플과 연관된 R의 튜플을 구합니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '데이터 무결성'을 위협하는 요인이 아닌 것은?",
        "options": [
            "잘못된 데이터 입력",
            "하드웨어의 고장",
            "병행 수행 시 제어 부재",
            "데이터의 중복 저장 제거"
        ],
        "answer": "데이터의 중복 저장 제거",
        "hint": "중복 제거는 무결성 유지에 도움이 됩니다.",
        "explanation": "데이터 중복을 최소화(정규화)하는 것은 일관성을 유지하고 무결성을 지키는 데 도움이 되는 활동입니다."
    },
    {
        "level": 3,
        "problem": "SQL에서 'ORDER BY' 절을 생략했을 때의 기본 정렬 순서는?",
        "options": [
            "오름차순 (ASC)",
            "내림차순 (DESC)",
            "입력 순서",
            "랜덤"
        ],
        "answer": "오름차순 (ASC)",
        "hint": "1, 2, 3... 순서입니다.",
        "explanation": "ORDER BY 절을 명시하지 않거나 ASC 옵션을 주면 오름차순(Ascending)으로 정렬됩니다."
    },
    {
        "level": 3,
        "problem": "개체-관계(E-R) 모델에서 '관계(Relationship)'를 나타내는 다이아몬드(마름모) 도형의 의미는?",
        "options": [
            "개체 타입",
            "속성",
            "개체 간의 연관성",
            "기본키"
        ],
        "answer": "개체 간의 연관성",
        "hint": "엔티티와 엔티티 사이를 이어줍니다.",
        "explanation": "마름모는 개체와 개체 사이의 연관성(Relationship)을 표현합니다."
    },
    {
        "level": 3,
        "problem": "트랜잭션의 4가지 특성(ACID)에 포함되지 않는 것은?",
        "options": [
            "Atomicity",
            "Consistency",
            "Integrity",
            "Durability"
        ],
        "answer": "Integrity",
        "hint": "I는 Isolation(격리성)입니다.",
        "explanation": "ACID는 Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(영속성)입니다. Integrity(무결성)는 데이터베이스의 조건이지 트랜잭션 특성 약어에는 포함되지 않습니다."
    },
    {
        "level": 3,
        "problem": "다음 중 '인덱스(Index)'를 생성하기에 부적절한 컬럼은?",
        "options": [
            "WHERE 절에 자주 사용되는 컬럼",
            "JOIN 조건으로 자주 사용되는 컬럼",
            "데이터의 중복도가 높고 종류가 적은 컬럼(예: 성별)",
            "외래키가 설정된 컬럼"
        ],
        "answer": "데이터의 중복도가 높고 종류가 적은 컬럼(예: 성별)",
        "hint": "변별력(Selectivity)이 낮습니다.",
        "explanation": "성별(남/여)처럼 카디널리티가 낮고 중복도가 높은 컬럼은 인덱스를 사용해도 검색 범위를 크게 줄이지 못해 효율이 떨어집니다(Full Scan이 더 빠를 수 있음)."
    },
    {
        "level": 3,
        "problem": "데이터베이스 '스토리지(Storage)' 구성 방식 중, 네트워크에 직접 연결되어 파일 수준의 공유를 제공하는 방식은?",
        "options": [
            "DAS",
            "NAS",
            "SAN",
            "RAID"
        ],
        "answer": "NAS",
        "hint": "Network Attached Storage입니다.",
        "explanation": "NAS(Network Attached Storage)는 이더넷 등 네트워크에 직접 연결되어 파일 서버처럼 동작하며 파일 단위 공유를 제공합니다."
    },
    {
        "level": 3,
        "problem": "순차 파일(Sequential File)에 대한 설명으로 옳은 것은?",
        "options": [
            "레코드를 키 값 순서대로 정렬하여 기록한다.",
            "임의 접근(Random Access)이 매우 빠르다.",
            "데이터 추가/삭제가 매우 용이하다.",
            "해싱 함수를 사용한다."
        ],
        "answer": "레코드를 키 값 순서대로 정렬하여 기록한다.",
        "hint": "테이프 같은 매체를 생각해보세요.",
        "explanation": "순차 파일은 데이터를 논리적인 순서(키 값 순 등)에 따라 물리적으로 연속되게 저장합니다. 검색 효율은 좋으나 삽입/삭제 시 파일 재구성이 필요하여 비효율적입니다."
    },
    {
        "level": 4,
        "problem": "C언어에서 다음 코드의 실행 결과는? \nint a[3] = {10, 20, 30}; \nint *p = a; \nprintf(\"%d\", *(p+1) + *p + 1);",
        "options": [
            "31",
            "41",
            "21",
            "11"
        ],
        "answer": "31",
        "hint": "*(p+1)은 a[1], *p는 a[0]입니다.",
        "explanation": "*(p+1)은 20, *p는 10입니다. 따라서 20 + 10 + 1 = 31이 출력됩니다."
    },
    {
        "level": 4,
        "problem": "Java에서 'Overloading(오버로딩)'에 대한 설명으로 옳은 것은?",
        "options": [
            "메소드 이름과 매개변수 타입이 모두 같아야 한다.",
            "리턴 타입만 다르면 오버로딩이 성립한다.",
            "같은 클래스 내에서 메소드 이름은 같지만 매개변수의 개수나 타입이 달라야 한다.",
            "상속 관계에서 부모 메소드를 재정의하는 것이다."
        ],
        "answer": "같은 클래스 내에서 메소드 이름은 같지만 매개변수의 개수나 타입이 달라야 한다.",
        "hint": "중복 정의라고도 합니다.",
        "explanation": "오버로딩은 같은 이름의 메소드를 매개변수(파라미터)의 구성만 다르게 하여 여러 개 정의하는 것입니다."
    },
    {
        "level": 4,
        "problem": "Python의 슬라이싱 결과로 옳은 것은? \na = [1, 2, 3, 4, 5] \nprint(a[::-1])",
        "options": [
            "[1, 2, 3, 4, 5]",
            "[5, 4, 3, 2, 1]",
            "[5]",
            "Error"
        ],
        "answer": "[5, 4, 3, 2, 1]",
        "hint": "Step 값이 -1이면 역순입니다.",
        "explanation": "[::-1]은 리스트 전체를 역순으로 슬라이싱하라는 의미입니다."
    },
    {
        "level": 4,
        "problem": "운영체제의 가상기억장치 페이지 교체 알고리즘 중, '최근에 가장 오랫동안 사용하지 않은 페이지'를 교체하는 기법은?",
        "options": [
            "FIFO",
            "LRU (Least Recently Used)",
            "LFU (Least Frequently Used)",
            "NUR (Not Used Recently)"
        ],
        "answer": "LRU (Least Recently Used)",
        "hint": "시간적으로 가장 멀리 떨어진 것을 찾습니다.",
        "explanation": "LRU는 현시점에서 가장 오랫동안 사용되지 않은 페이지를 찾아 교체하는 기법입니다."
    },
    {
        "level": 4,
        "problem": "IPv4 주소 체계에서 C클래스의 기본 서브넷 마스크(Default Subnet Mask)는?",
        "options": [
            "255.0.0.0",
            "255.255.0.0",
            "255.255.255.0",
            "255.255.255.255"
        ],
        "answer": "255.255.255.0",
        "hint": "C클래스는 네트워크 부분이 24비트입니다.",
        "explanation": "C클래스는 앞의 3옥텟(24비트)을 네트워크 주소로 사용하므로 서브넷 마스크는 255.255.255.0입니다."
    },
    {
        "level": 4,
        "problem": "C언어에서 구조체(Structure) 멤버에 접근하기 위해 포인터 변수를 사용할 때 쓰는 연산자는?",
        "options": [
            ".",
            "->",
            "::",
            "&"
        ],
        "answer": "->",
        "hint": "화살표 연산자라고 합니다.",
        "explanation": "구조체 변수는 점(.)으로 접근하지만, 구조체 포인터는 화살표(->) 연산자를 사용하여 멤버에 접근합니다."
    },
    {
        "level": 4,
        "problem": "OSI 7계층 중 '데이터 링크 계층(Data Link Layer)'의 주요 장비는?",
        "options": [
            "Router",
            "Bridge, Switch",
            "Repeater",
            "Gateway"
        ],
        "answer": "Bridge, Switch",
        "hint": "MAC 주소를 기반으로 통신합니다.",
        "explanation": "브리지와 L2 스위치는 데이터 링크 계층 장비입니다. 라우터는 네트워크 계층, 리피터는 물리 계층 장비입니다."
    },
    {
        "level": 4,
        "problem": "UNIX/Linux 명령어 중 파일의 권한(Permission)을 변경하는 명령어는?",
        "options": [
            "chown",
            "chmod",
            "cat",
            "umask"
        ],
        "answer": "chmod",
        "hint": "Change Mode의 약자입니다.",
        "explanation": "chmod(change mode)는 파일이나 디렉토리의 접근 권한을 변경하는 명령어입니다. (chown은 소유자 변경)"
    },
    {
        "level": 4,
        "problem": "프로세스 스케줄링 알고리즘 중, 현재 실행 중인 프로세스의 남은 시간보다 더 짧은 실행 시간을 가진 프로세스가 도착하면 CPU를 뺏는 선점형 기법은?",
        "options": [
            "FCFS",
            "SJF",
            "SRT (Shortest Remaining Time)",
            "HRN"
        ],
        "answer": "SRT (Shortest Remaining Time)",
        "hint": "SJF의 선점형 버전입니다.",
        "explanation": "SRT는 SJF 기법을 선점 형태로 변경한 것으로, 남은 처리 시간이 가장 짧은 프로세스에게 CPU를 할당합니다."
    },
    {
        "level": 4,
        "problem": "TCP/IP 프로토콜 중 인터넷 계층(Internet Layer)에 속하며, IP 패킷의 전송 오류 발생 시 에러 메시지를 전송하는 프로토콜은?",
        "options": [
            "ARP",
            "RARP",
            "ICMP",
            "IGMP"
        ],
        "answer": "ICMP",
        "hint": "Ping 명령어가 이 프로토콜을 사용합니다.",
        "explanation": "ICMP(Internet Control Message Protocol)는 IP 통신 중 발생하는 오류 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리합니다."
    },
    {
        "level": 4,
        "problem": "Java 코드: int[][] arr = new int[2][3]; 일 때, arr.length와 arr[0].length의 값은?",
        "options": [
            "2, 3",
            "3, 2",
            "2, 2",
            "6, 3"
        ],
        "answer": "2, 3",
        "hint": "행의 개수와 열의 개수를 생각하세요.",
        "explanation": "arr.length는 행의 개수(2)를, arr[0].length는 첫 번째 행의 열의 개수(3)를 반환합니다."
    },
    {
        "level": 4,
        "problem": "교착상태(Deadlock)의 발생 필요충분조건 4가지가 아닌 것은?",
        "options": [
            "상호 배제(Mutual Exclusion)",
            "점유 및 대기(Hold and Wait)",
            "비선점(Non-preemption)",
            "회피(Avoidance)"
        ],
        "answer": "회피(Avoidance)",
        "hint": "회피는 교착상태 해결 방법 중 하나입니다.",
        "explanation": "교착상태 4대 조건은 상호 배제, 점유 및 대기, 비선점, 환형 대기(Circular Wait)입니다."
    },
    {
        "level": 4,
        "problem": "Python에서 람다(Lambda) 함수에 대한 설명으로 옳은 것은?",
        "options": [
            "이름이 반드시 있어야 한다.",
            "여러 줄의 코드를 포함할 수 있다.",
            "익명 함수(Anonymous Function)를 생성할 때 사용한다.",
            "return 키워드를 반드시 써야 한다."
        ],
        "answer": "익명 함수(Anonymous Function)를 생성할 때 사용한다.",
        "hint": "한 줄짜리 간단한 함수를 만들 때 씁니다.",
        "explanation": "lambda는 이름 없는 익명 함수를 정의할 때 사용하며, return 문 없이 표현식의 결과가 자동으로 반환됩니다."
    },
    {
        "level": 4,
        "problem": "C언어에서 비트 연산자 중 XOR(배타적 논리합)을 나타내는 기호는?",
        "options": [
            "&",
            "|",
            "^",
            "~"
        ],
        "answer": "^",
        "hint": "서로 다를 때 1이 됩니다.",
        "explanation": "^는 XOR, &는 AND, |는 OR, ~는 NOT 연산자입니다."
    },
    {
        "level": 4,
        "problem": "네트워크 토폴로지(Topology) 중 중앙에 허브(Hub)가 있고 각 단말이 허브에 점 대 점(Point-to-Point)으로 연결된 형태는?",
        "options": [
            "버스형 (Bus)",
            "링형 (Ring)",
            "성형 (Star)",
            "매쉬형 (Mesh)"
        ],
        "answer": "성형 (Star)",
        "hint": "별 모양처럼 중앙에서 뻗어나갑니다.",
        "explanation": "성형(Star) 토폴로지는 중앙 집중식 구조로 관리가 쉽지만 중앙 허브 고장 시 전체가 마비됩니다."
    },
    {
        "level": 4,
        "problem": "Java의 접근 제어자(Access Modifier) 중 '같은 패키지 내에서만' 접근을 허용하는 것은? (단, 명시하지 않았을 때의 기본값)",
        "options": [
            "private",
            "protected",
            "default",
            "public"
        ],
        "answer": "default",
        "hint": "아무것도 적지 않았을 때입니다.",
        "explanation": "접근 제어자를 생략하면 default(package-private)로 설정되어 동일 패키지 내에서만 접근 가능합니다."
    },
    {
        "level": 4,
        "problem": "운영체제에서 '구역성(Locality)'의 종류가 아닌 것은?",
        "options": [
            "시간 구역성 (Temporal Locality)",
            "공간 구역성 (Spatial Locality)",
            "순차 구역성 (Sequential Locality)",
            "네트워크 구역성 (Network Locality)"
        ],
        "answer": "네트워크 구역성 (Network Locality)",
        "hint": "기억장치 참조 특성입니다.",
        "explanation": "구역성은 프로세스가 실행되는 동안 일부 페이지만 집중적으로 참조하는 성질로 시간, 공간, 순차 구역성이 있습니다."
    },
    {
        "level": 4,
        "problem": "C언어 포인터 문제: char *str = \"KOREA\"; printf(\"%c\", *(str+2)); 의 출력 결과는?",
        "options": [
            "K",
            "O",
            "R",
            "E"
        ],
        "answer": "R",
        "hint": "인덱스 0부터 시작하여 2번째(세 번째 글자)입니다.",
        "explanation": "*(str+2)는 str[2]와 같으므로 'K'(0), 'O'(1), 'R'(2) 중 'R'이 출력됩니다."
    },
    {
        "level": 4,
        "problem": "프로토콜의 3요소가 아닌 것은?",
        "options": [
            "구문 (Syntax)",
            "의미 (Semantics)",
            "타이밍 (Timing)",
            "보안 (Security)"
        ],
        "answer": "보안 (Security)",
        "hint": "무엇을, 어떻게, 언제 보낼지 정합니다.",
        "explanation": "프로토콜의 기본 3요소는 구문, 의미, 타이밍(순서)입니다."
    },
    {
        "level": 4,
        "problem": "Java에서 '상속받을 수 없는 마지막 클래스'를 지정할 때 사용하는 키워드는?",
        "options": [
            "static",
            "final",
            "abstract",
            "super"
        ],
        "answer": "final",
        "hint": "변경할 수 없다는 의미입니다.",
        "explanation": "final 키워드가 붙은 클래스는 상속할 수 없으며, 메소드에 붙으면 오버라이딩할 수 없습니다."
    },
    {
        "level": 4,
        "problem": "Python 코드: a = {1, 2, 3} 일 때 type(a)의 결과는?",
        "options": [
            "<class 'list'>",
            "<class 'tuple'>",
            "<class 'dict'>",
            "<class 'set'>"
        ],
        "answer": "<class 'set'>",
        "hint": "중괄호 {}를 사용하지만 키:값 쌍이 아닙니다.",
        "explanation": "중괄호 {} 안에 값만 나열되어 있으면 집합(Set) 자료형입니다."
    },
    {
        "level": 4,
        "problem": "UNIX 시스템에서 커널(Kernel)의 역할이 아닌 것은?",
        "options": [
            "메모리 관리",
            "프로세스 관리",
            "명령어 해석",
            "파일 시스템 관리"
        ],
        "answer": "명령어 해석",
        "hint": "사용자의 명령어를 해석하는 것은 껍데기(Shell)입니다.",
        "explanation": "명령어 해석은 쉘(Shell)의 역할이며, 커널은 하드웨어를 제어하고 자원을 관리하는 핵심부입니다."
    },
    {
        "level": 4,
        "problem": "IP 주소를 물리적 주소(MAC Address)로 변환해 주는 프로토콜은?",
        "options": [
            "ARP",
            "RARP",
            "DNS",
            "DHCP"
        ],
        "answer": "ARP",
        "hint": "Address Resolution Protocol입니다.",
        "explanation": "ARP는 IP 주소를 받아 해당 장비의 MAC 주소를 찾아주는 역할을 합니다. (RARP는 반대)"
    },
    {
        "level": 4,
        "problem": "C언어의 기억 클래스(Storage Class) 중, 블록이 종료되어도 값이 유지되며 프로그램 종료 시 소멸되는 변수는?",
        "options": [
            "auto",
            "register",
            "static",
            "extern"
        ],
        "answer": "static",
        "hint": "정적 변수입니다.",
        "explanation": "static 변수는 선언된 블록 내에서만 접근 가능하지만, 생명 주기는 프로그램 시작부터 종료까지 유지됩니다."
    },
    {
        "level": 4,
        "problem": "스레싱(Thrashing) 현상을 방지하기 위한 방법으로, 각 프로세스가 필요로 하는 페이지들의 집합을 유지해 주는 기법은?",
        "options": [
            "Working Set",
            "Paging",
            "Segmentation",
            "Demand Paging"
        ],
        "answer": "Working Set",
        "hint": "자주 참조하는 페이지들의 집합입니다.",
        "explanation": "워킹 셋(Working Set)은 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합으로, 이를 메모리에 유지하여 페이지 부재(Page Fault)를 줄입니다."
    },
    {
        "level": 4,
        "problem": "TCP 헤더에 포함되지 않는 정보는?",
        "options": [
            "Sequence Number",
            "Source Port",
            "Window Size",
            "Source IP Address"
        ],
        "answer": "Source IP Address",
        "hint": "IP 주소는 IP 헤더에 있습니다.",
        "explanation": "출발지 및 목적지 IP 주소는 IP 패킷 헤더에 포함되며, TCP 헤더에는 포트 번호가 포함됩니다."
    },
    {
        "level": 4,
        "problem": "Java에서 예외 처리를 위해 사용하는 키워드 조합이 아닌 것은?",
        "options": [
            "try - catch",
            "try - finally",
            "throw",
            "try - error"
        ],
        "answer": "try - error",
        "hint": "error라는 키워드는 없습니다.",
        "explanation": "Java의 예외 처리 구문은 try, catch, finally, throw, throws입니다."
    },
    {
        "level": 4,
        "problem": "Python의 리스트 메소드 중, 리스트의 맨 마지막 요소를 제거하고 그 값을 반환하는 것은?",
        "options": [
            "remove()",
            "pop()",
            "del",
            "clear()"
        ],
        "answer": "pop()",
        "hint": "스택의 연산과 이름이 같습니다.",
        "explanation": "pop()은 리스트의 마지막 요소(또는 지정 인덱스)를 꺼내서 반환하고 리스트에서 삭제합니다."
    },
    {
        "level": 4,
        "problem": "운영체제에서 기아(Starvation) 현상을 해결하기 위해, 오랫동안 대기한 프로세스의 우선순위를 높여주는 기법은?",
        "options": [
            "Aging",
            "Banking",
            "Spooling",
            "Context Switching"
        ],
        "answer": "Aging",
        "hint": "나이를 먹을수록 대우해 줍니다.",
        "explanation": "에이징(Aging)은 무한 대기를 방지하기 위해 대기 시간이 길어질수록 우선순위를 점진적으로 높여주는 기법입니다."
    },
    {
        "level": 4,
        "problem": "C언어 문제: int a=5, b=3; printf(\"%d\", a&b); 의 결과는?",
        "options": [
            "1",
            "3",
            "5",
            "7"
        ],
        "answer": "1",
        "hint": "비트 단위 AND 연산입니다. 5(101), 3(011)",
        "explanation": "5는 2진수로 101, 3은 011이므로 AND 연산 시 001(1)이 됩니다."
    },
    {
        "level": 4,
        "problem": "UDP 프로토콜의 특징으로 틀린 것은?",
        "options": [
            "비연결형 서비스이다.",
            "신뢰성보다는 속도가 중요하다.",
            "헤더가 단순하다.",
            "흐름 제어 및 혼잡 제어를 수행한다."
        ],
        "answer": "흐름 제어 및 혼잡 제어를 수행한다.",
        "hint": "이건 TCP의 특징입니다.",
        "explanation": "UDP는 흐름 제어나 혼잡 제어, 오류 정정 등의 기능이 없어 신뢰성은 낮지만 전송 속도가 빠릅니다."
    },
    {
        "level": 4,
        "problem": "Java에서 인터페이스(Interface)의 모든 필드(변수)는 기본적으로 어떤 속성을 갖는가?",
        "options": [
            "private final",
            "public static final",
            "protected",
            "abstract"
        ],
        "answer": "public static final",
        "hint": "상수입니다.",
        "explanation": "인터페이스 내의 변수는 무조건 public static final(상수)로 간주됩니다."
    },
    {
        "level": 4,
        "problem": "Python에서 for i in range(1, 10, 2): 의 실행 결과로 생성되는 숫자는?",
        "options": [
            "1, 2, 3, 4, 5...9",
            "1, 3, 5, 7, 9",
            "2, 4, 6, 8",
            "1, 3, 5, 7"
        ],
        "answer": "1, 3, 5, 7, 9",
        "hint": "1부터 10 미만까지 2씩 증가합니다.",
        "explanation": "range(start, stop, step) 함수는 1, 3, 5, 7, 9를 생성합니다. (10은 포함되지 않음)"
    },
    {
        "level": 4,
        "problem": "HRN(Highest Response-ratio Next) 스케줄링의 우선순위 계산식으로 옳은 것은?",
        "options": [
            "(대기 시간 + 서비스 시간) / 서비스 시간",
            "(대기 시간 + 서비스 시간) / 대기 시간",
            "서비스 시간 / (대기 시간 + 서비스 시간)",
            "대기 시간 / 서비스 시간"
        ],
        "answer": "(대기 시간 + 서비스 시간) / 서비스 시간",
        "hint": "대기 시간이 길수록, 서비스 시간이 짧을수록 우선순위가 높습니다.",
        "explanation": "HRN은 SJF의 단점을 보완하기 위해 대기 시간을 고려하며, 우선순위 = (대기+서비스)/서비스 입니다."
    },
    {
        "level": 4,
        "problem": "패킷 교환 방식(Packet Switching) 중, 통신 전에 미리 경로를 설정하고 해당 경로로만 패킷을 전송하는 방식은?",
        "options": [
            "데이터그램 (Datagram)",
            "가상 회선 (Virtual Circuit)",
            "메시지 교환",
            "회선 교환"
        ],
        "answer": "가상 회선 (Virtual Circuit)",
        "hint": "마치 회선 교환처럼 논리적인 연결을 맺습니다.",
        "explanation": "가상 회선 방식은 논리적인 연결(가상 경로)을 설정한 후 패킷을 순서대로 전송하는 방식입니다. 데이터그램은 경로 설정 없이 독립적으로 전송합니다."
    },
    {
        "level": 4,
        "problem": "C언어: int arr[3][2] = {{1,2},{3,4},{5,6}}; printf(\"%d\", arr[1][0]); 의 결과는?",
        "options": [
            "1",
            "3",
            "4",
            "5"
        ],
        "answer": "3",
        "hint": "0행이 {1,2}, 1행이 {3,4} 입니다.",
        "explanation": "arr[1]은 두 번째 행인 {3, 4}를 가리키며, arr[1][0]은 그 중 첫 번째 요소인 3입니다."
    },
    {
        "level": 4,
        "problem": "쉘(Shell)의 기능에 대한 설명으로 틀린 것은?",
        "options": [
            "사용자와 커널 사이의 인터페이스 역할을 한다.",
            "주기억장치에 상주하여 계속 실행된다.",
            "명령어 해석기이다.",
            "시스템과 사용자 간의 다리 역할을 한다."
        ],
        "answer": "주기억장치에 상주하여 계속 실행된다.",
        "hint": "상주하는 것은 커널(Kernel)입니다.",
        "explanation": "메모리에 상주하는 핵심 부분은 커널입니다. 쉘은 보조기억장치에 있다가 요청 시 메모리에 적재되는 유틸리티 프로그램 성격이 강합니다."
    },
    {
        "level": 4,
        "problem": "Java에서 문자열 내용을 비교할 때 사용하는 메소드는? (주소 비교 아님)",
        "options": [
            "==",
            "=",
            "equals()",
            "compareTo()"
        ],
        "answer": "equals()",
        "hint": "==는 주소값을 비교합니다.",
        "explanation": "객체의 내용(값)을 비교할 때는 equals() 메소드를 사용해야 합니다. == 연산자는 참조 주소를 비교합니다."
    },
    {
        "level": 4,
        "problem": "Python 예외 처리 구문에서 예외 발생 여부와 상관없이 항상 실행되는 블록은?",
        "options": [
            "else",
            "finally",
            "always",
            "catch"
        ],
        "answer": "finally",
        "hint": "Java와 같습니다.",
        "explanation": "finally 블록은 예외 발생 여부와 관계없이 무조건 실행되는 코드 영역입니다."
    },
    {
        "level": 4,
        "problem": "IPv6 주소 체계의 특징이 아닌 것은?",
        "options": [
            "128비트 주소 길이",
            "16진수로 표기",
            "유니캐스트, 멀티캐스트, 브로드캐스트 지원",
            "보안과 품질 보장(QoS) 기능 강화"
        ],
        "answer": "유니캐스트, 멀티캐스트, 브로드캐스트 지원",
        "hint": "IPv6에서는 브로드캐스트가 사라졌습니다.",
        "explanation": "IPv6는 유니캐스트, 멀티캐스트, 애니캐스트(Anycast)를 지원하며, 브로드캐스트는 지원하지 않습니다."
    },
    {
        "level": 4,
        "problem": "C언어: int n=10; int *p = &n; *p = 20; printf(\"%d\", n); 의 결과는?",
        "options": [
            "10",
            "20",
            "주소값",
            "에러"
        ],
        "answer": "20",
        "hint": "포인터를 통해 n의 값을 직접 바꿨습니다.",
        "explanation": "*p는 n이 저장된 메모리 공간을 가리키므로, *p에 20을 대입하면 n의 값도 20으로 변경됩니다."
    },
    {
        "level": 4,
        "problem": "프로세스 상태 전이 중, CPU를 할당받아 실행 중인 프로세스가 할당된 시간이 종료되어 다시 준비(Ready) 상태로 되돌아가는 것은?",
        "options": [
            "Dispatch",
            "Wake Up",
            "Timeout (Timer Run Out)",
            "Spooling"
        ],
        "answer": "Timeout (Timer Run Out)",
        "hint": "시간 할당량 종료입니다.",
        "explanation": "타임 슬라이스가 만료되어 실행 상태에서 준비 상태로 전이되는 것을 Timeout 또는 Timer Run Out이라고 합니다."
    },
    {
        "level": 4,
        "problem": "Java의 Wrapper Class가 아닌 것은?",
        "options": [
            "Integer",
            "Character",
            "Double",
            "String"
        ],
        "answer": "String",
        "hint": "String은 기본 자료형을 감싸는 클래스가 아니라 그 자체로 참조형입니다.",
        "explanation": "Wrapper Class는 기본 자료형(int, char 등)을 객체로 다루기 위한 클래스입니다. String은 원래 클래스입니다."
    },
    {
        "level": 4,
        "problem": "OSI 7계층 중 종단 간(End-to-End) 신뢰성 있는 데이터 전송을 담당하며, 흐름 제어, 오류 제어를 수행하는 계층은?",
        "options": [
            "네트워크 계층",
            "전송 계층 (Transport Layer)",
            "세션 계층",
            "표현 계층"
        ],
        "answer": "전송 계층 (Transport Layer)",
        "hint": "TCP, UDP가 작동하는 계층입니다.",
        "explanation": "전송 계층(L4)은 종단 간 통신을 제어하며 신뢰성 있는 전송을 보장합니다."
    },
    {
        "level": 4,
        "problem": "UNIX에서 현재 프로세스의 상태를 확인하는 명령어는?",
        "options": [
            "ls",
            "ps",
            "pwd",
            "top"
        ],
        "answer": "ps",
        "hint": "Process Status의 약자입니다.",
        "explanation": "ps 명령어는 현재 실행 중인 프로세스의 상태 정보를 출력합니다."
    },
    {
        "level": 4,
        "problem": "Python: a = [1, 2, 3]; b = a; a[0] = 10; print(b[0]) 의 결과는?",
        "options": [
            "1",
            "10",
            "Error",
            "None"
        ],
        "answer": "10",
        "hint": "얕은 복사(Shallow Copy)가 일어납니다.",
        "explanation": "b = a는 같은 객체를 참조하게 되므로, a를 수정하면 b도 영향을 받습니다."
    },
    {
        "level": 4,
        "problem": "C언어 이스케이프 시퀀스 중 '캐리지 리턴(Carriage Return)'을 의미하는 것은?",
        "options": [
            "\\n",
            "\\r",
            "\\t",
            "\\b"
        ],
        "answer": "\\r",
        "hint": "커서를 줄의 맨 앞으로 이동시킵니다.",
        "explanation": "\\r은 커서를 해당 줄의 처음으로 이동시킵니다. (\\n: 줄바꿈, \\t: 탭, \\b: 백스페이스)"
    },
    {
        "level": 4,
        "problem": "페이지 부재(Page Fault) 발생 횟수를 줄이기 위해 프로세스에게 할당하는 페이지 프레임 수를 늘리면, 오히려 부재 횟수가 증가하는 현상은?",
        "options": [
            "Belady's Anomaly (모순)",
            "Deadlock",
            "Thrashing",
            "Fragmentation"
        ],
        "answer": "Belady's Anomaly (모순)",
        "hint": "FIFO 알고리즘에서 발생할 수 있습니다.",
        "explanation": "Belady의 모순은 FIFO 페이지 교체 기법에서 프레임 수를 늘렸음에도 페이지 부재가 더 많이 발생하는 특이 현상입니다."
    },
    {
        "level": 4,
        "problem": "Java에서 추상 클래스(Abstract Class)에 대한 설명으로 틀린 것은?",
        "options": [
            "abstract 키워드를 사용한다.",
            "추상 메소드를 하나 이상 포함할 수 있다.",
            "직접 객체(인스턴스)를 생성할 수 있다.",
            "상속을 통해 자식 클래스에서 구현해야 한다."
        ],
        "answer": "직접 객체(인스턴스)를 생성할 수 있다.",
        "hint": "미완성 설계도이므로 직접 제품을 만들 수 없습니다.",
        "explanation": "추상 클래스는 미완성 클래스이므로 new 연산자를 통해 직접 인스턴스를 생성할 수 없으며, 상속받은 자식 클래스를 통해 생성해야 합니다."
    },
    {
        "level": 4,
        "problem": "네트워크 장비 중, 서로 다른 프로토콜을 사용하는 네트워크 간을 연결해주며 프로토콜 변환 기능을 수행하는 것은?",
        "options": [
            "Bridge",
            "Router",
            "Gateway",
            "Hub"
        ],
        "answer": "Gateway",
        "hint": "출입구 역할을 하며 가장 상위 계층까지 다룹니다.",
        "explanation": "게이트웨이(Gateway)는 서로 다른 아키텍처나 프로토콜을 가진 네트워크를 연결하며, 전 계층의 프로토콜 변환을 수행합니다."
    },
    {
        "level": 4,
        "problem": "C언어에서 구조체 변수 선언 시 'struct' 키워드를 생략하기 위해 사용하는 키워드는?",
        "options": [
            "typedef",
            "define",
            "enum",
            "union"
        ],
        "answer": "typedef",
        "hint": "자료형을 새로 정의합니다.",
        "explanation": "typedef는 기존 자료형에 새로운 이름을 붙여주는 키워드로, 구조체 선언 시 함께 사용하면 변수 선언 시 struct 키워드를 생략할 수 있습니다."
    },
    {
        "level": 4,
        "problem": "Java의 컬렉션 프레임워크 중 Key-Value 쌍으로 데이터를 저장하며, 순서를 보장하지 않는 클래스는?",
        "options": [
            "ArrayList",
            "HashSet",
            "HashMap",
            "LinkedList"
        ],
        "answer": "HashMap",
        "hint": "Map 인터페이스를 구현합니다.",
        "explanation": "HashMap은 Map 인터페이스를 구현한 클래스로 키와 값의 쌍으로 데이터를 관리하며, 해싱을 사용하기 때문에 순서를 보장하지 않습니다."
    },
    {
        "level": 4,
        "problem": "Python에서 문자열 'Hello World'를 'World Hello'로 출력하기 위해 사용하는 split() 함수의 기본 구분자는?",
        "options": [
            "공백(Space)",
            "콤마(,)",
            "점(.)",
            "줄바꿈(\\n)"
        ],
        "answer": "공백(Space)",
        "hint": "아무것도 넣지 않았을 때 기준입니다.",
        "explanation": "split() 함수에 인자를 전달하지 않으면 공백(스페이스, 탭, 엔터 등)을 기준으로 문자열을 나눕니다."
    },
    {
        "level": 4,
        "problem": "운영체제의 가상기억장치 구현 기법 중 프로그램을 가변적인 크기의 블록으로 나누는 기법은?",
        "options": [
            "Paging",
            "Segmentation",
            "Banking",
            "Spooling"
        ],
        "answer": "Segmentation",
        "hint": "논리적인 단위(함수, 배열 등)로 나눕니다.",
        "explanation": "세그멘테이션(Segmentation)은 프로그램을 논리적인 크기의 가변적인 블록(세그먼트)으로 나누어 메모리에 적재하는 기법입니다. (페이징은 고정 크기)"
    },
    {
        "level": 4,
        "problem": "TCP/IP 프로토콜 중 네트워크 계층에서 동작하며, 멀티캐스트 그룹 관리를 담당하는 프로토콜은?",
        "options": [
            "ICMP",
            "IGMP",
            "ARP",
            "RARP"
        ],
        "answer": "IGMP",
        "hint": "Group Management Protocol입니다.",
        "explanation": "IGMP(Internet Group Management Protocol)는 멀티캐스트 그룹에 가입하거나 탈퇴하는 등의 그룹 관리를 수행합니다."
    },
    {
        "level": 4,
        "problem": "C언어 포인터: int a[3] = {10, 20, 30}; int *p = a; printf(\"%d\", *p++); 의 결과는?",
        "options": [
            "10",
            "20",
            "30",
            "11"
        ],
        "answer": "10",
        "hint": "후위 연산자(++)는 출력을 먼저 하고 주소를 증가시킵니다.",
        "explanation": "*p++는 *(p++)와 같습니다. 현재 p가 가리키는 값(10)을 먼저 출력하고, p의 주소값을 1 증가시킵니다."
    },
    {
        "level": 4,
        "problem": "UNIX 파일 시스템에서 파일의 소유자, 크기, 생성 시간, 권한 등의 메타 데이터를 저장하는 블록은?",
        "options": [
            "Boot Block",
            "Super Block",
            "I-node Block",
            "Data Block"
        ],
        "answer": "I-node Block",
        "hint": "Index node의 약자입니다.",
        "explanation": "I-node는 파일에 대한 속성 정보(메타 데이터)와 데이터 블록의 위치 정보를 저장하는 자료구조입니다."
    },
    {
        "level": 4,
        "problem": "OSI 7계층 중 데이터의 암호화, 압축, 코드 변환 등을 담당하여 상호 간에 이해할 수 있는 포맷으로 변환하는 계층은?",
        "options": [
            "응용 계층",
            "표현 계층 (Presentation Layer)",
            "세션 계층",
            "전송 계층"
        ],
        "answer": "표현 계층 (Presentation Layer)",
        "hint": "데이터를 어떻게 표현할지 정합니다.",
        "explanation": "표현 계층은 데이터의 구문(Syntax)을 다루며 암호화, 압축, 인코딩 변환 등을 수행합니다."
    },
    {
        "level": 4,
        "problem": "프로세스 교착상태(Deadlock) 해결 방법 중 '은행원 알고리즘(Banker's Algorithm)'이 해당하는 유형은?",
        "options": [
            "예방 (Prevention)",
            "회피 (Avoidance)",
            "발견 (Detection)",
            "회복 (Recovery)"
        ],
        "answer": "회피 (Avoidance)",
        "hint": "불안전 상태가 되지 않도록 피하는 것입니다.",
        "explanation": "은행원 알고리즘은 시스템이 안전 상태일 때만 자원을 할당하여 교착상태를 '회피'하는 기법입니다."
    },
    {
        "level": 4,
        "problem": "Java에서 스레드(Thread)를 생성하기 위해 상속받거나 구현해야 하는 인터페이스는?",
        "options": [
            "Runnable",
            "Serializable",
            "Comparable",
            "Cloneable"
        ],
        "answer": "Runnable",
        "hint": "run() 메소드를 구현해야 합니다.",
        "explanation": "스레드를 구현하려면 Thread 클래스를 상속받거나 Runnable 인터페이스를 implements 하여 run() 메소드를 재정의해야 합니다."
    },
    {
        "level": 4,
        "problem": "IPv4 헤더의 필드 중 패킷이 네트워크 내에서 무한히 순환하는 것을 방지하기 위해 라우터를 거칠 때마다 1씩 감소하는 필드는?",
        "options": [
            "Version",
            "Identification",
            "TTL (Time To Live)",
            "Checksum"
        ],
        "answer": "TTL (Time To Live)",
        "hint": "수명(Time)이 줄어듭니다.",
        "explanation": "TTL은 패킷의 생존 시간을 나타내며, 라우터를 통과할 때마다 값이 1씩 감소하여 0이 되면 패기됩니다."
    },
    {
        "level": 4,
        "problem": "C언어: int n=7; printf(\"%d\", n << 2); 의 결과는?",
        "options": [
            "14",
            "28",
            "3",
            "1"
        ],
        "answer": "28",
        "hint": "왼쪽 시프트 1칸당 값은 2배가 됩니다.",
        "explanation": "7(00000111)을 왼쪽으로 2비트 이동하면 28(00011100)이 됩니다. (7 * 2^2 = 28)"
    },
    {
        "level": 4,
        "problem": "운영체제 스케줄링 중 'Round Robin' 방식의 특징은?",
        "options": [
            "시간 할당량(Time Slice) 동안만 CPU를 사용한다.",
            "가장 짧은 작업을 우선 처리한다.",
            "우선순위가 높은 작업을 먼저 처리한다.",
            "한 번 할당받으면 끝까지 수행한다."
        ],
        "answer": "시간 할당량(Time Slice) 동안만 CPU를 사용한다.",
        "hint": "시분할 시스템을 위해 고안되었습니다.",
        "explanation": "Round Robin은 FCFS 방식을 선점형으로 변형한 것으로, 각 프로세스는 할당된 시간(Time Quantum) 동안만 CPU를 사용하고 대기 큐의 끝으로 이동합니다."
    },
    {
        "level": 4,
        "problem": "Python에서 예외를 강제로 발생시킬 때 사용하는 키워드는?",
        "options": [
            "throw",
            "raise",
            "error",
            "catch"
        ],
        "answer": "raise",
        "hint": "들어 올린다는 뜻입니다.",
        "explanation": "Python에서는 raise 키워드를 사용하여 에러를 강제로 발생시킬 수 있습니다. (Java는 throw)"
    },
    {
        "level": 4,
        "problem": "네트워크 서브넷 마스크가 255.255.255.192 일 때, 하나의 서브넷에서 사용 가능한 호스트(IP)의 개수는?",
        "options": [
            "30개",
            "62개",
            "126개",
            "254개"
        ],
        "answer": "62개",
        "hint": "192는 이진수로 11000000 입니다. 호스트 비트는 6개입니다.",
        "explanation": "호스트 비트가 6비트이므로 2^6 = 64개 IP가 나오며, 여기서 네트워크 주소와 브로드캐스트 주소 2개를 뺀 62개를 사용할 수 있습니다."
    },
    {
        "level": 4,
        "problem": "C언어: int i=0, sum=0; while(i<5) { i++; if(i==3) continue; sum += i; } printf(\"%d\", sum); 의 결과는?",
        "options": [
            "12",
            "15",
            "10",
            "9"
        ],
        "answer": "12",
        "hint": "1, 2, 4, 5를 더합니다.",
        "explanation": "i는 1, 2, 3, 4, 5로 증가하며, i가 3일 때 continue로 인해 덧셈을 건너뜁니다. 1+2+4+5 = 12."
    },
    {
        "level": 4,
        "problem": "Java에서 'static' 메소드 내에서 사용할 수 없는 것은?",
        "options": [
            "static 변수",
            "지역 변수",
            "인스턴스(instance) 변수",
            "매개변수"
        ],
        "answer": "인스턴스(instance) 변수",
        "hint": "객체가 생성되기 전에 실행될 수 있습니다.",
        "explanation": "static 메소드는 객체 생성 없이 호출될 수 있으므로, 객체 생성이 필요한 인스턴스 변수(this 포함)는 사용할 수 없습니다."
    },
    {
        "level": 4,
        "problem": "UNIX 쉘(Shell) 환경 변수를 설정하거나 확인하는 명령어는?",
        "options": [
            "env",
            "ls",
            "tar",
            "grep"
        ],
        "answer": "env",
        "hint": "Environment의 약자입니다.",
        "explanation": "env(또는 printenv) 명령어는 현재 설정된 환경 변수 목록을 출력하거나 설정할 때 사용합니다."
    },
    {
        "level": 4,
        "problem": "ARP Spoofing 공격에 대한 설명으로 옳은 것은?",
        "options": [
            "자신의 MAC 주소를 게이트웨이의 MAC 주소인 것처럼 속인다.",
            "대량의 패킷을 보내 서버를 마비시킨다.",
            "패킷의 출발지 IP를 변조한다.",
            "DNS 응답을 조작한다."
        ],
        "answer": "자신의 MAC 주소를 게이트웨이의 MAC 주소인 것처럼 속인다.",
        "hint": "중간자 공격(Man In The Middle)의 일종입니다.",
        "explanation": "ARP Spoofing은 공격자의 MAC 주소를 타겟의 IP 주소와 매핑되도록 ARP 패킷을 위조하여 데이터 흐름을 가로채는 공격입니다."
    },
    {
        "level": 4,
        "problem": "페이지 교체 알고리즘 중 'LFU(Least Frequently Used)'의 교체 기준은?",
        "options": [
            "사용 빈도(횟수)가 가장 적은 페이지",
            "가장 오랫동안 사용하지 않은 페이지",
            "가장 먼저 들어온 페이지",
            "최근에 사용하지 않은 페이지"
        ],
        "answer": "사용 빈도(횟수)가 가장 적은 페이지",
        "hint": "Frequent는 빈번함을 의미합니다.",
        "explanation": "LFU는 참조 횟수(빈도)가 가장 적은 페이지를 교체하는 기법입니다."
    },
    {
        "level": 4,
        "problem": "C언어: char a[] = \"Test\"; printf(\"%d\", sizeof(a)); 의 결과는?",
        "options": [
            "4",
            "5",
            "8",
            "1"
        ],
        "answer": "5",
        "hint": "문자열 끝에는 널 문자(\\0)가 포함됩니다.",
        "explanation": "\"Test\"는 4글자지만 끝에 종료 문자 '\\0'이 자동으로 포함되어 크기는 5바이트가 됩니다."
    },
    {
        "level": 4,
        "problem": "Python: def func(a, b=5): return a+b; print(func(3)); 의 결과는?",
        "options": [
            "3",
            "5",
            "8",
            "Error"
        ],
        "answer": "8",
        "hint": "디폴트 매개변수가 사용됩니다.",
        "explanation": "함수 호출 시 b의 값을 주지 않았으므로 기본값 5가 사용되어 3 + 5 = 8이 반환됩니다."
    },
    {
        "level": 4,
        "problem": "OSI 7계층 중 물리적 연결을 설정, 유지, 해제하며 전기적, 기계적 특성을 정의하는 계층은?",
        "options": [
            "물리 계층",
            "데이터 링크 계층",
            "네트워크 계층",
            "전송 계층"
        ],
        "answer": "물리 계층",
        "hint": "케이블, 리피터 등이 속합니다.",
        "explanation": "물리 계층(Physical Layer)은 비트 스트림을 전송하며 전압, 케이블 규격 등 하드웨어적 특성을 정의합니다."
    },
    {
        "level": 4,
        "problem": "프로세스의 상태 중 '준비(Ready)' 상태에서 '실행(Running)' 상태로 변하는 과정을 무엇이라 하는가?",
        "options": [
            "Dispatch",
            "Spooling",
            "Wake Up",
            "Block"
        ],
        "answer": "Dispatch",
        "hint": "스케줄러가 CPU를 쥐어주는 것입니다.",
        "explanation": "디스패치(Dispatch)는 준비 상태에 있는 프로세스 중 하나를 골라 CPU 제어권을 넘겨주어 실행 상태로 만드는 과정입니다."
    },
    {
        "level": 4,
        "problem": "Java에서 상속 관계가 없을 때 두 클래스 간의 기능을 확장하거나 결합하기 위해 주로 사용하는 디자인 패턴은?",
        "options": [
            "Singleton",
            "Adapter",
            "Observer",
            "Factory"
        ],
        "answer": "Adapter",
        "hint": "호환되지 않는 인터페이스를 연결해 줍니다.",
        "explanation": "어댑터(Adapter) 패턴은 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들을 연결해 주는 구조 패턴입니다."
    },
    {
        "level": 4,
        "problem": "C언어에서 메모리 누수(Memory Leak)를 방지하기 위해 동적 할당된 메모리를 해제하는 함수는?",
        "options": [
            "malloc()",
            "free()",
            "alloc()",
            "new"
        ],
        "answer": "free()",
        "hint": "자유롭게 놓아줍니다.",
        "explanation": "malloc 등으로 할당한 힙 영역의 메모리는 사용 후 반드시 free() 함수로 해제해야 합니다."
    },
    {
        "level": 4,
        "problem": "다음 중 '비연결형(Connectionless)' 통신 방식을 사용하는 프로토콜은?",
        "options": [
            "TCP",
            "UDP",
            "SPX",
            "X.25"
        ],
        "answer": "UDP",
        "hint": "데이터그램 방식입니다.",
        "explanation": "UDP(User Datagram Protocol)는 연결 설정 과정(Handshaking) 없이 데이터를 독립적인 패킷으로 전송하는 비연결형 프로토콜입니다."
    },
    {
        "level": 4,
        "problem": "운영체제에서 '임계 구역(Critical Section)'의 상호 배제(Mutual Exclusion)를 보장하기 위한 하드웨어적 기법은?",
        "options": [
            "Semaphore",
            "Monitor",
            "TestAndSet",
            "Banker's Algorithm"
        ],
        "answer": "TestAndSet",
        "hint": "기계어 명령 하나로 값을 읽고 씁니다.",
        "explanation": "TestAndSet은 원자적(Atomic) 연산을 수행하는 하드웨어 명령어로, 상호 배제를 구현하는 데 사용됩니다. 세마포어와 모니터는 소프트웨어적 기법입니다."
    },
    {
        "level": 4,
        "problem": "Python: a = [1, 2, 3]; a.append([4, 5]); print(len(a)); 의 결과는?",
        "options": [
            "3",
            "4",
            "5",
            "Error"
        ],
        "answer": "4",
        "hint": "[4, 5] 리스트 자체가 하나의 요소로 추가됩니다.",
        "explanation": "append는 객체를 하나의 요소로 추가합니다. 따라서 [1, 2, 3, [4, 5]]가 되어 길이는 4입니다."
    },
    {
        "level": 4,
        "problem": "Java에서 '다형성(Polymorphism)'을 구현하는 방법이 아닌 것은?",
        "options": [
            "Overloading",
            "Overriding",
            "Interface 구현",
            "Encapsulation"
        ],
        "answer": "Encapsulation",
        "hint": "캡슐화는 정보 은닉과 관련 있습니다.",
        "explanation": "캡슐화(Encapsulation)는 데이터와 함수를 묶고 정보를 은닉하는 개념이며, 다형성은 오버로딩, 오버라이딩 등을 통해 구현됩니다."
    },
    {
        "level": 4,
        "problem": "네트워크 클래스 A의 IP 주소 범위로 옳은 것은?",
        "options": [
            "0.0.0.0 ~ 127.255.255.255",
            "128.0.0.0 ~ 191.255.255.255",
            "192.0.0.0 ~ 223.255.255.255",
            "224.0.0.0 ~ 239.255.255.255"
        ],
        "answer": "0.0.0.0 ~ 127.255.255.255",
        "hint": "첫 번째 비트가 0입니다.",
        "explanation": "Class A는 첫 바이트가 0~127 범위입니다. (B클래스: 128~191, C클래스: 192~223)"
    },
    {
        "level": 4,
        "problem": "C언어: int arr[5] = {1, 2, 3}; printf(\"%d\", arr[4]); 의 결과는?",
        "options": [
            "0",
            "3",
            "쓰레기값",
            "에러"
        ],
        "answer": "0",
        "hint": "초기화 리스트가 배열 크기보다 짧으면 나머지는?",
        "explanation": "배열 선언 시 초기화 리스트가 배열 크기보다 작으면, 나머지 요소는 자동으로 0으로 초기화됩니다."
    },
    {
        "level": 4,
        "problem": "UNIX에서 프로세스 간 통신(IPC) 기법이 아닌 것은?",
        "options": [
            "Pipe",
            "Socket",
            "Shared Memory",
            "Thread"
        ],
        "answer": "Thread",
        "hint": "스레드는 통신 방식이 아니라 실행 단위입니다.",
        "explanation": "Pipe, Socket, Shared Memory, Message Queue 등은 IPC 기법이지만, Thread는 프로세스 내의 실행 흐름 단위입니다."
    },
    {
        "level": 4,
        "problem": "TCP 흐름 제어(Flow Control) 기법 중 하나로, 수신 측의 버퍼 크기에 맞춰 전송량을 조절하는 방식은?",
        "options": [
            "Sliding Window",
            "Stop and Wait",
            "Slow Start",
            "Congestion Avoidance"
        ],
        "answer": "Sliding Window",
        "hint": "윈도우 크기를 조절하며 연속 전송합니다.",
        "explanation": "슬라이딩 윈도우는 수신 측에서 설정한 윈도우 크기만큼 송신 측이 확인 응답(ACK) 없이 데이터를 연속해서 전송하는 기법입니다."
    },
    {
        "level": 4,
        "problem": "Java: String s1 = \"Java\"; String s2 = new String(\"Java\"); System.out.println(s1 == s2); 의 결과는?",
        "options": [
            "true",
            "false",
            "Java",
            "Error"
        ],
        "answer": "false",
        "hint": "리터럴과 new 객체의 주소는 다릅니다.",
        "explanation": "s1은 String Pool의 상수를 가리키고, s2는 Heap 영역에 새로 생성된 객체를 가리키므로 주소값 비교(==) 시 false가 나옵니다."
    },
    {
        "level": 4,
        "problem": "Python 딕셔너리(Dictionary)에서 모든 Key만 가져오는 메소드는?",
        "options": [
            "keys()",
            "values()",
            "items()",
            "get()"
        ],
        "answer": "keys()",
        "hint": "이름 그대로입니다.",
        "explanation": "keys() 메소드는 딕셔너리의 키(Key) 목록을 반환합니다. (values: 값, items: 키-값 쌍)"
    },
    {
        "level": 4,
        "problem": "교착상태 발생 조건 중 '자원은 한 번에 한 프로세스만 사용할 수 있다'는 조건은?",
        "options": [
            "상호 배제 (Mutual Exclusion)",
            "점유 및 대기",
            "비선점",
            "환형 대기"
        ],
        "answer": "상호 배제 (Mutual Exclusion)",
        "hint": "너 아니면 나, 둘 중 하나만 쓸 수 있습니다.",
        "explanation": "상호 배제는 독점적으로 자원을 사용해야 한다는 조건으로, 이를 부정하면 교착상태를 예방할 수 있습니다."
    },
    {
        "level": 4,
        "problem": "C언어 매크로 함수: #define SQR(x) x*x ... printf(\"%d\", SQR(2+3)); 의 결과는?",
        "options": [
            "25",
            "11",
            "13",
            "10"
        ],
        "answer": "11",
        "hint": "단순 치환됩니다. 2+3*2+3",
        "explanation": "매크로는 텍스트 그대로 치환됩니다. 2+3 * 2+3 = 2 + 6 + 3 = 11. (괄호를 써서 #define SQR(x) ((x)*(x))로 해야 25가 나옴)"
    },
    {
        "level": 4,
        "problem": "OSI 7계층 중 경로 설정(Routing), 패킷 전달, 트래픽 제어를 수행하는 계층은?",
        "options": [
            "네트워크 계층",
            "데이터 링크 계층",
            "전송 계층",
            "세션 계층"
        ],
        "answer": "네트워크 계층",
        "hint": "IP 프로토콜이 여기 속합니다.",
        "explanation": "네트워크 계층(Network Layer)은 최적의 경로를 찾아 패킷을 목적지까지 전달하는 역할을 수행합니다."
    },
    {
        "level": 4,
        "problem": "UNIX 명령어 중 파일의 내용을 화면 단위로 끊어서 보여주는 명령어는?",
        "options": [
            "more",
            "cp",
            "mv",
            "touch"
        ],
        "answer": "more",
        "hint": "더 보여달라는 뜻입니다. (less도 있습니다)",
        "explanation": "more(또는 less) 명령어는 긴 파일의 내용을 한 화면씩 나누어 출력합니다."
    },
    {
        "level": 4,
        "problem": "C언어: int a = 10; printf(\"%d\", !a); 의 결과는?",
        "options": [
            "10",
            "1",
            "0",
            "-10"
        ],
        "answer": "0",
        "hint": "0이 아닌 값은 참(True)입니다.",
        "explanation": "C언어에서 0이 아닌 값은 참으로 간주됩니다. !a는 참(True)의 부정이므로 거짓(False), 즉 0이 됩니다."
    },
    {
        "level": 4,
        "problem": "Java에서 예외(Exception) 발생 시 메시지를 가져오는 메소드는?",
        "options": [
            "getMessage()",
            "print()",
            "toString()",
            "catch()"
        ],
        "answer": "getMessage()",
        "hint": "오류 메시지를 얻습니다.",
        "explanation": "Exception 클래스의 getMessage() 메소드는 발생한 예외에 대한 상세 메시지 문자열을 반환합니다."
    },
    {
        "level": 4,
        "problem": "스케줄링 기법 중 SJF(Shortest Job First)의 단점인 기아 현상을 보완하기 위해 대기 시간을 고려한 기법은?",
        "options": [
            "HRN",
            "RR",
            "SRT",
            "Multilevel Queue"
        ],
        "answer": "HRN",
        "hint": "Highest Response-ratio Next",
        "explanation": "HRN은 우선순위 계산식에 대기 시간을 포함시켜, 오래 기다린 프로세스의 우선순위를 높여줍니다."
    },
    {
        "level": 4,
        "problem": "Python: a = (1); b = (1,); type(a)와 type(b)는?",
        "options": [
            "int, tuple",
            "tuple, tuple",
            "int, int",
            "tuple, int"
        ],
        "answer": "int, tuple",
        "hint": "요소가 하나인 튜플은 콤마(,)가 필수입니다.",
        "explanation": "(1)은 괄호로 감싼 정수 1이고, (1,)은 요소가 하나인 튜플입니다."
    },
    {
        "level": 4,
        "problem": "네트워크 토폴로지 중 모든 노드가 하나의 통신 회선(Backbone)에 연결되어 있는 형태는?",
        "options": [
            "버스형 (Bus)",
            "성형 (Star)",
            "링형 (Ring)",
            "망형 (Mesh)"
        ],
        "answer": "버스형 (Bus)",
        "hint": "버스 손잡이처럼 매달려 있습니다.",
        "explanation": "버스형 토폴로지는 하나의 공통 전송 회선(버스)에 여러 단말이 연결된 구조로, 회선 종단에는 터미네이터가 필요합니다."
    },
    {
        "level": 4,
        "problem": "C언어 전처리기가 아닌 것은?",
        "options": [
            "#include",
            "#define",
            "#if",
            "#while"
        ],
        "answer": "#while",
        "hint": "반복문은 컴파일러가 처리합니다.",
        "explanation": "#while이라는 전처리 지시어는 없습니다. (#include, #define, #ifdef 등은 존재)"
    },
    {
        "level": 4,
        "problem": "UNIX 파일 권한이 'rwxr-xr--' (754) 일 때, 그룹(Group) 사용자의 권한은?",
        "options": [
            "읽기/쓰기/실행",
            "읽기/실행",
            "읽기 전용",
            "실행 전용"
        ],
        "answer": "읽기/실행",
        "hint": "중간의 3자리 'r-x' 입니다.",
        "explanation": "rwx(소유자) / r-x(그룹) / r--(기타). 그룹은 r(4)+x(1)=5 이므로 읽기와 실행 권한을 가집니다."
    },
    {
        "level": 4,
        "problem": "Java에서 Garbage Collection(GC)이 관리하는 메모리 영역은?",
        "options": [
            "Stack",
            "Heap",
            "Static",
            "Register"
        ],
        "answer": "Heap",
        "hint": "동적으로 생성된 객체가 저장되는 곳입니다.",
        "explanation": "new 연산자로 생성된 객체는 Heap 영역에 저장되며, 더 이상 참조되지 않을 때 GC에 의해 수거됩니다."
    },
    {
        "level": 4,
        "problem": "OSI 7계층 중 인접한 두 장비 간의 신뢰성 있는 정보 전송을 위해 오류 제어와 흐름 제어를 수행하는 계층은?",
        "options": [
            "데이터 링크 계층",
            "물리 계층",
            "전송 계층",
            "네트워크 계층"
        ],
        "answer": "데이터 링크 계층",
        "hint": "프레임(Frame) 단위로 전송합니다.",
        "explanation": "데이터 링크 계층은 물리적 연결을 통해 인접한 노드 간의 신뢰성 있는 전송(프레임 전송)을 담당합니다. (전송 계층은 종단 간 신뢰성)"
    },
    {
        "level": 4,
        "problem": "C언어: int a=3, b=2; float c = a/b; printf(\"%.1f\", c); 의 결과는?",
        "options": [
            "1.5",
            "1.0",
            "1",
            "2.0"
        ],
        "answer": "1.0",
        "hint": "정수 나누기 정수는 정수입니다.",
        "explanation": "a와 b가 모두 정수이므로 a/b는 정수 연산이 되어 소수점이 버려진 1이 됩니다. 이를 float에 대입하면 1.0이 됩니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 개발 보안 방법론 중 'Seven Touchpoints'에서 모의 침투 테스트(Penetration Testing)가 수행되는 단계는?",
        "options": [
            "요구사항 분석",
            "구조 설계",
            "구현 및 테스트",
            "외부 악용 점검"
        ],
        "answer": "외부 악용 점검",
        "hint": "개발의 후반부 단계입니다.",
        "explanation": "Seven Touchpoints의 단계 중 '제5단계: 악용 사례(Abuse Cases)'와 '제6단계: 외부 악용 점검' 등에서 모의 해킹이나 침투 테스트가 수행됩니다."
    },
    {
        "level": 5,
        "problem": "접근 통제 모델 중 'Biba 모델'의 무결성 원칙 중 하나로, '낮은 보안 등급의 주체는 높은 보안 등급의 객체에 데이터를 쓸 수 없다'는 규칙은?",
        "options": [
            "Simple Integrity Property (No Read Down)",
            "Star Integrity Property (No Write Up)",
            "Simple Security Property (No Read Up)",
            "Star Security Property (No Write Down)"
        ],
        "answer": "Star Integrity Property (No Write Up)",
        "hint": "데이터의 신뢰성이 낮은 곳에서 높은 곳으로 오염되는 것을 막습니다.",
        "explanation": "Biba 모델의 Star Integrity Property(성형 무결성 원칙)는 무결성이 낮은 주체가 높은 등급의 객체를 수정하여 무결성을 해치는 것을 방지하기 위한 'No Write Up' 규칙입니다."
    },
    {
        "level": 5,
        "problem": "IPSec 프로토콜에서 'IKE(Internet Key Exchange)'의 역할은?",
        "options": [
            "데이터 암호화",
            "무결성 검증",
            "보안 연관(SA) 설정 및 키 교환",
            "패킷 압축"
        ],
        "answer": "보안 연관(SA) 설정 및 키 교환",
        "hint": "키(Key)를 교환합니다.",
        "explanation": "IKE는 IPSec 통신을 시작하기 전에 두 호스트 간의 보안 파라미터(암호화 알고리즘, 키 등)를 협상하고 보안 연관(SA)을 설정하는 프로토콜입니다."
    },
    {
        "level": 5,
        "problem": "기능 점수(FP) 산정 방식 중 '트랜잭션 기능' 측정 요소인 '외부 입력(EI)', '외부 출력(EO)', '외부 조회(EQ)'를 구분하는 기준인 'FTR'의 정의는?",
        "options": [
            "참조되는 내부 논리 파일 또는 외부 인터페이스 파일의 수",
            "사용자가 식별 가능한 필드의 수",
            "입력 데이터의 복잡도",
            "출력 보고서의 페이지 수"
        ],
        "answer": "참조되는 내부 논리 파일 또는 외부 인터페이스 파일의 수",
        "hint": "File Type Referenced의 약자입니다.",
        "explanation": "FTR(File Type Referenced)은 트랜잭션 처리 과정에서 읽거나 생성/수정하기 위해 참조하는 파일(ILF 또는 EIF)의 개수를 의미합니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '세션 하이재킹(Session Hijacking)' 공격을 탐지했을 때 발생하는 현상으로, 공격자가 서버와 클라이언트 사이의 패킷 순서 번호(Sequence Number)를 조작함으로써 발생하는 현상은?",
        "options": [
            "ACK Storm",
            "SYN Flood",
            "Buffer Overflow",
            "Race Condition"
        ],
        "answer": "ACK Storm",
        "hint": "패킷이 폭풍처럼 쏟아집니다.",
        "explanation": "세션 하이재킹 시 공격자가 끼어들어 시퀀스 넘버가 어긋나게 되면, 서버와 클라이언트는 서로 올바른 시퀀스 넘버를 맞추기 위해 무한정 ACK 패킷을 주고받는 'ACK Storm' 현상이 발생합니다."
    },
    {
        "level": 5,
        "problem": "CMMI(Capability Maturity Model Integration) 모델의 성숙도 단계 중, '조직 차원의 표준 프로세스가 정립되고, 프로젝트가 이 표준에 따라 수행되는' 단계는?",
        "options": [
            "Level 1 (Initial)",
            "Level 2 (Managed)",
            "Level 3 (Defined)",
            "Level 4 (Quantitatively Managed)"
        ],
        "answer": "Level 3 (Defined)",
        "hint": "정의(Defined)된 단계입니다.",
        "explanation": "Level 3(Defined)는 조직 전체의 표준 프로세스가 정의되어 있고, 모든 프로젝트가 이 표준 프로세스를 기반으로 수행되는 단계입니다. (Level 2는 프로젝트별로 관리됨)"
    },
    {
        "level": 5,
        "problem": "네트워크 스토리지 구성 방식 중 'SAN(Storage Area Network)' 환경에서 서버와 스토리지 간의 고속 통신을 위해 주로 사용되는 프로토콜은?",
        "options": [
            "NFS",
            "CIFS",
            "Fibre Channel (FC)",
            "HTTP"
        ],
        "answer": "Fibre Channel (FC)",
        "hint": "광케이블을 사용합니다.",
        "explanation": "SAN은 주로 파이버 채널(Fibre Channel) 스위치를 이용해 서버와 스토리지를 연결하여 고속 데이터 전송을 지원합니다. (NFS, CIFS는 NAS 프로토콜)"
    },
    {
        "level": 5,
        "problem": "공개키 기반 구조(PKI)에서 사용자 인증서의 유효성을 검증하기 위해 인증서 폐기 목록(CRL)을 다운로드받는 대신, 실시간으로 인증서 상태를 조회하는 프로토콜은?",
        "options": [
            "OCSP (Online Certificate Status Protocol)",
            "LDAP",
            "CMP",
            "SCEP"
        ],
        "answer": "OCSP (Online Certificate Status Protocol)",
        "hint": "온라인으로 상태를 확인합니다.",
        "explanation": "OCSP는 인증서의 유효성(폐기 여부 등)을 실시간으로 인증 기관(CA) 서버에 질의하여 확인하는 프로토콜입니다."
    },
    {
        "level": 5,
        "problem": "COCOMO II 모형의 '초기 설계(Early Design)' 단계에서 비용 산정에 사용하는 척도는?",
        "options": [
            "Object Point",
            "Function Point",
            "LOC",
            "Use Case Point"
        ],
        "answer": "Function Point",
        "hint": "기능 점수를 기반으로 합니다.",
        "explanation": "COCOMO II의 초기 설계 단계에서는 기능 점수(Function Point)를 사용하여 대략적인 코드 라인 수를 추정하고 비용을 산정합니다. (Application Composition 단계는 Object Point 사용)"
    },
    {
        "level": 5,
        "problem": "다음 중 '스니핑(Sniffing)' 방지 대책으로 가장 효과적인 것은?",
        "options": [
            "데이터 암호화 (SSL/TLS 등)",
            "방화벽 설치",
            "안티바이러스 설치",
            "패스워드 변경"
        ],
        "answer": "데이터 암호화 (SSL/TLS 등)",
        "hint": "엿들어도 내용을 모르게 해야 합니다.",
        "explanation": "스니핑은 네트워크 패킷을 엿보는 공격이므로, 데이터를 암호화하여 전송하면 패킷을 가로채더라도 내용을 알 수 없어 가장 효과적인 방어책이 됩니다."
    },
    {
        "level": 5,
        "problem": "블록체인 합의 알고리즘 중 'PBFT(Practical Byzantine Fault Tolerance)'의 특징으로 틀린 것은?",
        "options": [
            "분기가 발생하지 않아 즉시 완결성을 가진다.",
            "참여 노드 수가 늘어날수록 통신량이 기하급수적으로 증가한다.",
            "퍼블릭 블록체인에 적합하다.",
            "일부 노드가 악의적이어도 합의가 가능하다."
        ],
        "answer": "퍼블릭 블록체인에 적합하다.",
        "hint": "통신량이 많아 노드가 많으면 느려집니다.",
        "explanation": "PBFT는 모든 노드 간의 통신이 필요하므로 노드 수가 많은 퍼블릭 블록체인보다는 허가형(Private/Consortium) 블록체인에 적합합니다."
    },
    {
        "level": 5,
        "problem": "공격자가 웹 사이트의 입력란에 특수문자나 SQL 구문을 입력하여, 데이터베이스로부터 정보를 열람하거나 조작하는 'SQL Injection' 공격 중, 쿼리 결과를 참/거짓으로만 판단하여 데이터를 알아내는 기법은?",
        "options": [
            "Union-Based SQL Injection",
            "Blind SQL Injection",
            "Stored Procedure Injection",
            "Mass SQL Injection"
        ],
        "answer": "Blind SQL Injection",
        "hint": "장님 코끼리 만지기 식입니다.",
        "explanation": "Blind SQL Injection은 데이터베이스가 에러 메시지를 보여주지 않을 때, 쿼리의 참/거짓 반응(응답 시간, 페이지 변화 등)만으로 데이터를 추측해내는 기법입니다."
    },
    {
        "level": 5,
        "problem": "네트워크 가상화 기술 중, 'SDN(Software Defined Networking)'의 핵심 개념은?",
        "options": [
            "제어 평면(Control Plane)과 데이터 평면(Data Plane)의 분리",
            "하드웨어의 가상화",
            "네트워크 대역폭의 확장",
            "무선 네트워크의 통합"
        ],
        "answer": "제어 평면(Control Plane)과 데이터 평면(Data Plane)의 분리",
        "hint": "뇌와 몸통을 분리합니다.",
        "explanation": "SDN은 네트워크 장비의 제어부(Control Plane)를 중앙의 컨트롤러로 소프트웨어화하여 분리하고, 장비는 전송(Data Plane)만 담당하게 하는 기술입니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '비용 산정 모형'인 Putnam 모형에서 사용하는 'Rayleigh-Norden 곡선'이 나타내는 것은?",
        "options": [
            "프로젝트 기간에 따른 노력(인력)의 분포",
            "코드 라인 수와 오류의 관계",
            "기능 점수와 비용의 관계",
            "유지보수 비용의 증가율"
        ],
        "answer": "프로젝트 기간에 따른 노력(인력)의 분포",
        "hint": "초기엔 적게, 중반엔 많이, 후반엔 다시 적게 투입됩니다.",
        "explanation": "Putnam 모형은 소프트웨어 개발 주기의 각 단계별로 인력 투입 분포가 Rayleigh 곡선을 따른다고 가정하고 이를 토대로 비용을 산정합니다."
    },
    {
        "level": 5,
        "problem": "정보보안의 3요소(CIA) 외에, '사용자가 행한 행위를 부인할 수 없게 하는' 특성은?",
        "options": [
            "인증성 (Authenticity)",
            "부인 방지 (Non-Repudiation)",
            "책임성 (Accountability)",
            "신뢰성 (Reliability)"
        ],
        "answer": "부인 방지 (Non-Repudiation)",
        "hint": "디지털 서명을 사용하는 주된 이유 중 하나입니다.",
        "explanation": "부인 방지(Non-Repudiation)는 송신자나 수신자가 메시지를 주고받은 사실을 나중에 부인하지 못하도록 증거를 제공하는 보안 특성입니다."
    },
    {
        "level": 5,
        "problem": "최신 보안 솔루션 중, '기업 내부의 모든 사용자와 기기를 신뢰하지 않고 끊임없이 검증한다'는 개념의 보안 모델은?",
        "options": [
            "VPN",
            "Zero Trust",
            "Firewall",
            "NAC"
        ],
        "answer": "Zero Trust",
        "hint": "Never Trust, Always Verify.",
        "explanation": "Zero Trust(제로 트러스트) 모델은 '신뢰하지 않는다, 항상 검증한다'는 원칙 하에 내부/외부 구분 없이 모든 접근을 제어하고 검증하는 보안 모델입니다."
    },
    {
        "level": 5,
        "problem": "RAID 레벨 중, 최소 3개의 디스크가 필요하며, 패리티 정보를 모든 디스크에 분산 저장하여 디스크 1개 장애 시 복구가 가능한 방식은?",
        "options": [
            "RAID 0",
            "RAID 1",
            "RAID 5",
            "RAID 6"
        ],
        "answer": "RAID 5",
        "hint": "가장 대중적으로 사용되는 방식 중 하나입니다.",
        "explanation": "RAID 5는 패리티(Parity) 정보를 각 디스크에 분산 저장하여 병목 현상을 줄이고, 디스크 1개 고장 시에도 데이터를 복구할 수 있습니다. (RAID 6는 2개 고장까지 허용)"
    },
    {
        "level": 5,
        "problem": "네트워크 프로토콜 중 IoT(사물인터넷) 환경에서 저전력, 저대역폭 환경에 적합하도록 설계된 '발행/구독(Publish/Subscribe)' 기반의 경량 프로토콜은?",
        "options": [
            "HTTP",
            "CoAP",
            "MQTT",
            "XMPP"
        ],
        "answer": "MQTT",
        "hint": "Message Queuing Telemetry Transport",
        "explanation": "MQTT는 경량의 Publish/Subscribe 모델을 사용하여 대역폭이 제한적인 IoT 환경에 최적화된 메시징 프로토콜입니다. (CoAP는 REST 기반)"
    },
    {
        "level": 5,
        "problem": "소프트웨어 비용 산정 시, 프로젝트의 '총 개발 기간'을 단축하기 위해 인력을 추가 투입해도 의사소통 비용 등으로 인해 개발 시간이 비례하여 줄어들지 않는다는 법칙은?",
        "options": [
            "브룩스의 법칙 (Brooks' Law)",
            "무어의 법칙",
            "파레토 법칙",
            "암달의 법칙"
        ],
        "answer": "브룩스의 법칙 (Brooks' Law)",
        "hint": "지체된 프로젝트에 인력을 더하면 더 지체된다.",
        "explanation": "브룩스의 법칙은 '지체되는 소프트웨어 개발 프로젝트에 인력을 추가하는 것은 프로젝트를 더욱 지체시킨다'는 격언입니다."
    },
    {
        "level": 5,
        "problem": "다음 중 대칭키 암호화 알고리즘이면서, 128비트의 블록 크기를 갖고 128/192/256비트의 키 길이를 지원하는 미국 표준 알고리즘은?",
        "options": [
            "DES",
            "AES",
            "RSA",
            "SEED"
        ],
        "answer": "AES",
        "hint": "Rijndael 알고리즘을 기반으로 합니다.",
        "explanation": "AES(Advanced Encryption Standard)는 DES를 대체하기 위해 선정된 미국 표준 대칭키 암호화 알고리즘으로, SPN 구조를 가집니다."
    },
    {
        "level": 5,
        "problem": "PERT(Program Evaluation and Review Technique) 기법에서 작업의 소요 시간을 예측할 때 사용하는 공식은? (a: 비관치, m: 최가능치, b: 낙관치)",
        "options": [
            "(a + m + b) / 3",
            "(a + 4m + b) / 6",
            "(a + 2m + b) / 4",
            "(a + 6m + b) / 8"
        ],
        "answer": "(a + 4m + b) / 6",
        "hint": "최가능치(m)에 가중치 4를 줍니다.",
        "explanation": "PERT는 베타 분포를 가정하여 예측치(TE) = (낙관치 + 4*최가능치 + 비관치) / 6 공식을 사용합니다."
    },
    {
        "level": 5,
        "problem": "클라우드 컴퓨팅 서비스 모델 중, 개발자에게 애플리케이션 개발 및 실행을 위한 플랫폼(OS, DB, 미들웨어 등)을 제공하는 모델은?",
        "options": [
            "IaaS",
            "PaaS",
            "SaaS",
            "DaaS"
        ],
        "answer": "PaaS",
        "hint": "Platform as a Service",
        "explanation": "PaaS(Platform as a Service)는 개발 환경과 도구를 서비스 형태로 제공합니다. (IaaS는 인프라, SaaS는 소프트웨어 완제품)"
    },
    {
        "level": 5,
        "problem": "악성코드 유형 중, 정상적인 프로그램으로 위장하여 사용자 몰래 숨어 있다가 특정 조건이 되면 악성 기능을 수행하는 것은?",
        "options": [
            "웜 (Worm)",
            "트로이 목마 (Trojan Horse)",
            "바이러스 (Virus)",
            "랜섬웨어 (Ransomware)"
        ],
        "answer": "트로이 목마 (Trojan Horse)",
        "hint": "그리스 로마 신화에서 유래했습니다.",
        "explanation": "트로이 목마는 자가 복제 기능은 없으나, 유용한 프로그램인 척 위장하여 침투한 뒤 백도어 설치, 정보 유출 등의 악성 행위를 합니다."
    },
    {
        "level": 5,
        "problem": "TCP/IP 프로토콜 계층 중 '전송 계층(Transport Layer)'에서 동작하며, 신뢰성 있는 전송을 위해 '3-way Handshaking' 방식으로 연결을 설정하는 프로토콜은?",
        "options": [
            "UDP",
            "IP",
            "TCP",
            "ICMP"
        ],
        "answer": "TCP",
        "hint": "연결 지향형 프로토콜입니다.",
        "explanation": "TCP는 연결 지향형 프로토콜로, 3-way Handshaking을 통해 연결을 수립하고 데이터의 신뢰성을 보장합니다."
    },
    {
        "level": 5,
        "problem": "다음 중 'DoS(Denial of Service)' 공격의 일종으로, HTTP GET 요청을 불완전하게 지속적으로 보내 서버의 연결 자원을 고갈시키는 공격은?",
        "options": [
            "Syn Flooding",
            "Slowloris",
            "Smurf",
            "Ping of Death"
        ],
        "answer": "Slowloris",
        "hint": "Slow HTTP Header DoS라고도 합니다.",
        "explanation": "Slowloris 공격은 HTTP 헤더를 끝내지 않고 천천히 전송하여 웹 서버의 연결 스레드를 오랫동안 점유함으로써 정상적인 서비스를 방해합니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 유지보수의 유형 중 '소프트웨어의 잠재적인 오류를 사전에 발견하고 수정하여 미래의 문제를 예방'하는 활동은?",
        "options": [
            "수정(Corrective) 유지보수",
            "적응(Adaptive) 유지보수",
            "완전(Perfective) 유지보수",
            "예방(Preventive) 유지보수"
        ],
        "answer": "예방(Preventive) 유지보수",
        "hint": "미리 막는 것입니다.",
        "explanation": "예방 유지보수는 현재는 문제가 없으나 향후 발생할 수 있는 문제를 미리 찾아 수정하거나, 유지보수성을 향상시키는 활동(문서 업데이트, 코드 구조 개선 등)입니다."
    },
    {
        "level": 5,
        "problem": "암호화 키 분배 프로토콜 중, 이산대수 문제의 어려움에 기반하여 두 사용자가 사전에 비밀키를 공유하지 않고도 안전하게 공통의 비밀키를 생성할 수 있게 하는 방식은?",
        "options": [
            "Diffie-Hellman",
            "RSA",
            "ElGamal",
            "ECC"
        ],
        "answer": "Diffie-Hellman",
        "hint": "최초의 공개키 알고리즘 개념입니다.",
        "explanation": "디피-헬만(Diffie-Hellman) 키 교환 알고리즘은 대칭키를 안전하게 공유하기 위해 고안된 방식으로, 이산대수 문제를 이용합니다."
    },
    {
        "level": 5,
        "problem": "다음 중 'Docker'와 같은 컨테이너 기술의 오케스트레이션(배포, 관리, 확장)을 담당하는 오픈소스 플랫폼은?",
        "options": [
            "Jenkins",
            "Kubernetes",
            "Ansible",
            "GitLab"
        ],
        "answer": "Kubernetes",
        "hint": "구글이 만들었고 '조타수'라는 뜻입니다.",
        "explanation": "쿠버네티스(Kubernetes, k8s)는 컨테이너화된 애플리케이션의 자동 배포, 스케일링, 관리를 위한 컨테이너 오케스트레이션 시스템입니다."
    },
    {
        "level": 5,
        "problem": "접근 통제 방법 중 '역할 기반 접근 통제(RBAC)'의 장점은?",
        "options": [
            "객체별로 세밀한 권한 설정이 가능하다.",
            "인사 이동이 잦은 조직에서 관리가 용이하다.",
            "보안 등급에 따른 엄격한 통제가 가능하다.",
            "데이터 소유자가 임의로 권한을 줄 수 있다."
        ],
        "answer": "인사 이동이 잦은 조직에서 관리가 용이하다.",
        "hint": "사람이 바뀌어도 역할은 그대로입니다.",
        "explanation": "RBAC는 사용자에게 직접 권한을 주는 것이 아니라 '역할'에 권한을 할당하므로, 담당자가 바뀌더라도 역할만 변경하면 되어 관리가 효율적입니다."
    },
    {
        "level": 5,
        "problem": "해시 함수(Hash Function)의 특성 중 '입력값의 아주 작은 변화가 출력값(해시값) 전체를 획기적으로 변화시키는 성질'은?",
        "options": [
            "역상 저항성",
            "제2 역상 저항성",
            "충돌 저항성",
            "쇄도 효과 (Avalanche Effect)"
        ],
        "answer": "쇄도 효과 (Avalanche Effect)",
        "hint": "눈사태 효과라고도 합니다.",
        "explanation": "쇄도 효과는 입력 데이터가 1비트만 바뀌어도 결과 해시값이 절반 이상 바뀌는 성질로, 암호학적 해시 함수의 중요한 요건입니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 신뢰성 모델 중, '소프트웨어의 결함 발생률이 시간에 따라 점차 감소한다'는 가정을 기반으로 하는 모델은?",
        "options": [
            "COCOMO",
            "Putnam",
            "Jelinski-Moranda",
            "McCabe"
        ],
        "answer": "Jelinski-Moranda",
        "hint": "초기 신뢰성 성장 모델입니다.",
        "explanation": "Jelinski-Moranda 모델은 소프트웨어 테스트 과정에서 오류가 발견되고 수정될 때마다 고장률이 일정 비율로 감소한다고 가정합니다."
    },
    {
        "level": 5,
        "problem": "네트워크 공격 기법 중 'ARP Spoofing'의 원리는?",
        "options": [
            "DNS 쿼리를 조작하여 엉뚱한 사이트로 유도한다.",
            "자신의 MAC 주소를 게이트웨이의 MAC 주소인 것처럼 속여 패킷을 가로챈다.",
            "IP 패킷의 소스 주소를 변조한다.",
            "TCP 연결을 가로챈다."
        ],
        "answer": "자신의 MAC 주소를 게이트웨이의 MAC 주소인 것처럼 속여 패킷을 가로챈다.",
        "hint": "2계층 주소(MAC)를 속입니다.",
        "explanation": "ARP Spoofing은 로컬 네트워크에서 ARP 응답을 위조하여 공격자의 MAC 주소를 게이트웨이(또는 피해자)의 IP에 매핑시켜 패킷을 중간에서 가로채는 공격입니다."
    },
    {
        "level": 5,
        "problem": "다음 중 'DRM(Digital Rights Management)' 구성 요소 중 콘텐츠와 라이선스를 암호화하고 패키징하는 역할을 수행하는 것은?",
        "options": [
            "Clearing House",
            "Content Provider",
            "Packager",
            "DRM Controller"
        ],
        "answer": "Packager",
        "hint": "포장하는 사람입니다.",
        "explanation": "패키저(Packager)는 콘텐츠를 메타데이터와 함께 배포 가능한 단위로 묶고 암호화하는 역할을 수행합니다."
    },
    {
        "level": 5,
        "problem": "비대칭키 암호 알고리즘인 RSA의 보안성은 어떤 수학적 난제에 기반하는가?",
        "options": [
            "이산대수 문제",
            "소인수분해 문제",
            "타원곡선 문제",
            "배낭 문제"
        ],
        "answer": "소인수분해 문제",
        "hint": "매우 큰 두 소수의 곱을 구하는 것은 쉽지만, 그 곱을 다시 소수로 나누는 것은 어렵습니다.",
        "explanation": "RSA는 두 개의 큰 소수를 곱하여 만든 합성수를 다시 소인수분해하는 것이 계산적으로 매우 어렵다는 점을 이용합니다."
    },
    {
        "level": 5,
        "problem": "IT 서비스 관리(ITSM) 프레임워크인 'ITIL'의 핵심 구성요소 중, 서비스 중단 시 신속한 복구를 목표로 하는 프로세스는?",
        "options": [
            "문제 관리 (Problem Management)",
            "사건 관리 (Incident Management)",
            "변경 관리 (Change Management)",
            "구성 관리 (Configuration Management)"
        ],
        "answer": "사건 관리 (Incident Management)",
        "hint": "근본 원인 해결보다는 '일단 복구'가 우선입니다.",
        "explanation": "사건 관리(Incident Management)는 서비스 중단을 최소화하고 최대한 빨리 정상 상태로 복구하는 데 초점을 맞춥니다. (근본 원인 해결은 문제 관리)"
    },
    {
        "level": 5,
        "problem": "다음 중 '망 분리(Network Separation)' 기술의 하나로, PC 가상화 기술을 이용해 한 대의 PC에서 논리적으로 업무망과 인터넷망을 분리하는 방식은?",
        "options": [
            "CBC (Client Based Computing)",
            "SBC (Server Based Computing)",
            "VDI (Virtual Desktop Infrastructure)",
            "VPN"
        ],
        "answer": "CBC (Client Based Computing)",
        "hint": "클라이언트(PC) 기반입니다.",
        "explanation": "CBC 방식은 사용자 PC에 가상화 소프트웨어를 설치하여 운영체제를 논리적으로 분리하는 방식입니다. (VDI는 서버 기반인 SBC의 일종)"
    },
    {
        "level": 5,
        "problem": "소프트웨어 아키텍처 패턴 중 '마이크로서비스 아키텍처(MSA)'의 단점으로 볼 수 있는 것은?",
        "options": [
            "서비스 간 결합도가 높다.",
            "특정 서비스만 독립적으로 배포하기 어렵다.",
            "트랜잭션 관리와 데이터 일관성 유지가 어렵다.",
            "기술 스택을 다양하게 가져가기 어렵다."
        ],
        "answer": "트랜잭션 관리와 데이터 일관성 유지가 어렵다.",
        "hint": "DB가 쪼개져 있어서 합치기 힘듭니다.",
        "explanation": "MSA는 서비스별로 DB가 분리되어 있어 분산 트랜잭션 처리가 복잡하고 데이터 일관성을 보장하기 까다롭습니다(Saga 패턴 등 필요)."
    },
    {
        "level": 5,
        "problem": "네트워크 접근 제어(NAC) 시스템의 주요 기능이 아닌 것은?",
        "options": [
            "단말기의 무결성 점검 (백신 설치 여부 등)",
            "비인가 단말기의 네트워크 접근 차단",
            "사용자 인증 및 권한 부여",
            "외부 해킹 시도에 대한 패킷 필터링 및 차단"
        ],
        "answer": "외부 해킹 시도에 대한 패킷 필터링 및 차단",
        "hint": "이것은 방화벽이나 IPS의 역할입니다.",
        "explanation": "NAC는 내부 네트워크에 접속하는 단말기의 보안 상태를 검증하고 접근을 제어하는 솔루션입니다. 외부 해킹 패킷 필터링은 주로 방화벽이나 IPS가 담당합니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '커버로스(Kerberos)' 인증 프로토콜의 특징으로 옳은 것은?",
        "options": [
            "공개키 암호화 방식을 기반으로 한다.",
            "KDC(Key Distribution Center)라는 신뢰된 제3자를 이용한다.",
            "분산 환경보다는 단일 시스템 인증에 적합하다.",
            "타임스탬프를 사용하지 않아 재전송 공격에 취약하다."
        ],
        "answer": "KDC(Key Distribution Center)라는 신뢰된 제3자를 이용한다.",
        "hint": "티켓을 발급해주는 곳이 있습니다.",
        "explanation": "커버로스는 대칭키 기반이며, 신뢰할 수 있는 제3기관인 KDC(AS+TGS)를 통해 티켓을 발급받아 인증을 수행합니다."
    },
    {
        "level": 5,
        "problem": "정보시스템 감리(Audit) 시 준거성이 되는 프레임워크로, IT 거버넌스를 위한 국제 표준은?",
        "options": [
            "ISO/IEC 20000",
            "ISO/IEC 27001",
            "ISO/IEC 38500",
            "CMMI"
        ],
        "answer": "ISO/IEC 38500",
        "hint": "거버넌스(Governance) 표준입니다.",
        "explanation": "ISO/IEC 38500은 IT 거버넌스에 대한 국제 표준입니다. (20000은 ITSM, 27001은 정보보안)"
    },
    {
        "level": 5,
        "problem": "빅데이터 분석 기술 중 '텍스트 마이닝'에서 단어의 빈도수(TF)와 역문서 빈도(IDF)를 곱하여 단어의 중요도를 가중치로 주는 기법은?",
        "options": [
            "TF-IDF",
            "Word2Vec",
            "N-gram",
            "Stemming"
        ],
        "answer": "TF-IDF",
        "hint": "이름에 답이 있습니다.",
        "explanation": "TF-IDF(Term Frequency - Inverse Document Frequency)는 특정 단어가 문서 내에서 얼마나 중요한지를 나타내는 통계적 수치입니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 비용 산정의 '델파이 기법(Delphi Method)'의 특징은?",
        "options": [
            "과거 유사 프로젝트의 데이터를 통계적으로 분석한다.",
            "여러 전문가의 의견을 익명으로 수렴하고 중재하여 합의를 도출한다.",
            "WBS를 기초로 하여 원가를 산정한다.",
            "수학적 공식을 사용하여 자동 계산한다."
        ],
        "answer": "여러 전문가의 의견을 익명으로 수렴하고 중재하여 합의를 도출한다.",
        "hint": "전문가들의 집단 지성을 활용합니다.",
        "explanation": "델파이 기법은 전문가들의 편견을 줄이기 위해 익명으로 의견을 수렴하고, 이를 반복 조정하여 합의점에 도달하는 하향식 산정 기법입니다."
    },
    {
        "level": 5,
        "problem": "네트워크 계층 구조에서 'OSI 7계층' 중 데이터를 전기적 신호로 변환하여 전송하는 물리 계층(Physical Layer)의 PDU(Protocol Data Unit) 단위는?",
        "options": [
            "Frame",
            "Packet",
            "Segment",
            "Bit"
        ],
        "answer": "Bit",
        "hint": "0과 1입니다.",
        "explanation": "물리 계층은 비트(Bit) 단위, 데이터 링크는 프레임(Frame), 네트워크는 패킷(Packet), 전송 계층은 세그먼트(Segment) 단위를 사용합니다."
    },
    {
        "level": 5,
        "problem": "정보보안 관리체계 인증인 'ISMS-P'의 인증 기준 중 '관리체계 수립 및 운영' 단계의 4가지 과정 순서는?",
        "options": [
            "수립 -> 운영 -> 점검 -> 개선",
            "계획 -> 실행 -> 검토 -> 조치",
            "식별 -> 분석 -> 평가 -> 대책",
            "예방 -> 탐지 -> 대응 -> 복구"
        ],
        "answer": "수립 -> 운영 -> 점검 -> 개선",
        "hint": "PDCA(Plan-Do-Check-Act) 사이클과 유사합니다.",
        "explanation": "ISMS-P는 관리체계 기반 마련(수립) -> 위험 관리 및 운영(운영) -> 점검 및 이행 점검(점검) -> 결함 수정 및 재발 방지(개선)의 순환 구조를 가집니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '디지털 트윈(Digital Twin)'의 핵심 기술이 아닌 것은?",
        "options": [
            "3D 모델링",
            "실시간 데이터 동기화 (IoT)",
            "시뮬레이션",
            "블록체인 채굴"
        ],
        "answer": "블록체인 채굴",
        "hint": "현실을 가상에 복제하는 기술입니다.",
        "explanation": "디지털 트윈은 현실 세계의 기계나 장비 등을 컴퓨터 속 가상 세계에 구현하는 것으로 3D 모델링, IoT 센싱, 시뮬레이션 등이 핵심입니다. 채굴과는 관련이 적습니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 공학에서 '리팩토링(Refactoring)'의 목적으로 가장 적절한 것은?",
        "options": [
            "기능을 추가하여 성능을 높인다.",
            "외부 동작은 유지한 채 내부 구조를 개선하여 가독성과 유지보수성을 높인다.",
            "버그를 수정하여 신뢰성을 높인다.",
            "UI를 개선하여 사용성을 높인다."
        ],
        "answer": "외부 동작은 유지한 채 내부 구조를 개선하여 가독성과 유지보수성을 높인다.",
        "hint": "기능 변경 없이 '청소'하는 것입니다.",
        "explanation": "리팩토링은 소프트웨어의 겉보기 동작(기능)은 그대로 유지하면서 내부 코드 구조를 정리하여 이해하기 쉽고 수정하기 쉽게 만드는 작업입니다."
    },
    {
        "level": 5,
        "problem": "보안 공격 중 'Land Attack'의 공격 방법은?",
        "options": [
            "패킷의 출발지 IP와 목적지 IP를 동일하게 설정하여 보낸다.",
            "패킷의 크기를 MTU보다 크게 설정하여 보낸다.",
            "잘못된 Fragment Offset 정보를 보낸다.",
            "ICMP 패킷을 브로드캐스팅한다."
        ],
        "answer": "패킷의 출발지 IP와 목적지 IP를 동일하게 설정하여 보낸다.",
        "hint": "자기가 자신에게 계속 응답하게 만듭니다.",
        "explanation": "Land Attack은 출발지 IP와 목적지 IP를 공격 대상의 IP로 동일하게 설정하여, 시스템이 자신에게 무한히 응답하게 만들어 부하를 일으키는 공격입니다."
    },
    {
        "level": 5,
        "problem": "서버의 가용성을 높이기 위한 HA(High Availability) 구성 방식 중, 두 대의 서버가 동시에 서비스를 수행하며 부하를 분산하다가 한 대가 장애 시 다른 한 대가 모든 처리를 담당하는 방식은?",
        "options": [
            "Active-Standby",
            "Active-Active",
            "Hot-Standby",
            "Cold-Standby"
        ],
        "answer": "Active-Active",
        "hint": "둘 다 일하고 있습니다.",
        "explanation": "Active-Active 방식은 두 노드가 동시에 서비스를 제공(부하 분산)하며, 장애 시 나머지 노드가 서비스를 승계합니다. (Active-Standby는 한 대는 대기 상태)"
    },
    {
        "level": 5,
        "problem": "다음 중 '양자 암호 통신(Quantum Cryptography)'의 핵심 기술로, 양자 중첩과 얽힘 현상을 이용하여 송수신자가 비밀키를 나누어 갖는 기술은?",
        "options": [
            "QKD (Quantum Key Distribution)",
            "PQC (Post-Quantum Cryptography)",
            "ZK-SNARK",
            "Homomorphic Encryption"
        ],
        "answer": "QKD (Quantum Key Distribution)",
        "hint": "양자 키 분배입니다.",
        "explanation": "QKD(양자 키 분배)는 양자 역학적 특성을 이용해 도청 불가능한 안전한 암호키를 생성하고 분배하는 기술입니다."
    },
    {
        "level": 5,
        "problem": "네트워크 라우팅 프로토콜 중 'OSPF'가 사용하는 알고리즘은?",
        "options": [
            "Distance Vector",
            "Link State",
            "Path Vector",
            "Spanning Tree"
        ],
        "answer": "Link State",
        "hint": "다익스트라(Dijkstra) 알고리즘을 사용합니다.",
        "explanation": "OSPF(Open Shortest Path First)는 링크 상태(Link State) 알고리즘을 사용하여 네트워크의 토폴로지 정보를 모든 라우터가 공유하고 최단 경로를 계산합니다. (RIP는 Distance Vector)"
    },
    {
        "level": 5,
        "problem": "네트워크 접근 제어(NAC)에서 단말기의 보안 상태(백신 설치 여부, OS 패치 등)를 점검하고, 정책에 부합하지 않는 단말기를 격리하거나 치료를 유도하는 과정을 무엇이라 하는가?",
        "options": [
            "인증 (Authentication)",
            "무결성 점검 (Integrity Check)",
            "격리 (Quarantine)",
            "치료 (Remediation)"
        ],
        "answer": "무결성 점검 (Integrity Check)",
        "hint": "단말기가 깨끗한 상태인지 확인하는 것입니다.",
        "explanation": "NAC의 핵심 기능 중 하나로, 네트워크 접속 시 단말기의 보안 패치, 백신 설치 여부 등을 검사하는 것을 무결성 점검이라고 합니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '랜섬웨어(Ransomware)'의 특징이 아닌 것은?",
        "options": [
            "사용자의 파일을 암호화하여 인질로 삼는다.",
            "암호 화폐(비트코인 등)를 요구한다.",
            "스스로 전파되는 웜(Worm)의 형태를 띨 수도 있다.",
            "하드웨어 자체를 물리적으로 파괴한다."
        ],
        "answer": "하드웨어 자체를 물리적으로 파괴한다.",
        "hint": "데이터를 못 쓰게 만드는 것이 목적입니다.",
        "explanation": "랜섬웨어는 소프트웨어적으로 데이터를 암호화하여 접근을 차단하는 것이 주된 공격 방식이며, 하드웨어를 물리적으로 파괴하는 것은 드뭅니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 개발 프로젝트 관리에서 'WBS(Work Breakdown Structure)'의 최하위 단위로, 관리 가능한 크기의 작업 단위를 무엇이라 하는가?",
        "options": [
            "마일스톤 (Milestone)",
            "워크 패키지 (Work Package)",
            "액티비티 (Activity)",
            "태스크 (Task)"
        ],
        "answer": "워크 패키지 (Work Package)",
        "hint": "업무(Work)를 묶어놓은 패키지입니다.",
        "explanation": "WBS의 최하위 요소로, 일정과 비용 산정, 담당자 할당의 기준이 되는 단위를 워크 패키지라고 합니다."
    },
    {
        "level": 5,
        "problem": "다음 중 'VPN(Virtual Private Network)' 구현 기술인 SSL VPN과 IPSec VPN의 차이점으로 틀린 것은?",
        "options": [
            "SSL VPN은 별도의 클라이언트 프로그램 설치 없이 웹 브라우저로 접속 가능하다.",
            "IPSec VPN은 네트워크 계층(Layer 3)에서 동작한다.",
            "SSL VPN은 애플리케이션 계층에서 동작한다.",
            "IPSec VPN은 사용자 인증 기능이 없다."
        ],
        "answer": "IPSec VPN은 사용자 인증 기능이 없다.",
        "hint": "IPSec도 IKE 등을 통해 인증을 수행합니다.",
        "explanation": "IPSec VPN도 IKE(Internet Key Exchange) 프로토콜 등을 통해 상호 인증 과정을 거칩니다."
    },
    {
        "level": 5,
        "problem": "정보보안의 3요소 중 '기밀성(Confidentiality)'을 위협하는 공격 유형은?",
        "options": [
            "DoS 공격",
            "스니핑 (Sniffing)",
            "데이터 변조",
            "재전송 공격"
        ],
        "answer": "스니핑 (Sniffing)",
        "hint": "몰래 엿보는 행위입니다.",
        "explanation": "스니핑은 네트워크상의 데이터를 도청하는 행위로 기밀성을 해칩니다. (DoS는 가용성, 변조는 무결성 위협)"
    },
    {
        "level": 5,
        "problem": "리눅스/유닉스 시스템에서 파일의 권한을 'rwxr-xr-x' (755)로 설정했을 때의 의미는?",
        "options": [
            "소유자는 읽기/쓰기/실행, 그룹과 기타 사용자는 읽기/실행만 가능",
            "소유자는 읽기/쓰기, 그룹은 읽기, 기타는 권한 없음",
            "모든 사용자가 읽기/쓰기/실행 가능",
            "소유자만 읽기/쓰기/실행 가능"
        ],
        "answer": "소유자는 읽기/쓰기/실행, 그룹과 기타 사용자는 읽기/실행만 가능",
        "hint": "r=4, w=2, x=1 입니다.",
        "explanation": "7(4+2+1)은 rwx, 5(4+0+1)는 r-x이므로 소유자는 모든 권한, 그룹과 나머지는 읽기 및 실행 권한을 가집니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '블록체인'의 '스마트 계약(Smart Contract)'을 처음으로 구현하여 2세대 블록체인이라 불리는 플랫폼은?",
        "options": [
            "Bitcoin",
            "Ethereum",
            "Ripple",
            "Hyperledger"
        ],
        "answer": "Ethereum",
        "hint": "비탈릭 부테린이 창시했습니다.",
        "explanation": "이더리움(Ethereum)은 블록체인에 프로그래밍 가능한 스마트 컨트랙트 기능을 도입하여 다양한 탈중앙화 애플리케이션(DApp)을 만들 수 있게 했습니다."
    },
    {
        "level": 5,
        "problem": "대칭키 암호화 방식 중 '스트림 암호(Stream Cipher)'에 해당하는 알고리즘은?",
        "options": [
            "DES",
            "AES",
            "RC4",
            "SEED"
        ],
        "answer": "RC4",
        "hint": "비트 단위로 연속적으로 암호화합니다.",
        "explanation": "RC4는 대표적인 스트림 암호 알고리즘입니다. DES, AES, SEED는 블록 암호 알고리즘입니다."
    },
    {
        "level": 5,
        "problem": "네트워크 공격 중 'Ping of Death' 공격의 원리는?",
        "options": [
            "규정된 크기보다 큰 ICMP 패킷을 전송하여 수신측의 버퍼 오버플로우를 유발한다.",
            "대량의 Ping 요청을 보내 대역폭을 고갈시킨다.",
            "출발지 IP를 위조하여 응답을 유도한다.",
            "ICMP Echo Reply를 차단한다."
        ],
        "answer": "규정된 크기보다 큰 ICMP 패킷을 전송하여 수신측의 버퍼 오버플로우를 유발한다.",
        "hint": "패킷이 쪼개져서 전송되었다가 재조립될 때 문제가 생깁니다.",
        "explanation": "Ping of Death는 허용 범위(65,535바이트)를 초과하는 커다란 패킷을 보내, 수신 측에서 재조립 시 오류를 발생시켜 시스템을 마비시키는 공격입니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 비용 산정 시 '기능 점수(FP)' 방식의 장점이 아닌 것은?",
        "options": [
            "사용자 관점에서 기능을 정량화한다.",
            "프로그래밍 언어에 독립적이다.",
            "개발 초기에 규모 산정이 가능하다.",
            "복잡한 내부 로직과 알고리즘을 정확히 반영한다."
        ],
        "answer": "복잡한 내부 로직과 알고리즘을 정확히 반영한다.",
        "hint": "FP는 입출력 데이터 위주입니다.",
        "explanation": "기능 점수는 사용자 관점의 입출력 데이터 기능을 측정하므로, 내부의 복잡한 알고리즘이나 기술적 난이도를 충분히 반영하지 못할 수 있다는 단점이 있습니다."
    },
    {
        "level": 5,
        "problem": "ITIL v4의 서비스 가치 시스템(SVS)의 구성 요소가 아닌 것은?",
        "options": [
            "지도 원칙 (Guiding Principles)",
            "거버넌스 (Governance)",
            "서비스 가치 사슬 (Service Value Chain)",
            "폭포수 모델 (Waterfall Model)"
        ],
        "answer": "폭포수 모델 (Waterfall Model)",
        "hint": "폭포수 모델은 고전적 개발 방법론입니다.",
        "explanation": "ITIL v4 SVS는 지도 원칙, 거버넌스, 서비스 가치 사슬, 지속적 개선, 실천(Practices) 등으로 구성됩니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '해시(Hash) 함수'의 보안 요구사항인 '충돌 회피성(Collision Resistance)'의 의미는?",
        "options": [
            "해시값으로부터 입력값을 찾는 것이 계산적으로 불가능해야 한다.",
            "입력값이 다르면 해시값도 달라야 한다는 성질을 만족하는 두 입력값을 찾는 것이 어려워야 한다.",
            "키가 없으면 해시값을 생성할 수 없어야 한다.",
            "입력값의 길이에 관계없이 고정된 길이의 출력을 내야 한다."
        ],
        "answer": "입력값이 다르면 해시값도 달라야 한다는 성질을 만족하는 두 입력값을 찾는 것이 어려워야 한다.",
        "hint": "서로 다른 두 입력이 같은 해시값을 가지면 안 됩니다.",
        "explanation": "충돌 회피성은 H(x) = H(y)가 되는 서로 다른 입력값 x, y를 찾는 것이 계산적으로 불가능해야 함을 의미합니다."
    },
    {
        "level": 5,
        "problem": "네트워크 장비 중, OSI 2계층(데이터 링크)에서 동작하며 MAC 주소를 기반으로 프레임을 전달하는 장비는?",
        "options": [
            "Hub",
            "Switch",
            "Router",
            "Gateway"
        ],
        "answer": "Switch",
        "hint": "L2 장비입니다.",
        "explanation": "스위치(Switch)는 MAC 주소 테이블을 학습하여 목적지 포트로만 프레임을 전송하는 2계층 장비입니다."
    },
    {
        "level": 5,
        "problem": "클라우드 컴퓨팅 기술 중, 물리적인 서버 한 대를 여러 개의 논리적인 서버로 나누어 사용하는 기술은?",
        "options": [
            "서버 가상화 (Server Virtualization)",
            "그리드 컴퓨팅",
            "유틸리티 컴퓨팅",
            "엣지 컴퓨팅"
        ],
        "answer": "서버 가상화 (Server Virtualization)",
        "hint": "하이퍼바이저를 사용합니다.",
        "explanation": "서버 가상화는 하이퍼바이저 등을 이용해 물리적 자원을 추상화하여 다수의 가상 머신(VM)을 구동하는 기술입니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '보안 관제 센터(SOC)'에서 주로 사용하는 시스템으로, 다양한 보안 장비의 로그를 수집 및 분석하여 위협을 탐지하는 시스템은?",
        "options": [
            "F/W (Firewall)",
            "IDS",
            "SIEM",
            "VPN"
        ],
        "answer": "SIEM",
        "hint": "Security Information and Event Management",
        "explanation": "SIEM은 방화벽, IDS, IPS 등 다양한 장비에서 발생하는 로그를 중앙에서 수집하고 상관 분석을 통해 위협을 탐지하는 솔루션입니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 생명주기 모형 중, '나선형(Spiral) 모형'의 가장 큰 특징은?",
        "options": [
            "순차적인 단계 진행",
            "위험 분석(Risk Analysis) 단계 포함",
            "프로토타입의 배제",
            "문서화의 최소화"
        ],
        "answer": "위험 분석(Risk Analysis) 단계 포함",
        "hint": "리스크를 줄이면서 반복합니다.",
        "explanation": "나선형 모형은 계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가의 과정을 반복하며 위험을 최소화하는 것이 핵심입니다."
    },
    {
        "level": 5,
        "problem": "다음 중 'OWASP Top 10'에 포함되는 웹 취약점으로, 신뢰할 수 없는 데이터가 웹 페이지에 포함되어 사용자의 브라우저에서 실행되는 공격은?",
        "options": [
            "SQL Injection",
            "XSS (Cross Site Scripting)",
            "CSRF",
            "Directory Traversal"
        ],
        "answer": "XSS (Cross Site Scripting)",
        "hint": "스크립트가 실행됩니다.",
        "explanation": "XSS는 공격자가 악성 스크립트를 웹 페이지에 삽입하여, 이를 열람하는 사용자의 브라우저에서 스크립트가 실행되게 하는 공격입니다."
    },
    {
        "level": 5,
        "problem": "네트워크 프로토콜 'ARP(Address Resolution Protocol)'의 역할은?",
        "options": [
            "IP 주소를 MAC 주소로 변환한다.",
            "MAC 주소를 IP 주소로 변환한다.",
            "도메인 이름을 IP 주소로 변환한다.",
            "사설 IP를 공인 IP로 변환한다."
        ],
        "answer": "IP 주소를 MAC 주소로 변환한다.",
        "hint": "논리 주소 -> 물리 주소",
        "explanation": "ARP는 네트워크 계층의 IP 주소를 데이터 링크 계층의 물리적 주소인 MAC 주소로 변환해 줍니다. (반대는 RARP)"
    },
    {
        "level": 5,
        "problem": "데이터베이스 암호화 방식 중, 애플리케이션 서버가 아닌 DB 서버 내부에서 암호화/복호화 모듈(API 등)을 실행하는 방식은?",
        "options": [
            "Plug-In 방식",
            "API 방식",
            "TDE (Transparent Data Encryption)",
            "File Encryption"
        ],
        "answer": "Plug-In 방식",
        "hint": "DB에 꽂아서 씁니다.",
        "explanation": "Plug-In 방식은 DB 서버 내에 암호화 모듈을 설치(플러그인)하여, DB 엔진이 암/복호화를 수행하도록 하는 방식입니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '비즈니스 연속성 계획(BCP)'의 핵심 요소로, 재해 발생 시 목표 복구 시간(허용 가능한 다운타임)을 의미하는 용어는?",
        "options": [
            "RPO (Recovery Point Objective)",
            "RTO (Recovery Time Objective)",
            "MTBF",
            "MTTR"
        ],
        "answer": "RTO (Recovery Time Objective)",
        "hint": "시간(Time)이 중요합니다.",
        "explanation": "RTO는 업무가 중단된 후 복구될 때까지 허용되는 최대 시간(목표 복구 시간)을 의미합니다. RPO는 데이터 손실 허용 시점입니다."
    },
    {
        "level": 5,
        "problem": "인공지능(AI) 학습 방법 중, 정답(Label)이 없는 데이터의 패턴이나 구조를 스스로 학습하는 방법은?",
        "options": [
            "지도 학습 (Supervised Learning)",
            "비지도 학습 (Unsupervised Learning)",
            "강화 학습 (Reinforcement Learning)",
            "전이 학습 (Transfer Learning)"
        ],
        "answer": "비지도 학습 (Unsupervised Learning)",
        "hint": "선생님 없이 혼자 공부합니다.",
        "explanation": "비지도 학습은 정답 레이블 없이 입력 데이터의 특징을 찾아 군집화하거나 차원을 축소하는 등의 학습 방법입니다."
    },
    {
        "level": 5,
        "problem": "네트워크 라우팅 프로토콜 'BGP(Border Gateway Protocol)'는 어떤 알고리즘을 사용하는가?",
        "options": [
            "Distance Vector",
            "Link State",
            "Path Vector",
            "Hybrid"
        ],
        "answer": "Path Vector",
        "hint": "경로(Path) 정보를 교환합니다.",
        "explanation": "BGP는 AS(Autonomous System) 간의 라우팅을 담당하며, 루핑 방지를 위해 경로 정보를 함께 전달하는 경로 벡터(Path Vector) 알고리즘을 사용합니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '버퍼 오버플로우(Buffer Overflow)' 공격을 방어하기 위한 메모리 보호 기법이 아닌 것은?",
        "options": [
            "ASLR (Address Space Layout Randomization)",
            "DEP (Data Execution Prevention)",
            "Stack Guard",
            "SQL Filter"
        ],
        "answer": "SQL Filter",
        "hint": "SQL Filter는 웹 공격 방어용입니다.",
        "explanation": "ASLR, DEP, Stack Guard는 시스템 메모리 보호 기법이며, SQL Filter는 SQL Injection을 막기 위한 애플리케이션 레벨의 방어입니다."
    },
    {
        "level": 5,
        "problem": "COCOMO 비용 산정 모델의 프로젝트 모드 중, 트랜잭션 처리 시스템이나 운영체제와 같이 복잡하고 하드웨어 제약이 큰 소프트웨어를 개발하는 모드는?",
        "options": [
            "Organic Mode",
            "Semi-Detached Mode",
            "Embedded Mode",
            "Application Mode"
        ],
        "answer": "Embedded Mode",
        "hint": "내장형 시스템입니다.",
        "explanation": "Embedded Mode는 초대형 규모이거나 복잡하고 제약 조건이 많은 시스템(OS, 실시간 시스템 등) 개발에 적용되는 모드입니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '데이터 3법' 개정으로 도입된 개념으로, 추가 정보 없이는 특정 개인을 알아볼 수 없도록 처리한 정보를 무엇이라 하는가?",
        "options": [
            "익명 정보",
            "가명 정보",
            "개인 정보",
            "공공 정보"
        ],
        "answer": "가명 정보",
        "hint": "가짜 이름을 쓴 정보입니다.",
        "explanation": "가명 정보는 개인정보의 일부를 삭제하거나 대체하여, 추가 정보의 결합 없이는 특정 개인을 식별할 수 없도록 처리한 정보로, 통계 작성이나 연구 목적으로 활용 가능합니다."
    },
    {
        "level": 5,
        "problem": "네트워크 보안 장비 중 'UTM(Unified Threat Management)'의 특징은?",
        "options": [
            "단일 기능을 고성능으로 제공한다.",
            "방화벽, IDS, IPS, VPN 등 여러 보안 기능을 하나의 장비로 통합하여 제공한다.",
            "무선 네트워크 전용 보안 장비이다.",
            "물리적 계층의 보안만 담당한다."
        ],
        "answer": "방화벽, IDS, IPS, VPN 등 여러 보안 기능을 하나의 장비로 통합하여 제공한다.",
        "hint": "통합 위협 관리 시스템입니다.",
        "explanation": "UTM은 여러 보안 솔루션을 하나의 하드웨어에 통합하여 관리 편의성과 비용 효율성을 높인 장비입니다."
    },
    {
        "level": 5,
        "problem": "리눅스 명령어 중 현재 실행 중인 프로세스의 목록과 상태를 실시간으로 확인하는 명령어는?",
        "options": [
            "ps",
            "top",
            "kill",
            "nice"
        ],
        "answer": "top",
        "hint": "가장 CPU를 많이 쓰는 프로세스가 맨 위에(top) 뜹니다.",
        "explanation": "top 명령어는 시스템의 프로세스 상태, CPU/메모리 점유율 등을 실시간으로 갱신하며 보여줍니다. (ps는 순간의 스냅샷)"
    },
    {
        "level": 5,
        "problem": "소프트웨어 아키텍처 패턴 중 '브로커(Broker) 패턴'의 주된 용도는?",
        "options": [
            "분산 시스템에서 원격 서비스 호출을 조정한다.",
            "데이터베이스 접근을 추상화한다.",
            "사용자 인터페이스를 분리한다.",
            "객체의 상태 변화를 통지한다."
        ],
        "answer": "분산 시스템에서 원격 서비스 호출을 조정한다.",
        "hint": "중개자 역할을 합니다.",
        "explanation": "브로커 패턴은 분산 환경에서 클라이언트와 서버 간의 통신을 중개(Broker)하여 위치 투명성을 제공하는 패턴입니다. (예: CORBA)"
    },
    {
        "level": 5,
        "problem": "다음 중 '애자일(Agile)' 개발 방법론에 해당하지 않는 것은?",
        "options": [
            "Scrum",
            "XP (eXtreme Programming)",
            "Kanban",
            "Waterfall"
        ],
        "answer": "Waterfall",
        "hint": "폭포수 모델입니다.",
        "explanation": "Waterfall(폭포수) 모델은 전통적인 순차적 개발 방법론이며, 애자일 방법론과 대비됩니다."
    },
    {
        "level": 5,
        "problem": "네트워크 공격 기법 중 'CSRF(Cross-Site Request Forgery)'의 설명으로 옳은 것은?",
        "options": [
            "사용자의 세션 쿠키를 훔친다.",
            "사용자가 자신의 의지와 무관하게 공격자가 의도한 행위(수정, 삭제 등)를 하게 만든다.",
            "서버의 관리자 권한을 획득한다.",
            "데이터베이스 쿼리를 조작한다."
        ],
        "answer": "사용자가 자신의 의지와 무관하게 공격자가 의도한 행위(수정, 삭제 등)를 하게 만든다.",
        "hint": "위조된 요청을 보냅니다.",
        "explanation": "CSRF는 이미 로그인된 사용자의 권한을 도용하여, 사용자가 모르는 사이에 공격자가 준비한 요청(비밀번호 변경, 글쓰기 등)을 서버에 전송하게 하는 공격입니다."
    },
    {
        "level": 5,
        "problem": "시스템의 고가용성(HA)을 위해 디스크를 공유하지 않고 네트워크를 통해 데이터를 복제하는 방식의 클러스터링은?",
        "options": [
            "Shared Disk",
            "Shared Nothing",
            "RAID",
            "SAN"
        ],
        "answer": "Shared Nothing",
        "hint": "아무것도 공유하지 않습니다.",
        "explanation": "Shared Nothing 구조는 각 노드가 독립적인 메모리와 디스크를 가지고 있으며, 노드 간 데이터 일관성은 네트워크를 통한 메시지 전달로 유지합니다."
    },
    {
        "level": 5,
        "problem": "정보시스템 감리 영역 중 '준거성(Compliance)' 감리의 목적은?",
        "options": [
            "시스템의 성능이 목표치를 달성했는지 확인",
            "법규, 표준, 지침 등을 준수하고 있는지 확인",
            "사용자 요구사항이 반영되었는지 확인",
            "코드의 품질을 검증"
        ],
        "answer": "법규, 표준, 지침 등을 준수하고 있는지 확인",
        "hint": "규칙을 잘 지키는지 봅니다.",
        "explanation": "준거성 감리는 정보시스템 구축 및 운영 과정이 관련 법령, 규정, 표준 등을 준수하고 있는지 확인하는 활동입니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '온톨로지(Ontology)'의 정의로 가장 적절한 것은?",
        "options": [
            "실세계에 존재하는 개념과 개념 간의 관계를 컴퓨터가 이해할 수 있도록 명세한 것",
            "대용량 데이터를 분산 처리하는 프레임워크",
            "인간의 뇌 신경망을 모방한 알고리즘",
            "네트워크 패킷을 분석하는 도구"
        ],
        "answer": "실세계에 존재하는 개념과 개념 간의 관계를 컴퓨터가 이해할 수 있도록 명세한 것",
        "hint": "시맨틱 웹의 핵심 기술입니다.",
        "explanation": "온톨로지는 지식 표현 기술의 하나로, 특정 도메인의 개념과 관계를 정형화하여 정의한 것입니다."
    },
    {
        "level": 5,
        "problem": "네트워크 기술 중 'VLAN(Virtual LAN)'의 주요 목적은?",
        "options": [
            "물리적 배선 변경 없이 논리적으로 네트워크를 분할하여 브로드캐스트 도메인을 줄인다.",
            "네트워크 대역폭을 물리적으로 확장한다.",
            "장거리 통신을 가능하게 한다.",
            "무선 네트워크 신호를 증폭한다."
        ],
        "answer": "물리적 배선 변경 없이 논리적으로 네트워크를 분할하여 브로드캐스트 도메인을 줄인다.",
        "hint": "가상의 그룹을 만듭니다.",
        "explanation": "VLAN은 스위치에서 논리적으로 네트워크를 나누어 브로드캐스트 트래픽을 격리하고 보안과 효율성을 높이는 기술입니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 테스트 기법 중 '알파 테스트'와 '베타 테스트'는 어느 단계에 속하는가?",
        "options": [
            "단위 테스트",
            "통합 테스트",
            "시스템 테스트",
            "인수 테스트"
        ],
        "answer": "인수 테스트",
        "hint": "사용자가 최종적으로 확인합니다.",
        "explanation": "인수 테스트(Acceptance Test)는 사용자가 요구사항을 만족하는지 확인하는 단계로, 알파(개발 환경) 및 베타(실제 환경) 테스트가 포함됩니다."
    },
    {
        "level": 5,
        "problem": "다음 중 'AAA' 보안 프레임워크의 구성 요소가 아닌 것은?",
        "options": [
            "Authentication (인증)",
            "Authorization (인가)",
            "Accounting (계정 관리/과금)",
            "Availability (가용성)"
        ],
        "answer": "Availability (가용성)",
        "hint": "CIA의 A가 아닙니다.",
        "explanation": "AAA는 인증(Authentication), 인가(Authorization), 계정 관리(Accounting)를 의미하는 보안 프레임워크입니다."
    },
    {
        "level": 5,
        "problem": "리눅스 시스템에서 'crontab' 명령어의 용도는?",
        "options": [
            "파일 압축",
            "주기적인 작업 예약",
            "네트워크 설정",
            "사용자 계정 생성"
        ],
        "answer": "주기적인 작업 예약",
        "hint": "스케줄러입니다.",
        "explanation": "crontab은 특정 시간에 특정 작업을 주기적으로 실행하도록 예약하는 스케줄링 명령어입니다."
    },
    {
        "level": 5,
        "problem": "최신 웹 기술 중 'PWA(Progressive Web Apps)'의 특징은?",
        "options": [
            "웹 기술로 개발되었지만 네이티브 앱과 유사한 사용자 경험(오프라인 실행, 푸시 알림 등)을 제공한다.",
            "반드시 앱 스토어를 통해서만 설치해야 한다.",
            "플래시(Flash) 기반으로 동작한다.",
            "서버 사이드 렌더링만 지원한다."
        ],
        "answer": "웹 기술로 개발되었지만 네이티브 앱과 유사한 사용자 경험(오프라인 실행, 푸시 알림 등)을 제공한다.",
        "hint": "웹과 앱의 장점을 합쳤습니다.",
        "explanation": "PWA는 모바일 웹을 네이티브 앱처럼 사용할 수 있게 해주는 기술로, 서비스 워커 등을 이용해 오프라인 기능 등을 지원합니다."
    },
    {
        "level": 5,
        "problem": "정보보안 용어 중 '사회 공학(Social Engineering)' 기법이란?",
        "options": [
            "시스템의 기술적 취약점을 이용하는 공격",
            "사람의 심리적 약점이나 신뢰를 이용하여 정보를 획득하는 공격",
            "네트워크 장비를 물리적으로 파괴하는 공격",
            "암호 알고리즘을 수학적으로 해독하는 공격"
        ],
        "answer": "사람의 심리적 약점이나 신뢰를 이용하여 정보를 획득하는 공격",
        "hint": "보이스피싱이 대표적입니다.",
        "explanation": "사회 공학은 기술적인 해킹보다는 사람을 속여서 비밀번호를 알아내거나 보안 절차를 우회하는 비기술적 공격 기법입니다."
    },
    {
        "level": 5,
        "problem": "데이터베이스 트랜잭션의 격리 수준(Isolation Level) 중 가장 엄격하지만 성능이 느린 수준은?",
        "options": [
            "Read Uncommitted",
            "Read Committed",
            "Repeatable Read",
            "Serializable"
        ],
        "answer": "Serializable",
        "hint": "직렬화 가능",
        "explanation": "Serializable은 트랜잭션을 순차적으로 실행하는 것처럼 완벽하게 격리하여 동시성은 가장 낮지만 데이터 일관성은 가장 높습니다."
    },
    {
        "level": 5,
        "problem": "클라우드 서비스 모델 중 'SaaS(Software as a Service)'의 예시로 적절한 것은?",
        "options": [
            "Amazon EC2",
            "Google App Engine",
            "Microsoft Office 365",
            "Linux OS"
        ],
        "answer": "Microsoft Office 365",
        "hint": "완제품 소프트웨어를 빌려 씁니다.",
        "explanation": "Office 365, Gmail, Dropbox 등은 사용자에게 완성된 소프트웨어를 서비스 형태로 제공하는 SaaS입니다."
    },
    {
        "level": 5,
        "problem": "네트워크 프로토콜 'ICMP(Internet Control Message Protocol)'의 주요 기능은?",
        "options": [
            "대용량 파일 전송",
            "오류 보고 및 네트워크 상태 진단 (Ping 등)",
            "이메일 전송",
            "웹 페이지 요청"
        ],
        "answer": "오류 보고 및 네트워크 상태 진단 (Ping 등)",
        "hint": "Ping 명령어가 이것을 씁니다.",
        "explanation": "ICMP는 IP 패킷 전송 중 발생하는 오류를 보고하거나 네트워크 상태를 확인하기 위해 사용됩니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 개발 방법론 중 'TDD(Test Driven Development)'의 개발 순서는?",
        "options": [
            "코드 작성 -> 테스트 작성 -> 리팩토링",
            "테스트 작성 -> 코드 작성(테스트 통과) -> 리팩토링",
            "설계 -> 코드 작성 -> 테스트",
            "요구사항 분석 -> 테스트 -> 코드 작성"
        ],
        "answer": "테스트 작성 -> 코드 작성(테스트 통과) -> 리팩토링",
        "hint": "테스트를 먼저 만듭니다.",
        "explanation": "TDD는 실패하는 테스트 케이스를 먼저 작성하고, 이를 통과하기 위한 최소한의 코드를 작성한 후, 리팩토링하는 과정을 반복합니다."
    },
    {
        "level": 5,
        "problem": "다음 중 'SSO(Single Sign-On)'의 개념은?",
        "options": [
            "한 번의 로그아웃으로 모든 시스템에서 로그아웃된다.",
            "하나의 시스템에서 인증에 성공하면 다른 연결된 시스템도 별도의 인증 없이 사용할 수 있다.",
            "매번 새로운 비밀번호를 생성한다.",
            "두 가지 이상의 인증 수단을 사용한다."
        ],
        "answer": "하나의 시스템에서 인증에 성공하면 다른 연결된 시스템도 별도의 인증 없이 사용할 수 있다.",
        "hint": "통합 로그인입니다.",
        "explanation": "SSO는 한 번의 로그인(인증)으로 연동된 모든 시스템이나 서비스를 이용할 수 있게 해주는 인증 시스템입니다."
    },
    {
        "level": 5,
        "problem": "리눅스 파일 시스템에서 'inode'가 저장하는 정보가 아닌 것은?",
        "options": [
            "파일 소유자",
            "파일 크기",
            "파일 생성 시간",
            "파일 이름"
        ],
        "answer": "파일 이름",
        "hint": "이름은 디렉터리 엔트리에 저장됩니다.",
        "explanation": "inode는 파일의 메타데이터(권한, 소유자, 크기, 위치 등)를 저장하지만, 파일 이름은 디렉터리 엔트리(Directory Entry)에 저장됩니다."
    },
    {
        "level": 5,
        "problem": "최신 네트워크 기술 'Edge Computing'의 장점은?",
        "options": [
            "모든 데이터를 중앙 클라우드로 전송하여 처리한다.",
            "데이터 발생 지점 근처에서 데이터를 처리하여 지연 시간(Latency)을 줄인다.",
            "네트워크 대역폭 사용량을 늘린다.",
            "보안 관리가 중앙 집중화되어 쉽다."
        ],
        "answer": "데이터 발생 지점 근처에서 데이터를 처리하여 지연 시간(Latency)을 줄인다.",
        "hint": "가장자리(Edge)에서 처리합니다.",
        "explanation": "엣지 컴퓨팅은 데이터를 중앙 데이터센터가 아닌 단말 근처에서 처리하여 응답 속도를 높이고 대역폭을 절약하는 기술입니다."
    },
    {
        "level": 5,
        "problem": "암호화 기술 중 '전자봉투(Digital Envelope)'를 생성할 때 사용하는 키는?",
        "options": [
            "송신자의 공개키",
            "송신자의 개인키",
            "수신자의 공개키",
            "수신자의 개인키"
        ],
        "answer": "수신자의 공개키",
        "hint": "받는 사람만 열어봐야 합니다.",
        "explanation": "전자봉투는 대칭키(세션키)를 수신자의 공개키로 암호화한 것입니다. 따라서 수신자만이 자신의 개인키로 열어볼 수 있습니다."
    },
    {
        "level": 5,
        "problem": "소프트웨어 유지보수성 향상을 위한 지표 중 'McCabe의 순환 복잡도(Cyclomatic Complexity)' 계산 공식은? (E: 간선 수, N: 노드 수)",
        "options": [
            "E - N + 2",
            "E + N + 2",
            "N - E + 2",
            "E * N / 2"
        ],
        "answer": "E - N + 2",
        "hint": "간선 빼기 노드 더하기 2",
        "explanation": "순환 복잡도 V(G) = E(Edge) - N(Node) + 2 입니다."
    },
    {
        "level": 5,
        "problem": "다음 중 '다크 데이터(Dark Data)'의 의미는?",
        "options": [
            "해커들이 사용하는 데이터",
            "기업 내에 저장되어 있으나 분석되거나 활용되지 않는 데이터",
            "암호화된 데이터",
            "삭제된 데이터"
        ],
        "answer": "기업 내에 저장되어 있으나 분석되거나 활용되지 않는 데이터",
        "hint": "어둠 속에 묻혀 있는 데이터입니다.",
        "explanation": "다크 데이터는 정보를 수집하고 저장했지만, 비즈니스 목적 등으로 활용되지 않고 방치된 데이터를 말합니다."
    },
    {
        "level": 5,
        "problem": "공격자가 패킷의 출발지 IP를 공격 대상의 IP로 위조하여 다수의 서버에 ICMP Echo Request를 보내고, 이에 대한 응답(Echo Reply)이 공격 대상에게 쏟아지게 하는 공격은?",
        "options": [
            "Smurf Attack",
            "Flooding Attack",
            "Spoofing Attack",
            "Sniffing Attack"
        ],
        "answer": "Smurf Attack",
        "hint": "증폭 공격의 일종입니다.",
        "explanation": "Smurf Attack은 브로드캐스트를 통해 다수의 에이전트가 위조된 출발지(피해자)로 응답을 보내게 하여 트래픽을 증폭시키는 공격입니다."
    }
]